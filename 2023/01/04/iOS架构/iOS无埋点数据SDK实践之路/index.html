<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="google90a27f59c648608f.html">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文为转载。 作者：zerygao链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;69ce01e15042来源：简书 本篇文章是基于 网易乐得无埋点数据SDK 总结而成。负责无埋点数据收集 SDK 的开发已经有半年多了，期间在组内进行过相关分享，现在觉得是时候拿出去和同行们交流下了。本篇主要讲一下SDK的整体实现思路以及关键的技术点。 SDK 已经具备不需要代码埋点就能 自动的、动态可配">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS无埋点数据SDK实践之路">
<meta property="og:url" content="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="本文为转载。 作者：zerygao链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;69ce01e15042来源：简书 本篇文章是基于 网易乐得无埋点数据SDK 总结而成。负责无埋点数据收集 SDK 的开发已经有半年多了，期间在组内进行过相关分享，现在觉得是时候拿出去和同行们交流下了。本篇主要讲一下SDK的整体实现思路以及关键的技术点。 SDK 已经具备不需要代码埋点就能 自动的、动态可配">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/1.webp">
<meta property="og:image" content="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/2.webp">
<meta property="og:image" content="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/3.webp">
<meta property="article:published_time" content="2023-01-04T08:40:08.000Z">
<meta property="article:modified_time" content="2023-01-04T09:04:28.121Z">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="架构">
<meta property="article:tag" content="埋点">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/1.webp">

<link rel="canonical" href="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>iOS无埋点数据SDK实践之路 | 不会飞的小白</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=253081122# <app_id>"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '253081122# <app_id>');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不会飞的小白</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS无埋点数据SDK实践之路
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-04 16:40:08 / 修改时间：17:04:28" itemprop="dateCreated datePublished" datetime="2023-01-04T16:40:08+08:00">2023-01-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文为转载。</p>
<p>作者：zerygao<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/69ce01e15042">https://www.jianshu.com/p/69ce01e15042</a><br>来源：简书</p>
<p>本篇文章是基于 网易乐得无埋点数据SDK 总结而成。负责无埋点数据收集 SDK 的开发已经有半年多了，期间在组内进行过相关分享，现在觉得是时候拿出去和同行们交流下了。本篇主要讲一下SDK的整体实现思路以及关键的技术点。</p>
<p>SDK 已经具备不需要代码埋点就能 <strong>自动的</strong>、<strong>动态可配的</strong>、<strong>全面且正确</strong> 的收集用户在使用 App 时的所有事件数据。除此之外，还单独开发了与之配合的圈选SDK，能够在 App 端完成对界面元素的圈配以及 KVC 配置的上传。而界面元素圈配的工作完全可以交给用研与产品人员来做，减轻了开发人员的工作量。</p>
<p>SDK 已有的功能可以分为两大部分：</p>
<ul>
<li><strong>基本事件数据的收集</strong>：基本事件的收集是指应用冷启动事件、页面事件、用户点击事件、<code>ScrollView</code>滑动事件等，这部分全部都是自动完成的，实现思路会在第一节中介绍。</li>
<li><strong>业务层数据的收集</strong>：业务层数据的收集是指对与业务功能相关的一些数据，例如：在用户点击提交订单按钮时，收集用户购买的物品以及订单总金额的数据。这种业务层数据的收集以往大多通过 <em>代码埋点</em> 的方式去做，本SDK则真正的实现了 <strong><code>无埋点</code></strong> 的去获取这些想要的业务数据。这部分的实现会在本文的第二节详细介绍。</li>
</ul>
<h2 id="SDK的整体实现思路"><a href="#SDK的整体实现思路" class="headerlink" title="SDK的整体实现思路"></a>SDK的整体实现思路</h2><p>SDK 整体采用了 AOP（Aspect-Oriented-Programming）即面向切面编程的思想，就是动态的在函数调用的前后插入数据收集的代码。在 Objective-C 中的实现是基于 <code>Runtime</code> 特性的 <code>Method Swizzling</code> 黑魔法。</p>
<p>SDK 的数据收集功能的实现主要通过 <code>Method Swizzling</code> 来 <code>hook</code> 相应的方法。<code>hook</code>的方法大致可以分为3类：系统类的方法、系统类的<code>Delegate</code>方法、自定义类的方法。</p>
<h3 id="系统类的方法"><a href="#系统类的方法" class="headerlink" title="系统类的方法"></a>系统类的方法</h3><p>系统类的方法是指系统框架中提供的基础类的方法，如 <code>UIApplication</code>、<code>UIViewController</code> 等。SDK 在实现某些功能时，需要<code>hook</code>这些类的方法。例如在实现对页面事件的收集时，主要<code>hook</code>了 <code>UIViewController</code> 的生命周期的方法：<code>viewDidLoad</code>、<code>viewDidAppear</code>、<code>viewDidDisappear</code>、<code>dealloc</code></p>
<h3 id="系统类的-Delegate-方法"><a href="#系统类的-Delegate-方法" class="headerlink" title="系统类的 Delegate 方法"></a>系统类的 Delegate 方法</h3><p>系统类的 Delegate 方法主要指 UIKit 框架中提供的 Delegate 中的方法，如 UIScrollViewDelegate、UITableViewDelegate、UIWebViewDelegate 等。SDK 中的大多数功能都是通过<code>hook</code>这些协议中的方法来完成的。例如在实现列表元素点击事件的收集时，主要 <code>hook</code> 了 <code>UITableViewDelegate</code> 中的 <code>tableView:didSelectRowAtIndexPath:</code> 方法。</p>
<h3 id="自定义类的方法"><a href="#自定义类的方法" class="headerlink" title="自定义类的方法"></a>自定义类的方法</h3><p>顾名思义，自定义类的方法是指开发人员在工程中自已定义的类，而非系统类的方法。SDK的一些功能是通过<code>hook</code> 这些类的方法来实现。例如在SDK实现对手势操作的事件收集时，需要<code>hook</code>手势对象所指定的target 中的 action 方法，而 target 通常都是自定义类。其实<code>hook</code>系统类的 delegate 方法也可以看成是 hook 自定义类的方法，因为系统类的 delegate 方法大多都是需要在自定义类中实现。</p>
<p>这部分看起来是借助于 AOP 来添加数据收集的代码，但是在真正做的时候，也并没有想的那么简单，涉及到很多细节上的问题，例如：如何将导航栏与系统弹窗的点击事件归属到合适页面中、如何区分<code>UIControlEventValueChanged</code>事件、如何解决<code>hook</code>手势操作引起的性能问题等等。不过这部分内容并不是本篇文章的重点，因此这里不打算多说，之后会单独写一篇文章来讲述遇到的一些坑。</p>
<h2 id="SDK的关键技术的实现"><a href="#SDK的关键技术的实现" class="headerlink" title="SDK的关键技术的实现"></a>SDK的关键技术的实现</h2><h3 id="viewPath-及-viewId-的生成及优化"><a href="#viewPath-及-viewId-的生成及优化" class="headerlink" title="viewPath 及 viewId 的生成及优化"></a>viewPath 及 viewId 的生成及优化</h3><p>为了对 APP 中某个页面的某个 view 进行数据收集、统计与分析，首先就需要能够唯一的标识与定位这个视图，这可以说是数据收集 SDK 的一个重要前提。那么怎样去唯一的标识 APP 中的某个 view 呢？SDK 中使用了 <code>viewPath</code> 与 <code>viewId</code> 来完成。</p>
<h4 id="1-viewPath-的组成"><a href="#1-viewPath-的组成" class="headerlink" title="1. viewPath 的组成"></a>1. viewPath 的组成</h4><p>其实整个 APP 的视图结构可以看成是一颗树（<code>viewTree</code>），树的根节点就是 UIWindow，树的枝干由<code>UIViewController</code>及<code>UIView</code>组成，树的叶节点都是由<code>UIView</code>组成。</p>
<p>那么在<code>viewTree</code>中用什么信息来表示其中任意一个 view 的位置呢？很容易想到的就是使用目标 view 到根之间的每个节点的深度（层次）组成一个路径，而节点的深度（层次）是指此节点在父节点中的 index。这样确实能够唯一的表示此 view 了，但是有一个缺点：它的可读性很差。因此在此基础上又增加了每个节点的名称，节点的名称由当前节点的 view 的类名来表示。</p>
<p>因此，在 <code>viewTree</code> 中，由一个 view 到根节点之间的每个节点的名称与深度（层次）共同组成的信息构成了此 view 的<code>viewPath</code>。另外，由于在做 view 的统计分析时，都是以页面为单位的，因此 SDK 在生成 <code>viewPath</code> 时，只到 view 所在的 UIViewController 级别，而非根部的 UIWindow。这样做也在一定程度上减少了<code>viewPath</code> 的长度。</p>
<h4 id="2-UITableViewCell-x2F-UICollectionCell-的深度表示"><a href="#2-UITableViewCell-x2F-UICollectionCell-的深度表示" class="headerlink" title="2. UITableViewCell&#x2F;UICollectionCell 的深度表示"></a>2. UITableViewCell&#x2F;UICollectionCell 的深度表示</h4><p>在 App 开发中，最常用而且最重要的控件就是<code>UITableView</code>与<code>UICollectionView</code>。针对这种可复用视图，里面会包含很多 Cell，而且 Cell 个数也不确定，那么里面的每一个 Cell 应该怎么去表示其深度呢？答案是<code>indexPath</code>。虽然每个 Cell 都可能被复用，但是不同的 Cell 都对应一个唯一的<code>indexPath</code>，因此完全可以使用<code>indexPath</code>值来表示其深度。</p>
<h4 id="3-viewPath-的表示形式与示例"><a href="#3-viewPath-的表示形式与示例" class="headerlink" title="3. viewPath 的表示形式与示例"></a>3. viewPath 的表示形式与示例</h4><p>我们已经知道，<code>viewPath</code>就是由各节点的类名与深度组成，那么接下来就使用这些信息来表示出 <code>viewPath</code>。下面结合一个具体的示例来简单说一下，我随便从项目中找了一个：</p>
<p>路径中各个节点的类名是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HYGHallSlideViewController-<span class="built_in">UIScrollView</span>-HYGHallProductTableView-<span class="built_in">UITableViewWrapperView</span>-HYGHallProductCell-<span class="built_in">UITableViewCellContentView</span>-HYGHallProductView。</span><br></pre></td></tr></table></figure>

<p>路径中各个节点的深度是：<code>0-0-1-0-0:2-0-1</code></p>
<p>接下来就是将这两者放到一起来构成 <code>viewPath</code>，SDK 的表示方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewPath：HYGHallSlideViewController-UIScrollView-HYGHallProductTableView-UITableViewWrapperView-HYGHallProductCell-UITableViewCellContentView-HYGHallProductView &amp; 0-0-1-0-0:2-0-1</span><br></pre></td></tr></table></figure>

<p>其实就是使用 <code>&amp;</code> 连接符简单的拼接到一起。这样做可以方便将两者组合与分离开，便于后面的<code>viewPath</code>匹配。另外，网上还有一种类似于 <code>xPath</code> 的表示方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HYGHallSlideViewController[0]/UIScrollView[0]/HYGHallProductTableView[1]/UITableViewWrapperView[0]/HYGHallProductCell[0:2]/UITableViewCellContentView[0]/HYGHallProductView[1]</span><br></pre></td></tr></table></figure>



<p>不过个人觉得<code>xPath</code>的方式稍微复杂了点，在组合以及拆分上都相对麻烦些。不过话说回来，<code>viewPath</code>的形式是次要的，大家可以按照各自喜欢的方式去表示就行，无须纠结于哪种形式更好。</p>
<h4 id="4-针对-viewPath-的优化"><a href="#4-针对-viewPath-的优化" class="headerlink" title="4.针对 viewPath 的优化"></a>4.针对 viewPath 的优化</h4><h5 id="4-1-优化节点的深度的计算方式"><a href="#4-1-优化节点的深度的计算方式" class="headerlink" title="4.1 优化节点的深度的计算方式"></a>4.1 优化节点的深度的计算方式</h5><p>上面提到在计算各节点的深度时，是采用当前 view 位于其父 view 中的所有子 view 中的 index 值。不过在实际的开发中，<code>viewTree</code> 有时候会根据用户的操作有所变动。仍然举个栗子：</p>
<ul>
<li>假设一个 UIView 中有三个子 view，先后加入的顺序是：label、button1、button2，按照之前的计算方式，这 3  个子 view 的深度依次是：0、1、2。这时候用户点击了一个按钮，label1 从父 view 中被移除了。此时 UIView 只有 2  个子view：button1、button2，而且深度变为了：0、1。如图所示：</li>
</ul>
<p><img src="1.webp" alt="img"></p>
<p>可以看出仅仅由于其中一个子view 被移除，却导致其它子 view 的深度都发生了变化。因此，SDK 为了在新增&#x2F;移除某一 view  时，尽量减少对已有 view 的深度的影响，调整了对节点的深度的计算方式：采用当前 view 位于其父 view 中的所有 <strong>同类型</strong> 子 view 中的index 值。</p>
<p>我们再看一下上面的这个例子，最初 label、button1、button2 的深度依次是：0、0、1。在 label  被移除后，button1、button2 的深度依次为：0、1。可以看出，在这个例子中，label 的移除并未对 button1、button2 的深度造成影响，这种调整后的计算方式在一定程度上增强了 <code>viewPath</code> 的抗干扰性。</p>
<p>另外，调整后的深度的计算方式是依赖于各节点的类型的，因此，此时必须要将各节点的名称放到<code>viewPath</code>中，而不再是仅仅为了增加可读性。</p>
<h5 id="4-2-viewPath-针对-Swift-的优化"><a href="#4-2-viewPath-针对-Swift-的优化" class="headerlink" title="4.2 viewPath 针对 Swift 的优化"></a>4.2 viewPath 针对 Swift 的优化</h5><p>众所周知，<code>Swift</code>文件在获取其类名时，会自动添加此文件所在的<code>Module</code>名前缀：如果<code>Swift</code>文件在主工程中，则会添加工程的名字；如果是在某个组件中，并且项目开启了 <code>use frameworks!</code> 选项，则会添加组件的名字。总的来说，在含有swift 的项目中（包括纯 swift&#x2F;OC 与 swift 混编），<code>viewPath</code>中会包含各 Swift 文件的<code>ModuleName</code>，那么在如下情况下：</p>
<ul>
<li>某个 OC 文件被使用 Swift 重写了</li>
<li>某个 Swift 文件被从主工程移至某个组件库中，或者从组件库移至主工程中</li>
<li>主工程在引用组件库时，在开启与关闭<code>use frameworks!</code>之间进行切换</li>
</ul>
<p>上述3种情况下，文件的类名都会由于<code>ModuleName</code>而发生变化，进而会导致 <code>viewPath</code> 的改变，工程文件在结构上的调整都可能会直接对<code>viewPath</code>造成影响。</p>
<p>实际开发中，特别是对于较老的<code>OC</code>项目，经常会对项目的<code>OC</code>文件使用<code>Swift</code>重写。因此 SDK 有必要去避免<code>viewPath</code>因为这类情况而发生变化。</p>
<p>其实这个问题的解决方案很简单，既然是由于类名中的<code>ModuleName</code>前缀的改变造成的，那么就干脆在生成<code>viewPath</code>时，去掉所有的<code>Swift</code>的<code>ModuleName</code>前缀。这种做法能够解决对<code>viewPath</code>的影响，但是细心的人可能会意识到另一个隐藏的问题：如果在不同的组件库中，两个不同的视图或控制器具有相同的名字（在<code>Swift</code>中是允许的，因为有<code>Module</code>进行区分），这种情况下，<code>viewPath</code>是否存在无法区分的情况？</p>
<p>其实经过仔细考虑，这个担忧有点多余，因为就算两个Module中的视图或控制器名字一样，但是他们里面的视图结构会有所不同，进而深度也不一样，<code>viewPath</code>也不会完全相同。</p>
<h5 id="4-3-在包含子VC时，优化VC的深度的计算"><a href="#4-3-在包含子VC时，优化VC的深度的计算" class="headerlink" title="4.3 在包含子VC时，优化VC的深度的计算"></a>4.3 在包含子VC时，优化VC的深度的计算</h5><p>前面提到，<code>viewPath</code>只表示到距离 view 最近的一个 VC，VC 的深度的计算也是此 VC 的 view 所在的父 view 的所有子 view 中的深度。在实际的 iOS 开发中，可能会经常使用<code>addChildViewController:</code>添加多个子 VC 来实现复杂的页面，但是在包含子 VC 时，VC 的深度计算就有可能会存在问题。还是举一个简单的栗子：</p>
<ul>
<li>假设一个 containerVC  中包含4个子VC：VC1、VC2、VC3、VC4。在每个子VC首次被展示时，子VC会先被add进来，而子 VC 的 view 也会被 add  到一个scrollView  上。这时候这几个子VC首次的查看顺序的不同将会导致它们的深度的变化：如果查看顺序是：VC1、VC2、VC3、VC4，那么它们的深度依次 为：VC1（0）、VC2（1）、VC3（2）、VC4（3）；如果查看顺序是：VC3、VC1、VC4、VC2，深度则变成了：VC1（1）、 VC2（3）、VC3（0）、VC4（2）。这种情况导致 <code>viewPath</code> 不可靠且无法保证唯一性。</li>
</ul>
<p>SDK 为了解决上述情况，调整了 VC 的深度的计算：不再采用其 view 的深度，而是直接使用固定的0。因为 VC 已经是<code>viewPath</code>的根级别了，它的深度信息已经不重要了。</p>
<p>不过这种方案会引起另一个小问题，如果上述子 VC 的 VC1 和 VC2 是同一个类的不同实例，那么他们内部的视图结构是完全一样的，这时候如果使用固定的 VC 深度（0），通过<code>viewPath</code>就无法区分具体是哪个子 VC 的 view 了。针对这种同一类的不同实例，如果想进一步区分它们，SDK 采用了另一个方案：页面别名。</p>
<h4 id="5-viewId-的生成"><a href="#5-viewId-的生成" class="headerlink" title="5. viewId 的生成"></a>5. viewId 的生成</h4><p><code>viewPath</code> 已经能够唯一标识某个 view 了，为何还需要<code>viewId</code>呢？其实主要原因是：<code>viewPath</code> 的长度不固定，而且一般都会比较长，不便于后台使用它作为 view 的唯一标识。因此 SDK 使用<code>viewPath</code>信息通过<code>MD5</code>加密生成一个固定长度的值作为<code>viewId</code>。</p>
<h4 id="6-viewPath-与-viewId-重复时的解决方案"><a href="#6-viewPath-与-viewId-重复时的解决方案" class="headerlink" title="6. viewPath 与 viewId 重复时的解决方案"></a>6. viewPath 与 viewId 重复时的解决方案</h4><p>经过对<code>viewPath</code>的优化，SDK 已经尽可能的保证了<code>viewPath</code>的稳定性。但是并不表示只依靠<code>viewPath</code>就能区分所有的点击事件。有时同一个<code>viewPath</code>的 view 具有不同的表现形式与作用，例如下面的情况：</p>
<ul>
<li>同一个按钮在不同的状态下，显示不同的文字。例如：一个按钮在未添加商品前显示“添加”；添加了商品之后，立刻显示成“清除”</li>
<li>同一个view上具有多处点击事件，例如 SegmentControl、<code>UISwitch</code>、<code>UIStepper</code>等</li>
</ul>
<p>上面的这2种情况，都是同一个<code>viewPath</code>对应多个事件，此时如果只使用<code>viewPath</code>无法区分出不同的状态或事件。</p>
<p>针对这类问题，SDK 的解决方案是：<code>viewPath</code> + “其它信息” 。这里的 “其它信息”  是视不同情况而定的，比如: 在上面的情况1中，“其它信息” 就是按钮的 title。在情况2中，“其它信息” 是 SegmentControl 的 selectedIndex 和 UISwitch 的 isOn 属性的值。SDK 在进行数据收集时，会上传 view  的这些信息，再结合圈选SDK就能让后台在做统计时区分出这些不同的事件了。</p>
<p>关于“其它信息”，再补充一点，除了 SDK  事先知道要获取的信息之外，还有一类就是业务数据。例如：有一个商品列表页，每一行显示一个商品，如果后台想统计的不是列表中每一行的点击，而是每个商品 的点击，那么此时的“其它信息”就应该是productId 了。关于 SDK 对业务层数据的获取与上报请看下面的介绍。</p>
<h3 id="SDK无埋点业务数据收集的实现"><a href="#SDK无埋点业务数据收集的实现" class="headerlink" title="SDK无埋点业务数据收集的实现"></a>SDK无埋点业务数据收集的实现</h3><p>讲完了 <code>viewPath</code> 之后，接下来详细介绍下 SDK 的另一个关键技术：基于 <code>viewPath</code> 与 <code>KVC</code> 实现 SDK 的无埋点业务数据收集功能。首先，先简单分析一下传统的 <em>代码埋点</em> 存在的缺点，大致有以下几个：</p>
<ul>
<li>埋点代码与业务逻辑代码混合在一起，增加了代码的维护成本；</li>
<li>埋点代码需要跟随APP版本一起发布，耽误数据的收集与统计；</li>
<li>埋点时存在错埋、漏埋等情况，无法动态更新及添加；</li>
</ul>
<p>为了解决上述的 <em>代码埋点</em> 的缺陷，SDK 实现了真正意义上的 <strong>无埋点</strong> 来对业务数据进行收集。</p>
<h4 id="1-无埋点的实现架构"><a href="#1-无埋点的实现架构" class="headerlink" title="1. 无埋点的实现架构"></a>1. 无埋点的实现架构</h4><p>SDK 的无埋点功能的实现主要依赖于 <code>viewPath</code> 与 <code>KVC</code>。<code>viewPath</code>前面已经介绍了，它主要用于标识<code>viewTree</code>中的某个 view。而<code>KVC</code>对于 iOS 开发者也不陌生，堪称 iOS 开发中的黑魔法之一。通过<code>KVC</code>我们能够通过 key 或 keyPath 直接访问对象的属性，而不需要调用明确的存取方法。关于<code>KVC</code>如果不太了解，请自行学习，这里不再过多阐述。</p>
<p>那么如何实现不需要代码埋点就能随意获取想要的业务数据呢？先看一下 SDK 的无埋点技术的整体架构图：</p>
<p><img src="2.webp" alt="img"></p>
<p>从上图可以看出，在实现 SDK 的无埋点数据收集时，主要分为3步：上传KVC配置、请求KVC配置、业务数据的收集与上报。</p>
<h4 id="2-什么是-KVC-配置"><a href="#2-什么是-KVC-配置" class="headerlink" title="2. 什么是 KVC 配置"></a>2. 什么是 KVC 配置</h4><p>在上图中出现了 KVC配置，那么下面先简单介绍下什么是KVC配置。其实 KVC配置 就是一些用来描述 App 应该在什么时机去收集什么数据的信息，包含的主要信息有：</p>
<ul>
<li><strong>appKey：</strong>用来标识是哪个应用</li>
<li><strong>appVersion：</strong>用来标识应用的版本号</li>
<li><strong>viewEvent：</strong>标识某个事件类型（收集时机），例如：ButtonClick、ListItemClick、ViewTap等</li>
<li><strong>viewPath：</strong>目标 view 在<code>viewTree</code>中的信息</li>
<li><strong>keyPath：</strong>目标 view 与要收集的业务数据间的关联路径，用于KVC取值</li>
<li><strong>keyName：</strong>为要收集的业务数据定义一个key，最终组成 key-value 的形式上报。用于区分多个收集的数据</li>
</ul>
<h4 id="3-KVC配置的上传与下发"><a href="#3-KVC配置的上传与下发" class="headerlink" title="3. KVC配置的上传与下发"></a>3. KVC配置的上传与下发</h4><ul>
<li>上传KVC配置<ul>
<li>利用 圈选SDK 上传 KVC配置 的操作对于用户是透明的，主要由开发人员进行上传与管理。此操作可以在任何时候进行，在想要收集某个或某些版本的 App 中的业务数据时，上传相应的KVC配置信息至后台即可，达到了根据需要动态可配的效果。</li>
</ul>
</li>
<li>请求KVC配置<ul>
<li>SDK 在初始化时会触发 KVC配置 的请求操作，从后台拉取 App 当前版本对应的所有KVC配置，并将请求结果缓存起来，以提供给下一步使用。</li>
</ul>
</li>
</ul>
<h4 id="4-业务数据的收集与上报"><a href="#4-业务数据的收集与上报" class="headerlink" title="4. 业务数据的收集与上报"></a>4. 业务数据的收集与上报</h4><p>这一部分是 SDK 无埋点技术的核心，接下来详细介绍这部分的实现逻辑。它的实现流程如下：</p>
<p><img src="3.webp" alt="img"></p>
<p>这个环节的核心是基于<code>viewPath</code>的 view 匹配，主要实现是通过循环遍历<code>viewPath</code>的每个节点的信息与当前 view 及其父view 依次进行匹配。因此这一步会产生一定的时间与性能消耗。为了尽可能减少这部分的操作，SDK 中使用了一些方式进行优化，其中一个就是基于缓存view的优化。</p>
<h5 id="4-1-基于缓存view的优化"><a href="#4-1-基于缓存view的优化" class="headerlink" title="4.1 基于缓存view的优化"></a>4.1 基于缓存view的优化</h5><p>SDK 采用缓存上一次匹配成功的 view 信息的方式，来减少一些不必要的<code>viewPath</code>匹配操作。这里主要缓存的 view 信息有：</p>
<ul>
<li>targetView：上一次通过<code>viewPath</code>匹配成功的 view 对象。</li>
<li>indexPath： 上一次通过<code>viewPath</code>匹配成功的 view 的<code>indexPath</code>，如果没有则为nil。</li>
</ul>
<h5 id="1-viewEvent-匹配"><a href="#1-viewEvent-匹配" class="headerlink" title="1. viewEvent 匹配"></a>1. viewEvent 匹配</h5><p>第一步先进行事件类型的匹配。如果KVC配置信息指定的 viewEvent 是 ButtonClick，那么可以轻松的过滤掉 ListItemClick、ViewTap 等其它事件。这一步能够过滤一大部分事件，只有事件类型匹配成功才继续进行下一步。</p>
<h5 id="2-targetView-匹配"><a href="#2-targetView-匹配" class="headerlink" title="2. targetView 匹配"></a>2. targetView 匹配</h5><p>接下来就是将缓存的 targetView 与当前 view 进行比较。如果两者指向同一对象，则进行第3步，否则直接进入第4步</p>
<h5 id="3-indexPath-匹配"><a href="#3-indexPath-匹配" class="headerlink" title="3. indexPath 匹配"></a>3. indexPath 匹配</h5><p>有人可能不明白为何要添加这一步呢？其实这一步也很重要，是对第2步的补充，主要是用来处理 Cell 可复用性的情况。</p>
<p>如果第2步中缓存的 targetView 是 Cell 或 Cell 中的某个 subview，那么第2步的匹配成功，并不能保证当前 view 就是我们真正想匹配的 view。这个可能不太容易理解，还是举个简单的例子来说明一下：</p>
<ul>
<li>假如一个 Cell 中有一个 button，在第1行的 button 被点击时，通过<code>viewPath</code>匹配成功 了，那么这时 targetView 缓存了第1行的 button  对象。接下来向下滑动列表，第一行被划出屏幕，第10行划入屏幕，同时第10行复用了第1行的 Cell，这时再点击 button 去匹配时，由于  Cell 复用的原因，targetView 与当前 button 肯定指向同一个对象，但是却不是我们真正想匹配的第1行的  button。可以看出：在有 Cell 复用的情况下，无法确定第2步的结果一定正确。</li>
</ul>
<p>因此，在第2步的基础上又增加了<code>indexPath</code>匹配。<code>indexPath</code>的匹配逻辑为：如果缓存的<code>indexPath</code>不为<code>nil</code>并且与当前view的<code>indexPath</code>不相等，则进入第4步；否则表明当前的 view 就是上次刚刚匹配成功的，也就没必要进行<code>viewPath</code>匹配，可以直接进入第5步。</p>
<h5 id="4-viewPath-匹配"><a href="#4-viewPath-匹配" class="headerlink" title="4. viewPath 匹配"></a>4. viewPath 匹配</h5><p>这一步就是对当前的 view 及其父view 与<code>KVC</code>配置中的<code>viewPath</code>的各个节点进行逐个匹配。由于是一个循环操作，因此会有一定的时间消耗，其实在这部分的匹配中，也做了一些简单的优化。在真正进入循环匹配之前，先进行如下3步判断：</p>
<ul>
<li>判断 view 类名是否相等；</li>
<li>判断 view 所在的 viewController 类名是否相等；</li>
<li>判断 view 所在的 window 类名是否相等；</li>
</ul>
<p>上述的3个判断也能过滤很多不必要的匹配。只有这3个判断均通过后，才进行<code>viewPath</code>循环匹配。</p>
<h5 id="5-KVC-取值与上报"><a href="#5-KVC-取值与上报" class="headerlink" title="5. KVC 取值与上报"></a>5. KVC 取值与上报</h5><p>到了这一步，就已经验证了数据收集的时机是正确的。接下来就可以直接使用 KVC配置信息中的<code>keyPath</code>调用 <code>valueForKeyPath:</code> 方法获取对应的值。如果值不为<code>nil</code>，就与 keyName 组成一个键值对，放到当前的事件数据中一起上报上去。这样后台就可以通过key去查找到相应的业务数据了。</p>
<p>上面只是简要介绍了一下匹配时的逻辑，在实际开发中还会添加对 cell 的<code>indexPath</code>通配的情况的处理，由于文章篇幅这里不再详细讲解。</p>
<h3 id="5-增加对-KVC-的异常处理"><a href="#5-增加对-KVC-的异常处理" class="headerlink" title="5. 增加对 KVC 的异常处理"></a>5. 增加对 KVC 的异常处理</h3><p>SDK 的无埋点功能的实现其实主要依赖于<code>KVC</code>，但是众所周知，<code>KVC</code>是非常危险的，很容易造成程序崩溃。例如一旦 key 或 keyPath 所对应的属性名不存在，立刻会导致程序抛出一个<code>NSUndefinedKeyException</code>异常，如果应用没有处理此异常，程序就会Crash。</p>
<p>因此，为了避免程序Crash，SDK 内部增加了对<code>KVC</code>异常的处理。具体实现是给 <code>NSObject</code> 增加一个 Category ，重写 <code>valueForUndefinedKey:</code> 方法，并在方法中<code>return nil</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">KVCExceptionHandler</span>)</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="其它关键技术"><a href="#其它关键技术" class="headerlink" title="其它关键技术"></a>其它关键技术</h3><p>当然，SDK 的实现中还有很多关键技术点，比如：SDK 对 RN 页面的数据收集、页面别名方案的实现、<code>Method Swizzling</code>与<code>Aspects</code>的兼容等。由于本文的篇幅已经很长了，而且考虑到大家读文章的耐性都不会太长，所以这里就先不讲解了，后续会再写文章单独介绍。</p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>文章写了这么多，其实主要介绍了 SDK 中的两个关键技术点，希望对你们能有一些参考价值。另外，如果有人对本文的方案有更好的建议，欢迎一起讨论学习。</p>
<p>最后，要特别感谢我的同事王佳乐，由于他对文章的排版与校对工作，才使得本文能更好的展示给大家。同时也要感谢组内的所有同事，在我开发遇到困难时，给予了我很多的帮助。</p>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>关于对本文内容提出的一些问题，将全部记录在这里（简书评论里的除外），并进行统一解答。</p>
<h4 id="Q1-SDK-都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？"><a href="#Q1-SDK-都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？" class="headerlink" title="Q1: SDK 都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？"></a>Q1: SDK 都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？</h4><h4 id="A1-会有对-KVC配置-的维护与管理工作，不过-SDK-也简化了这块的管理工作。"><a href="#A1-会有对-KVC配置-的维护与管理工作，不过-SDK-也简化了这块的管理工作。" class="headerlink" title="A1: 会有对 KVC配置 的维护与管理工作，不过 SDK 也简化了这块的管理工作。"></a>A1: 会有对 KVC配置 的维护与管理工作，不过 SDK 也简化了这块的管理工作。</h4><p>一般来说，上传的所有的 KVC配置 需要与 App 的版本相对应，因为 App 版本不同会直接导致<code>keyPath</code>可能不一样。所以与 KVC配置 相关的工作有如下2个：</p>
<ol>
<li>针对当前 App 版本上传相应的 KVC配置，以获取想要的业务数据</li>
<li>当 App 新版本发布时，需要对之前版本上的 KVC配置 逐一验证，是否仍然适用于新版本。如果仍然适用，则直接在管理后台上把新的版本号添加到此 KVC配置；如果不再适用，则对新版本再上传一个新的KVC配置。</li>
</ol>
<p>从上面可以看出，在 App 版本不断迭代的过程中，KVC配置 会越来越多，相应的维护与管理工作也相当繁琐。</p>
<p>为了解决这个痛点，SDK 中增加了一种方案来避免这种重复且繁琐的工作。具体的方案是：</p>
<ul>
<li>在上传 KVC 配置时，指定某个区间的版本，或者不指定具体的版本（即应用到当前所有版本上）；</li>
<li>SDK 在使用KVC配置获取业务数据失败时，添加相关的错误日志，并上报上去。其中错误日志里包含了<code>appKey</code>、<code>appVersion</code>、<code>keyPath</code>等信息，这样就能在后台清晰的看到哪些 KVC配置 在哪个 App 版本上存在问题；</li>
<li>使用脚本监控与<code>KVC</code>相关的错误日志。如果监控到有错误日志上报，则发送邮件通知给相关人员；</li>
</ul>
<p>因此，SDK 采用此方案优化之后，KVC配置 的管理工作就只有1个了：</p>
<ul>
<li>根据Log信息快速找到对应的 KVC配置，并上传一个针对新版本的 KVC配置</li>
</ul>
<h4 id="Q2-对于-“内容与位置”-可能会随时间而变动时，如何实现数据收集与统计？"><a href="#Q2-对于-“内容与位置”-可能会随时间而变动时，如何实现数据收集与统计？" class="headerlink" title="Q2: 对于 “内容与位置” 可能会随时间而变动时，如何实现数据收集与统计？"></a>Q2: 对于 “内容与位置” 可能会随时间而变动时，如何实现数据收集与统计？</h4><h4 id="A2-使用圈选SDK与数据SDK共同完成动态数据的收集与统计"><a href="#A2-使用圈选SDK与数据SDK共同完成动态数据的收集与统计" class="headerlink" title="A2: 使用圈选SDK与数据SDK共同完成动态数据的收集与统计"></a>A2: 使用圈选SDK与数据SDK共同完成动态数据的收集与统计</h4><p>这个问题在实际产品中也比较常见，比如 App 首页的内容大多是通过后台配置的。<br> 这个问题其实可以转化或分解成如下的2个情况：</p>
<ul>
<li>同一位置会显示不同的内容</li>
<li>同一内容会显示在不同的位置</li>
</ul>
<p>注意，这2个并非同一个，它们分别对应于不同的场景，同时数据收集的方案也有所不同。</p>
<p>另外，“位置” 可以是在列表中，也可以是非列表中的，不过这个对整体的方案没有太大影响，仅仅是在不关心位置时<code>viewPath</code>中的通配符位置不同。</p>
<h5 id="A2-1-同一位置显示不同的内容"><a href="#A2-1-同一位置显示不同的内容" class="headerlink" title="A2.1 同一位置显示不同的内容"></a>A2.1 同一位置显示不同的内容</h5><p>例子：在 App 首页有一个展示最近活动的位置，先展示活动1的图片，过一段时间运营人员又配成活动2的图片。如何统计活动1、活动2各自的点击量？</p>
<p>针对这种场景，SDK 的解决方案是：<strong>“关心位置” + “关心内容”</strong>。<br> <strong>“关心位置”</strong> 的意思是只使用当前的位置，具体表现是<code>viewPath</code>中不包含任何通配符；<strong>“关心内容”</strong> 的意思是指定一个想要统计的内容。</p>
<p>整个过程可以分解为如下3个环节：</p>
<ul>
<li>圈选SDK上传<strong>“关心位置”</strong>的KVC配置。KVC配置中指定获取活动的<code>url</code>的<code>keyPath</code>。</li>
<li>数据SDK在活动发生点击时，收集当前活动对应的<code>url</code>，并跟随点击事件一起上报。</li>
<li>圈选SDK上传<strong>“关心位置” + “关心内容”</strong>的圈选配置，关心的内容指定为想要统计的活动的<code>url</code>值。</li>
</ul>
<h5 id="A2-2-同一内容显示在不同的位置"><a href="#A2-2-同一内容显示在不同的位置" class="headerlink" title="A2.2 同一内容显示在不同的位置"></a>A2.2 同一内容显示在不同的位置</h5><p>例子：App 首页有4个固定的入口，假设其中一个叫“热门推荐”，那么根据后台配置的顺序不同，“热门推荐”可能被显示在4个位置中的任何1个，即一段时间显示在第1个，过一段时间可能显示在第2个位置。这时如何统计出“热门推荐”的点击量？</p>
<p>针对这种场景，SDK 的解决方案是：<strong>“不关心位置” + “关心内容”</strong>。<br> <strong>“不关心位置”</strong> 是指<code>viewPath</code>中含有通配符，用于表示<code>viewTree</code>中的多个位置。例如想要匹配列表所有行时，则将<code>viewPath</code>中的<code>indexPath</code>替换为通配符。</p>
<p>这个问题的解决过程也分为如下3步：</p>
<ul>
<li>圈选SDK上传<strong>“不关心位置”</strong>的KVC配置。KVC配置中指定获取入口的 title 的<code>keyPath</code>。</li>
<li>数据SDK在4个中任何一个入口被点击时，都去收集入口的 title，并跟随点击事件一起上报。</li>
<li>圈选SDK上传<strong>“不关心位置” + “关心内容”</strong>的圈选配置，关心的内容指定为“热门推荐”。</li>
</ul>
<p>到这里，数据收集与圈选配置的工作都已经做完了，接下来就是后台的数据统计了。<br> 上述2种情况对后台进行统计没有区别，都使用一个统计方案，这里也介绍一下后台大概的统计思路：</p>
<ul>
<li>拿到第3步中上传的圈选配置，根据<code>viewPath</code> 与 <strong>“关心的内容”</strong> 生成一个正则表达式，然后从数据 SDK 上报的原始数据中进行正则匹配，进而统计出相应数据。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag"># 架构</a>
              <a href="/tags/%E5%9F%8B%E7%82%B9/" rel="tag"># 埋点</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/03/iOS%E6%9E%B6%E6%9E%84/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB%E4%B9%8B%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" rel="prev" title="移动端监控体系之技术原理剖析">
      <i class="fa fa-chevron-left"></i> 移动端监控体系之技术原理剖析
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/" rel="next" title="iOS无埋点数据SDK整体设计">
      iOS无埋点数据SDK整体设计 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDK%E7%9A%84%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">1.</span> <span class="nav-text">SDK的整体实现思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">系统类的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E7%9A%84-Delegate-%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">系统类的 Delegate 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">自定义类的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDK%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">SDK的关键技术的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#viewPath-%E5%8F%8A-viewId-%E7%9A%84%E7%94%9F%E6%88%90%E5%8F%8A%E4%BC%98%E5%8C%96"><span class="nav-number">2.1.</span> <span class="nav-text">viewPath 及 viewId 的生成及优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-viewPath-%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. viewPath 的组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-UITableViewCell-x2F-UICollectionCell-%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. UITableViewCell&#x2F;UICollectionCell 的深度表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-viewPath-%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. viewPath 的表示形式与示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%92%88%E5%AF%B9-viewPath-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.针对 viewPath 的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-%E4%BC%98%E5%8C%96%E8%8A%82%E7%82%B9%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">4.1 优化节点的深度的计算方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-viewPath-%E9%92%88%E5%AF%B9-Swift-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">4.2 viewPath 针对 Swift 的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-%E5%9C%A8%E5%8C%85%E5%90%AB%E5%AD%90VC%E6%97%B6%EF%BC%8C%E4%BC%98%E5%8C%96VC%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">4.3 在包含子VC时，优化VC的深度的计算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-viewId-%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">2.1.5.</span> <span class="nav-text">5. viewId 的生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-viewPath-%E4%B8%8E-viewId-%E9%87%8D%E5%A4%8D%E6%97%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.6.</span> <span class="nav-text">6. viewPath 与 viewId 重复时的解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDK%E6%97%A0%E5%9F%8B%E7%82%B9%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">SDK无埋点业务数据收集的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%97%A0%E5%9F%8B%E7%82%B9%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9E%B6%E6%9E%84"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 无埋点的实现架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF-KVC-%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 什么是 KVC 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-KVC%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E5%8F%91"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. KVC配置的上传与下发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E9%9B%86%E4%B8%8E%E4%B8%8A%E6%8A%A5"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. 业务数据的收集与上报</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-%E5%9F%BA%E4%BA%8E%E7%BC%93%E5%AD%98view%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">4.1 基于缓存view的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-viewEvent-%E5%8C%B9%E9%85%8D"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">1. viewEvent 匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-targetView-%E5%8C%B9%E9%85%8D"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">2. targetView 匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-indexPath-%E5%8C%B9%E9%85%8D"><span class="nav-number">2.2.4.4.</span> <span class="nav-text">3. indexPath 匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-viewPath-%E5%8C%B9%E9%85%8D"><span class="nav-number">2.2.4.5.</span> <span class="nav-text">4. viewPath 匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-KVC-%E5%8F%96%E5%80%BC%E4%B8%8E%E4%B8%8A%E6%8A%A5"><span class="nav-number">2.2.4.6.</span> <span class="nav-text">5. KVC 取值与上报</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%A2%9E%E5%8A%A0%E5%AF%B9-KVC-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">5. 增加对 KVC 的异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="nav-number">2.4.</span> <span class="nav-text">其它关键技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#END"><span class="nav-number">2.5.</span> <span class="nav-text">END</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q-amp-A"><span class="nav-number">2.6.</span> <span class="nav-text">Q &amp; A</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Q1-SDK-%E9%83%BD%E4%BD%BF%E7%94%A8KVC%E9%85%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%98%AF%E5%90%A6%E4%BC%9A%E5%A2%9E%E5%8A%A0%E7%BB%B4%E6%8A%A4KVC%E9%85%8D%E7%BD%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="nav-number">2.6.1.</span> <span class="nav-text">Q1: SDK 都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A1-%E4%BC%9A%E6%9C%89%E5%AF%B9-KVC%E9%85%8D%E7%BD%AE-%E7%9A%84%E7%BB%B4%E6%8A%A4%E4%B8%8E%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%EF%BC%8C%E4%B8%8D%E8%BF%87-SDK-%E4%B9%9F%E7%AE%80%E5%8C%96%E4%BA%86%E8%BF%99%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E3%80%82"><span class="nav-number">2.6.2.</span> <span class="nav-text">A1: 会有对 KVC配置 的维护与管理工作，不过 SDK 也简化了这块的管理工作。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Q2-%E5%AF%B9%E4%BA%8E-%E2%80%9C%E5%86%85%E5%AE%B9%E4%B8%8E%E4%BD%8D%E7%BD%AE%E2%80%9D-%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%9A%8F%E6%97%B6%E9%97%B4%E8%80%8C%E5%8F%98%E5%8A%A8%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E4%B8%8E%E7%BB%9F%E8%AE%A1%EF%BC%9F"><span class="nav-number">2.6.3.</span> <span class="nav-text">Q2: 对于 “内容与位置” 可能会随时间而变动时，如何实现数据收集与统计？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A2-%E4%BD%BF%E7%94%A8%E5%9C%88%E9%80%89SDK%E4%B8%8E%E6%95%B0%E6%8D%AESDK%E5%85%B1%E5%90%8C%E5%AE%8C%E6%88%90%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E9%9B%86%E4%B8%8E%E7%BB%9F%E8%AE%A1"><span class="nav-number">2.6.4.</span> <span class="nav-text">A2: 使用圈选SDK与数据SDK共同完成动态数据的收集与统计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A2-1-%E5%90%8C%E4%B8%80%E4%BD%8D%E7%BD%AE%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">A2.1 同一位置显示不同的内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#A2-2-%E5%90%8C%E4%B8%80%E5%86%85%E5%AE%B9%E6%98%BE%E7%A4%BA%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">A2.2 同一内容显示在不同的位置</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
