<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="google90a27f59c648608f.html">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS, Swift, GitHub, CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不会飞的小白</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">iOS无埋点数据SDK整体设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-04 16:52:20 / 修改时间：17:04:32" itemprop="dateCreated datePublished" datetime="2023-01-04T16:52:20+08:00">2023-01-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文为转载。</p>
<p>作者：zerygao<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5f16e1de6d5a">https://www.jianshu.com/p/5f16e1de6d5a</a><br>来源：简书</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/69ce01e15042">iOS无埋点数据 SDK 实践之路</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0e1f2d357e39">iOS无埋点SDK 之 RN页面的数据收集</a></p>
<p>本篇文章是讲述 iOS 无埋点数据收集 SDK 系列的第三篇，之前的两篇文章都只是讲述了某一方面的内容，而本篇会详细介绍下 SDK 的整体设计以及各个模块的功能和实现思路。</p>
<h2 id="SDK-的整体设计"><a href="#SDK-的整体设计" class="headerlink" title="SDK 的整体设计"></a>SDK 的整体设计</h2><p>先看一张 SDK 的整体设计图：</p>
<p><img src="1.webp" alt="img"></p>
<p>从上图看出，SDK 整体上主要包含 4 个部分：<strong>AOP</strong>、<strong>Event Collector</strong>、<strong>Event Cache</strong>、<strong>Event Upload</strong>。其中，每个部分是一个相对独立的功能模块，同时模块之间通过图中的方式进行通信。</p>
<p>SDK 中的这 4 个模块各自的主要功能如下：</p>
<ul>
<li>AOP：提供数据收集所需要的时机，即通过 <code>Method Swizzling</code> 来 <code>hook</code> 相应类的方法，然后以 <code>Post Notification</code> 的方式提供出去。</li>
<li>Event Collector：监听通知，针对当前事件执行相应的数据收集，并将收集的事件数据提交给缓存模块。</li>
<li>Event Cache：负责事件数据的缓存、序列化以及读取操作，其中包括内存缓存与磁盘缓存。</li>
<li>Event Upload：基于一定的上报策略执行对已收集的事件数据的上报。</li>
</ul>
<p>接下来逐个介绍上述 4 个模块的具体实现细节。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>这个模块的主要功能就是提供 SDK 执行数据收集所需的时机，在实现上又可以细分为 2 个方面：</p>
<ol>
<li>实现 <code>AOP</code> 编程</li>
<li><code>hook</code> 类的方法</li>
</ol>
<h4 id="实现-AOP-编程"><a href="#实现-AOP-编程" class="headerlink" title="实现 AOP 编程"></a>实现 <code>AOP</code> 编程</h4><p>在 iOS 中实现 <code>AOP</code> 编程的技术就是基于 Objective-C Runtime 特性的 <code>Method Swizzling</code>。而在 Github 上已经有一个很不错的实现了 AOP 的开源库-<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/steipete/Aspects">Aspects</a>，它的实现也是利用了 Objective-C 的消息转发机制与 <code>Method Swizzling</code> 黑魔法。</p>
<p>但是，SDK 最终并未使用 Aspects 库，虽然 Aspects 封装的很好而且很好用，但是它并不能完全满足项目的需要，主要表现在如下 2 个方面：</p>
<ol>
<li>Aspects 无法 <code>hook</code> 类中不存在的方法，或者未实现的方法。</li>
<li>Aspects 不支持 <code>hook</code> 类的类方法。</li>
</ol>
<p>因此，SDK 单独实现并封装了一个用于执行 <code>hook</code> 的类，其实现也是对 <code>NSObject</code> 的扩展，类似于 Aspects。</p>
<h4 id="hook-的方法"><a href="#hook-的方法" class="headerlink" title="hook 的方法"></a><code>hook</code> 的方法</h4><p>在 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/69ce01e15042">上篇文章</a> 中简单提了一下，SDK 在实现对基本事件数据的自动收集时，主要 <code>hook</code> 的方法分为 3 类：</p>
<ul>
<li>系统类的方法</li>
<li>系统类的 <code>Delegate</code> 方法</li>
<li>自定义类的方法</li>
</ul>
<p>那么，接下来就详细的介绍一下，SDK 在实现对事件的收集时，具体 <code>hook</code> 了哪些类的哪些方法。</p>
<h5 id="各类点击事件的拦截"><a href="#各类点击事件的拦截" class="headerlink" title="各类点击事件的拦截"></a>各类点击事件的拦截</h5><p>对于 SDK 来说，收集用户的所有点击的行为数据是非常重要的一部分。另外，这部分数据对于用户行为分析以及统计路径转化率时，都是至关重要的。</p>
<p>那么 SDK 对于用户的各类点击事件的收集，主要 <code>hook</code> 了如下的一些系统类的方法：</p>
<p><img src="2.webp" alt="img"></p>
<p>针对上图，做一些简要的说明：</p>
<ol>
<li>所有的 <code>UIControl</code> 类型的控件、<code>UITabBarButton</code> 以及在导航栏上自定义添加的 <code>UIBarButtonItem</code> 的点击事件，都可以通过 <code>hook</code> 系统类<code>UIApplication</code> 的 <code>sendAction:to:from:forEvent:</code> 方法进行拦截。但是，这个方法并不能拦截到导航栏上系统自动添加的返回按钮的点击，因此 SDK 又 <code>hook</code> 了 <code>UINavigationController</code> 的 <code>navigationBar:shouldPopItem:</code> 方法来实现对它的点击的拦截。</li>
<li>针对与手势相关的事件，SDK 首先通过 <code>hook</code> 系统类 <code>UIGestureRecognizer</code> 的 <code>initWithTarget:action:</code> 与 <code>addTarget:action:</code> 这 2 个方法拿到 target 对象与 action 方法，然后再去 <code>hook</code> target 的 action 方法，从而能够拦截到手势相关的事件。</li>
<li>对于 UITableView、UICollectionView 某一行的点击，首先 <code>hook</code> 它们的 <code>setDelegate:</code> 方法，从而拿到 delegate 对象，然后再去 <code>hook</code> delegate 的 <code>didSelectRowAtIndexPath:</code> 方法即可。</li>
<li>对于 RN 页面中的点击，是通过 <code>hook</code> RN 框架中的 <code>RCTUIManager</code> 类的 <code>setJSResponder:blockNativeResponder:</code> 方法，具体原因可以看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0e1f2d357e39">这篇文章</a> 的详细讲解。另外，为了避免 SDK 对 RN 框架产生依赖，通过 <code>NSClassFromString(@&quot;RCTUIManager&quot;)</code> 来判断当前主工程是否使用了 RN 框架，如果未获取到此类，则不执行 <code>hook</code> 操作。</li>
<li>对于系统弹窗的点击这块，需要拦截到 <code>UIAlertView</code>、<code>UIActionSheet</code> 以及 iOS8 上新增的 <code>UIAlertController</code> 这 3 个弹窗的点击。对于前2个，只需要 <code>hook</code> 它们的 delegate 方法。而对于 <code>UIAlertController</code> 是没有提供相应的 delegate 方法的，这里可以通过 <code>hook</code> <code>UIAlertAction</code> 类的 <code>actionWithTitle:style:handler:</code> 类方法来拦截到其点击事件。</li>
</ol>
<h5 id="页面事件的拦截"><a href="#页面事件的拦截" class="headerlink" title="页面事件的拦截"></a>页面事件的拦截</h5><p>对于页面事件的收集，主要通过 <code>hook</code> 系统类 <code>UIViewController</code> 的生命周期方法来实现，具体看下图：</p>
<p><img src="3.webp" alt="img"></p>
<h5 id="滑动事件-amp-UIWebView加载事件"><a href="#滑动事件-amp-UIWebView加载事件" class="headerlink" title="滑动事件 &amp; UIWebView加载事件"></a>滑动事件 &amp; UIWebView加载事件</h5><p>对于 iOS 中的滑动事件、<code>UIWebView</code> 的加载事件的收集，SDK 主要 hook 了 <code>setDelegate:</code> 方法以及 UIScrollViewDelegate、UIWebViewDelegate 中的方法。其原理上与 UITableView 的类似。具体见下图：</p>
<p><img src="4.webp" alt="img"></p>
<h3 id="Event-Collector"><a href="#Event-Collector" class="headerlink" title="Event Collector"></a>Event Collector</h3><p>SDK 通过 AOP 层已经可以拿到执行各个事件的数据收集的时机，接下来就是执行真正的数据收集了，其中包括了对 点击事件的收集、页面事件的收集、滑动事件的收集等。</p>
<p>这些要收集的事件数据中包含一些基本信息，如：eventName、appKey、eventTime、sessionId、deviceId 等。除此之外，还有一些与特定事件相关的信息，例如对于 view 的点击事件，还需要收集与 view 的相关信息；对于列表行的点击，还需要收集点击行的 indexPath 信息；而对于 webView 加载事件则需要收集其 url 与 error 等信息。</p>
<p>接下来主要说一下 SDK 中点击事件的收集。</p>
<p>首先，对于 <code>UIControl</code> 控件与添加了 <code>UITapGestureRecognizer</code> 的 view，在收集它们的点击事件的数据时，重点收集了 2 部分内容：pageName、viewInfo。其中，pageName 是表明点击事件发生在哪个页面，一般用 viewController 的类名表示；viewInfo 是指当前被点击的view的一些相关信息，有：viewClass、viewPath、frame、title（如果有）、viewId 等。而 viewPath 是最关键的一项信息，能够唯一标识当前 view。</p>
<p>其次，对于导航栏上的点击事件的收集，与上面要收集的信息几乎是一样的，只是在收集 pageName 的数据时不一样。导航栏的点击事件默认的 pageName 是 UINavigationController，但是为了能够更好的分析用户行为，这里将 App 当前正在显示的页面作为其 pageName。</p>
<p>同理，收集系统弹窗的点击事件时，也将 App 当前正在显示的页面作为其 pageName。除此之外，由于同一个页面中可能会出现多个弹窗，它们的按钮文字信息有可能一样，比如经常会用 “确定”、“取消” 等文字，这时单纯靠按钮的 title 无法区分这些不同的弹窗，为了解决这个问题，又加入了系统弹窗的标题(title、message)。</p>
<p>最后，讲一下 SDK 中获取 viewPath 的实现逻辑，具体如下图所示：</p>
<p><img src="5.webp" alt="img"></p>
<h3 id="Event-Cache"><a href="#Event-Cache" class="headerlink" title="Event Cache"></a>Event Cache</h3><p>这个模块主要负责所有事件数据的存取及序列化操作，具体可分为如下 3 部分：</p>
<ol>
<li>采用双缓存的结构将数据存储在内存中。具体实现是，将新添加的事件数据先存储到全局数组 eventArray 中，等满足数据上报条件时，从 eventArray 中读出一部分数据并随机生成一个唯一的 eventsID，将其以 key-value 的形式存放到全局字典 popedEventDict 中，等这部分数据上传成功后再将 eventsID 对应项从 popedEventDict 中移除。</li>
<li>在某些情况下（App 即将被杀死、程序抛出异常），将内存中的数据以文件的形式持久化存储至磁盘中，以防数据丢失。</li>
<li>将从内存或文件中读取的数据执行 protobuf 序列化操作，以便后续的数据上传操作。</li>
</ol>
<p>另外，为了确保对数据存取的多线程安全，上述操作全部都放到了同一个串行队列中执行。</p>
<h3 id="Event-Upload"><a href="#Event-Upload" class="headerlink" title="Event Upload"></a>Event Upload</h3><p>这个模块的主要功能就是根据一定的数据上报策略，上报已收集的所有事件数据。数据上报主要包括对内存数据和本地文件这2部分，下面分别介绍一下它们的上报策略与实现思路。</p>
<h4 id="内存数据的实时上报"><a href="#内存数据的实时上报" class="headerlink" title="内存数据的实时上报"></a>内存数据的实时上报</h4><p>首先，针对内存数据的上报策略有 2 个：</p>
<ol>
<li>每隔 30 秒</li>
<li>每累积 10 条数据。</li>
</ol>
<p>当满足上述条件之一时，会触发从内存中读取数据，并执行上传操作。对于内存数据的上传，单独创建了一个并发队列，并限制其最大并发数为 10，以防由于数据频繁时上报引起开启的线程数太多。</p>
<h4 id="本地文件数据的上传"><a href="#本地文件数据的上传" class="headerlink" title="本地文件数据的上传"></a>本地文件数据的上传</h4><p>为了尽早的上传本地文件，以防用户卸载 App 造成本地数据的丢失，针对本地文件的上传策略有如下 3 个：</p>
<ol>
<li>App 冷启动</li>
<li>App 进入前台</li>
<li>App 进入后台</li>
</ol>
<p>这里创建了一个单独的串行队列，来实现对本地文件进行逐个上传，即等上一个文件上传成功后，再触发下一个文件的上传。因此，上述 3 个触发时机并不会造成文件的重复上传，并以较小的代价完成本地文件的上传。</p>
<h3 id="数据存取与上传的实现流程"><a href="#数据存取与上传的实现流程" class="headerlink" title="数据存取与上传的实现流程"></a>数据存取与上传的实现流程</h3><p>其实上面已经讲了大致的实现思路，里面设计到了使用 GCD 队列来控制数据上传与保证多线程安全。为了更清晰的展示出这 2 部分的实现逻辑，简单画了一个流程图展示出来：</p>
<p><img src="6.webp" alt="img"></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>本篇文章主要介绍了无埋点数据 SDK 的整体设计，以及各个模块的功能和实现思路，其中重点介绍了执行事件收集所需 <code>hook</code> 的具体方法，和事件数据的存取与上报功能的实现流程。如果对本文有问题，请留言评论。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/04/iOS%E6%9E%B6%E6%9E%84/iOS%E6%97%A0%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AESDK%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/" class="post-title-link" itemprop="url">iOS无埋点数据SDK实践之路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-04 16:40:08 / 修改时间：17:04:28" itemprop="dateCreated datePublished" datetime="2023-01-04T16:40:08+08:00">2023-01-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文为转载。</p>
<p>作者：zerygao<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/69ce01e15042">https://www.jianshu.com/p/69ce01e15042</a><br>来源：简书</p>
<p>本篇文章是基于 网易乐得无埋点数据SDK 总结而成。负责无埋点数据收集 SDK 的开发已经有半年多了，期间在组内进行过相关分享，现在觉得是时候拿出去和同行们交流下了。本篇主要讲一下SDK的整体实现思路以及关键的技术点。</p>
<p>SDK 已经具备不需要代码埋点就能 <strong>自动的</strong>、<strong>动态可配的</strong>、<strong>全面且正确</strong> 的收集用户在使用 App 时的所有事件数据。除此之外，还单独开发了与之配合的圈选SDK，能够在 App 端完成对界面元素的圈配以及 KVC 配置的上传。而界面元素圈配的工作完全可以交给用研与产品人员来做，减轻了开发人员的工作量。</p>
<p>SDK 已有的功能可以分为两大部分：</p>
<ul>
<li><strong>基本事件数据的收集</strong>：基本事件的收集是指应用冷启动事件、页面事件、用户点击事件、<code>ScrollView</code>滑动事件等，这部分全部都是自动完成的，实现思路会在第一节中介绍。</li>
<li><strong>业务层数据的收集</strong>：业务层数据的收集是指对与业务功能相关的一些数据，例如：在用户点击提交订单按钮时，收集用户购买的物品以及订单总金额的数据。这种业务层数据的收集以往大多通过 <em>代码埋点</em> 的方式去做，本SDK则真正的实现了 <strong><code>无埋点</code></strong> 的去获取这些想要的业务数据。这部分的实现会在本文的第二节详细介绍。</li>
</ul>
<h2 id="SDK的整体实现思路"><a href="#SDK的整体实现思路" class="headerlink" title="SDK的整体实现思路"></a>SDK的整体实现思路</h2><p>SDK 整体采用了 AOP（Aspect-Oriented-Programming）即面向切面编程的思想，就是动态的在函数调用的前后插入数据收集的代码。在 Objective-C 中的实现是基于 <code>Runtime</code> 特性的 <code>Method Swizzling</code> 黑魔法。</p>
<p>SDK 的数据收集功能的实现主要通过 <code>Method Swizzling</code> 来 <code>hook</code> 相应的方法。<code>hook</code>的方法大致可以分为3类：系统类的方法、系统类的<code>Delegate</code>方法、自定义类的方法。</p>
<h3 id="系统类的方法"><a href="#系统类的方法" class="headerlink" title="系统类的方法"></a>系统类的方法</h3><p>系统类的方法是指系统框架中提供的基础类的方法，如 <code>UIApplication</code>、<code>UIViewController</code> 等。SDK 在实现某些功能时，需要<code>hook</code>这些类的方法。例如在实现对页面事件的收集时，主要<code>hook</code>了 <code>UIViewController</code> 的生命周期的方法：<code>viewDidLoad</code>、<code>viewDidAppear</code>、<code>viewDidDisappear</code>、<code>dealloc</code></p>
<h3 id="系统类的-Delegate-方法"><a href="#系统类的-Delegate-方法" class="headerlink" title="系统类的 Delegate 方法"></a>系统类的 Delegate 方法</h3><p>系统类的 Delegate 方法主要指 UIKit 框架中提供的 Delegate 中的方法，如 UIScrollViewDelegate、UITableViewDelegate、UIWebViewDelegate 等。SDK 中的大多数功能都是通过<code>hook</code>这些协议中的方法来完成的。例如在实现列表元素点击事件的收集时，主要 <code>hook</code> 了 <code>UITableViewDelegate</code> 中的 <code>tableView:didSelectRowAtIndexPath:</code> 方法。</p>
<h3 id="自定义类的方法"><a href="#自定义类的方法" class="headerlink" title="自定义类的方法"></a>自定义类的方法</h3><p>顾名思义，自定义类的方法是指开发人员在工程中自已定义的类，而非系统类的方法。SDK的一些功能是通过<code>hook</code> 这些类的方法来实现。例如在SDK实现对手势操作的事件收集时，需要<code>hook</code>手势对象所指定的target 中的 action 方法，而 target 通常都是自定义类。其实<code>hook</code>系统类的 delegate 方法也可以看成是 hook 自定义类的方法，因为系统类的 delegate 方法大多都是需要在自定义类中实现。</p>
<p>这部分看起来是借助于 AOP 来添加数据收集的代码，但是在真正做的时候，也并没有想的那么简单，涉及到很多细节上的问题，例如：如何将导航栏与系统弹窗的点击事件归属到合适页面中、如何区分<code>UIControlEventValueChanged</code>事件、如何解决<code>hook</code>手势操作引起的性能问题等等。不过这部分内容并不是本篇文章的重点，因此这里不打算多说，之后会单独写一篇文章来讲述遇到的一些坑。</p>
<h2 id="SDK的关键技术的实现"><a href="#SDK的关键技术的实现" class="headerlink" title="SDK的关键技术的实现"></a>SDK的关键技术的实现</h2><h3 id="viewPath-及-viewId-的生成及优化"><a href="#viewPath-及-viewId-的生成及优化" class="headerlink" title="viewPath 及 viewId 的生成及优化"></a>viewPath 及 viewId 的生成及优化</h3><p>为了对 APP 中某个页面的某个 view 进行数据收集、统计与分析，首先就需要能够唯一的标识与定位这个视图，这可以说是数据收集 SDK 的一个重要前提。那么怎样去唯一的标识 APP 中的某个 view 呢？SDK 中使用了 <code>viewPath</code> 与 <code>viewId</code> 来完成。</p>
<h4 id="1-viewPath-的组成"><a href="#1-viewPath-的组成" class="headerlink" title="1. viewPath 的组成"></a>1. viewPath 的组成</h4><p>其实整个 APP 的视图结构可以看成是一颗树（<code>viewTree</code>），树的根节点就是 UIWindow，树的枝干由<code>UIViewController</code>及<code>UIView</code>组成，树的叶节点都是由<code>UIView</code>组成。</p>
<p>那么在<code>viewTree</code>中用什么信息来表示其中任意一个 view 的位置呢？很容易想到的就是使用目标 view 到根之间的每个节点的深度（层次）组成一个路径，而节点的深度（层次）是指此节点在父节点中的 index。这样确实能够唯一的表示此 view 了，但是有一个缺点：它的可读性很差。因此在此基础上又增加了每个节点的名称，节点的名称由当前节点的 view 的类名来表示。</p>
<p>因此，在 <code>viewTree</code> 中，由一个 view 到根节点之间的每个节点的名称与深度（层次）共同组成的信息构成了此 view 的<code>viewPath</code>。另外，由于在做 view 的统计分析时，都是以页面为单位的，因此 SDK 在生成 <code>viewPath</code> 时，只到 view 所在的 UIViewController 级别，而非根部的 UIWindow。这样做也在一定程度上减少了<code>viewPath</code> 的长度。</p>
<h4 id="2-UITableViewCell-x2F-UICollectionCell-的深度表示"><a href="#2-UITableViewCell-x2F-UICollectionCell-的深度表示" class="headerlink" title="2. UITableViewCell&#x2F;UICollectionCell 的深度表示"></a>2. UITableViewCell&#x2F;UICollectionCell 的深度表示</h4><p>在 App 开发中，最常用而且最重要的控件就是<code>UITableView</code>与<code>UICollectionView</code>。针对这种可复用视图，里面会包含很多 Cell，而且 Cell 个数也不确定，那么里面的每一个 Cell 应该怎么去表示其深度呢？答案是<code>indexPath</code>。虽然每个 Cell 都可能被复用，但是不同的 Cell 都对应一个唯一的<code>indexPath</code>，因此完全可以使用<code>indexPath</code>值来表示其深度。</p>
<h4 id="3-viewPath-的表示形式与示例"><a href="#3-viewPath-的表示形式与示例" class="headerlink" title="3. viewPath 的表示形式与示例"></a>3. viewPath 的表示形式与示例</h4><p>我们已经知道，<code>viewPath</code>就是由各节点的类名与深度组成，那么接下来就使用这些信息来表示出 <code>viewPath</code>。下面结合一个具体的示例来简单说一下，我随便从项目中找了一个：</p>
<p>路径中各个节点的类名是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HYGHallSlideViewController-<span class="built_in">UIScrollView</span>-HYGHallProductTableView-<span class="built_in">UITableViewWrapperView</span>-HYGHallProductCell-<span class="built_in">UITableViewCellContentView</span>-HYGHallProductView。</span><br></pre></td></tr></table></figure>

<p>路径中各个节点的深度是：<code>0-0-1-0-0:2-0-1</code></p>
<p>接下来就是将这两者放到一起来构成 <code>viewPath</code>，SDK 的表示方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewPath：HYGHallSlideViewController-UIScrollView-HYGHallProductTableView-UITableViewWrapperView-HYGHallProductCell-UITableViewCellContentView-HYGHallProductView &amp; 0-0-1-0-0:2-0-1</span><br></pre></td></tr></table></figure>

<p>其实就是使用 <code>&amp;</code> 连接符简单的拼接到一起。这样做可以方便将两者组合与分离开，便于后面的<code>viewPath</code>匹配。另外，网上还有一种类似于 <code>xPath</code> 的表示方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HYGHallSlideViewController[0]/UIScrollView[0]/HYGHallProductTableView[1]/UITableViewWrapperView[0]/HYGHallProductCell[0:2]/UITableViewCellContentView[0]/HYGHallProductView[1]</span><br></pre></td></tr></table></figure>



<p>不过个人觉得<code>xPath</code>的方式稍微复杂了点，在组合以及拆分上都相对麻烦些。不过话说回来，<code>viewPath</code>的形式是次要的，大家可以按照各自喜欢的方式去表示就行，无须纠结于哪种形式更好。</p>
<h4 id="4-针对-viewPath-的优化"><a href="#4-针对-viewPath-的优化" class="headerlink" title="4.针对 viewPath 的优化"></a>4.针对 viewPath 的优化</h4><h5 id="4-1-优化节点的深度的计算方式"><a href="#4-1-优化节点的深度的计算方式" class="headerlink" title="4.1 优化节点的深度的计算方式"></a>4.1 优化节点的深度的计算方式</h5><p>上面提到在计算各节点的深度时，是采用当前 view 位于其父 view 中的所有子 view 中的 index 值。不过在实际的开发中，<code>viewTree</code> 有时候会根据用户的操作有所变动。仍然举个栗子：</p>
<ul>
<li>假设一个 UIView 中有三个子 view，先后加入的顺序是：label、button1、button2，按照之前的计算方式，这 3  个子 view 的深度依次是：0、1、2。这时候用户点击了一个按钮，label1 从父 view 中被移除了。此时 UIView 只有 2  个子view：button1、button2，而且深度变为了：0、1。如图所示：</li>
</ul>
<p><img src="1.webp" alt="img"></p>
<p>可以看出仅仅由于其中一个子view 被移除，却导致其它子 view 的深度都发生了变化。因此，SDK 为了在新增&#x2F;移除某一 view  时，尽量减少对已有 view 的深度的影响，调整了对节点的深度的计算方式：采用当前 view 位于其父 view 中的所有 <strong>同类型</strong> 子 view 中的index 值。</p>
<p>我们再看一下上面的这个例子，最初 label、button1、button2 的深度依次是：0、0、1。在 label  被移除后，button1、button2 的深度依次为：0、1。可以看出，在这个例子中，label 的移除并未对 button1、button2 的深度造成影响，这种调整后的计算方式在一定程度上增强了 <code>viewPath</code> 的抗干扰性。</p>
<p>另外，调整后的深度的计算方式是依赖于各节点的类型的，因此，此时必须要将各节点的名称放到<code>viewPath</code>中，而不再是仅仅为了增加可读性。</p>
<h5 id="4-2-viewPath-针对-Swift-的优化"><a href="#4-2-viewPath-针对-Swift-的优化" class="headerlink" title="4.2 viewPath 针对 Swift 的优化"></a>4.2 viewPath 针对 Swift 的优化</h5><p>众所周知，<code>Swift</code>文件在获取其类名时，会自动添加此文件所在的<code>Module</code>名前缀：如果<code>Swift</code>文件在主工程中，则会添加工程的名字；如果是在某个组件中，并且项目开启了 <code>use frameworks!</code> 选项，则会添加组件的名字。总的来说，在含有swift 的项目中（包括纯 swift&#x2F;OC 与 swift 混编），<code>viewPath</code>中会包含各 Swift 文件的<code>ModuleName</code>，那么在如下情况下：</p>
<ul>
<li>某个 OC 文件被使用 Swift 重写了</li>
<li>某个 Swift 文件被从主工程移至某个组件库中，或者从组件库移至主工程中</li>
<li>主工程在引用组件库时，在开启与关闭<code>use frameworks!</code>之间进行切换</li>
</ul>
<p>上述3种情况下，文件的类名都会由于<code>ModuleName</code>而发生变化，进而会导致 <code>viewPath</code> 的改变，工程文件在结构上的调整都可能会直接对<code>viewPath</code>造成影响。</p>
<p>实际开发中，特别是对于较老的<code>OC</code>项目，经常会对项目的<code>OC</code>文件使用<code>Swift</code>重写。因此 SDK 有必要去避免<code>viewPath</code>因为这类情况而发生变化。</p>
<p>其实这个问题的解决方案很简单，既然是由于类名中的<code>ModuleName</code>前缀的改变造成的，那么就干脆在生成<code>viewPath</code>时，去掉所有的<code>Swift</code>的<code>ModuleName</code>前缀。这种做法能够解决对<code>viewPath</code>的影响，但是细心的人可能会意识到另一个隐藏的问题：如果在不同的组件库中，两个不同的视图或控制器具有相同的名字（在<code>Swift</code>中是允许的，因为有<code>Module</code>进行区分），这种情况下，<code>viewPath</code>是否存在无法区分的情况？</p>
<p>其实经过仔细考虑，这个担忧有点多余，因为就算两个Module中的视图或控制器名字一样，但是他们里面的视图结构会有所不同，进而深度也不一样，<code>viewPath</code>也不会完全相同。</p>
<h5 id="4-3-在包含子VC时，优化VC的深度的计算"><a href="#4-3-在包含子VC时，优化VC的深度的计算" class="headerlink" title="4.3 在包含子VC时，优化VC的深度的计算"></a>4.3 在包含子VC时，优化VC的深度的计算</h5><p>前面提到，<code>viewPath</code>只表示到距离 view 最近的一个 VC，VC 的深度的计算也是此 VC 的 view 所在的父 view 的所有子 view 中的深度。在实际的 iOS 开发中，可能会经常使用<code>addChildViewController:</code>添加多个子 VC 来实现复杂的页面，但是在包含子 VC 时，VC 的深度计算就有可能会存在问题。还是举一个简单的栗子：</p>
<ul>
<li>假设一个 containerVC  中包含4个子VC：VC1、VC2、VC3、VC4。在每个子VC首次被展示时，子VC会先被add进来，而子 VC 的 view 也会被 add  到一个scrollView  上。这时候这几个子VC首次的查看顺序的不同将会导致它们的深度的变化：如果查看顺序是：VC1、VC2、VC3、VC4，那么它们的深度依次 为：VC1（0）、VC2（1）、VC3（2）、VC4（3）；如果查看顺序是：VC3、VC1、VC4、VC2，深度则变成了：VC1（1）、 VC2（3）、VC3（0）、VC4（2）。这种情况导致 <code>viewPath</code> 不可靠且无法保证唯一性。</li>
</ul>
<p>SDK 为了解决上述情况，调整了 VC 的深度的计算：不再采用其 view 的深度，而是直接使用固定的0。因为 VC 已经是<code>viewPath</code>的根级别了，它的深度信息已经不重要了。</p>
<p>不过这种方案会引起另一个小问题，如果上述子 VC 的 VC1 和 VC2 是同一个类的不同实例，那么他们内部的视图结构是完全一样的，这时候如果使用固定的 VC 深度（0），通过<code>viewPath</code>就无法区分具体是哪个子 VC 的 view 了。针对这种同一类的不同实例，如果想进一步区分它们，SDK 采用了另一个方案：页面别名。</p>
<h4 id="5-viewId-的生成"><a href="#5-viewId-的生成" class="headerlink" title="5. viewId 的生成"></a>5. viewId 的生成</h4><p><code>viewPath</code> 已经能够唯一标识某个 view 了，为何还需要<code>viewId</code>呢？其实主要原因是：<code>viewPath</code> 的长度不固定，而且一般都会比较长，不便于后台使用它作为 view 的唯一标识。因此 SDK 使用<code>viewPath</code>信息通过<code>MD5</code>加密生成一个固定长度的值作为<code>viewId</code>。</p>
<h4 id="6-viewPath-与-viewId-重复时的解决方案"><a href="#6-viewPath-与-viewId-重复时的解决方案" class="headerlink" title="6. viewPath 与 viewId 重复时的解决方案"></a>6. viewPath 与 viewId 重复时的解决方案</h4><p>经过对<code>viewPath</code>的优化，SDK 已经尽可能的保证了<code>viewPath</code>的稳定性。但是并不表示只依靠<code>viewPath</code>就能区分所有的点击事件。有时同一个<code>viewPath</code>的 view 具有不同的表现形式与作用，例如下面的情况：</p>
<ul>
<li>同一个按钮在不同的状态下，显示不同的文字。例如：一个按钮在未添加商品前显示“添加”；添加了商品之后，立刻显示成“清除”</li>
<li>同一个view上具有多处点击事件，例如 SegmentControl、<code>UISwitch</code>、<code>UIStepper</code>等</li>
</ul>
<p>上面的这2种情况，都是同一个<code>viewPath</code>对应多个事件，此时如果只使用<code>viewPath</code>无法区分出不同的状态或事件。</p>
<p>针对这类问题，SDK 的解决方案是：<code>viewPath</code> + “其它信息” 。这里的 “其它信息”  是视不同情况而定的，比如: 在上面的情况1中，“其它信息” 就是按钮的 title。在情况2中，“其它信息” 是 SegmentControl 的 selectedIndex 和 UISwitch 的 isOn 属性的值。SDK 在进行数据收集时，会上传 view  的这些信息，再结合圈选SDK就能让后台在做统计时区分出这些不同的事件了。</p>
<p>关于“其它信息”，再补充一点，除了 SDK  事先知道要获取的信息之外，还有一类就是业务数据。例如：有一个商品列表页，每一行显示一个商品，如果后台想统计的不是列表中每一行的点击，而是每个商品 的点击，那么此时的“其它信息”就应该是productId 了。关于 SDK 对业务层数据的获取与上报请看下面的介绍。</p>
<h3 id="SDK无埋点业务数据收集的实现"><a href="#SDK无埋点业务数据收集的实现" class="headerlink" title="SDK无埋点业务数据收集的实现"></a>SDK无埋点业务数据收集的实现</h3><p>讲完了 <code>viewPath</code> 之后，接下来详细介绍下 SDK 的另一个关键技术：基于 <code>viewPath</code> 与 <code>KVC</code> 实现 SDK 的无埋点业务数据收集功能。首先，先简单分析一下传统的 <em>代码埋点</em> 存在的缺点，大致有以下几个：</p>
<ul>
<li>埋点代码与业务逻辑代码混合在一起，增加了代码的维护成本；</li>
<li>埋点代码需要跟随APP版本一起发布，耽误数据的收集与统计；</li>
<li>埋点时存在错埋、漏埋等情况，无法动态更新及添加；</li>
</ul>
<p>为了解决上述的 <em>代码埋点</em> 的缺陷，SDK 实现了真正意义上的 <strong>无埋点</strong> 来对业务数据进行收集。</p>
<h4 id="1-无埋点的实现架构"><a href="#1-无埋点的实现架构" class="headerlink" title="1. 无埋点的实现架构"></a>1. 无埋点的实现架构</h4><p>SDK 的无埋点功能的实现主要依赖于 <code>viewPath</code> 与 <code>KVC</code>。<code>viewPath</code>前面已经介绍了，它主要用于标识<code>viewTree</code>中的某个 view。而<code>KVC</code>对于 iOS 开发者也不陌生，堪称 iOS 开发中的黑魔法之一。通过<code>KVC</code>我们能够通过 key 或 keyPath 直接访问对象的属性，而不需要调用明确的存取方法。关于<code>KVC</code>如果不太了解，请自行学习，这里不再过多阐述。</p>
<p>那么如何实现不需要代码埋点就能随意获取想要的业务数据呢？先看一下 SDK 的无埋点技术的整体架构图：</p>
<p><img src="2.webp" alt="img"></p>
<p>从上图可以看出，在实现 SDK 的无埋点数据收集时，主要分为3步：上传KVC配置、请求KVC配置、业务数据的收集与上报。</p>
<h4 id="2-什么是-KVC-配置"><a href="#2-什么是-KVC-配置" class="headerlink" title="2. 什么是 KVC 配置"></a>2. 什么是 KVC 配置</h4><p>在上图中出现了 KVC配置，那么下面先简单介绍下什么是KVC配置。其实 KVC配置 就是一些用来描述 App 应该在什么时机去收集什么数据的信息，包含的主要信息有：</p>
<ul>
<li><strong>appKey：</strong>用来标识是哪个应用</li>
<li><strong>appVersion：</strong>用来标识应用的版本号</li>
<li><strong>viewEvent：</strong>标识某个事件类型（收集时机），例如：ButtonClick、ListItemClick、ViewTap等</li>
<li><strong>viewPath：</strong>目标 view 在<code>viewTree</code>中的信息</li>
<li><strong>keyPath：</strong>目标 view 与要收集的业务数据间的关联路径，用于KVC取值</li>
<li><strong>keyName：</strong>为要收集的业务数据定义一个key，最终组成 key-value 的形式上报。用于区分多个收集的数据</li>
</ul>
<h4 id="3-KVC配置的上传与下发"><a href="#3-KVC配置的上传与下发" class="headerlink" title="3. KVC配置的上传与下发"></a>3. KVC配置的上传与下发</h4><ul>
<li>上传KVC配置<ul>
<li>利用 圈选SDK 上传 KVC配置 的操作对于用户是透明的，主要由开发人员进行上传与管理。此操作可以在任何时候进行，在想要收集某个或某些版本的 App 中的业务数据时，上传相应的KVC配置信息至后台即可，达到了根据需要动态可配的效果。</li>
</ul>
</li>
<li>请求KVC配置<ul>
<li>SDK 在初始化时会触发 KVC配置 的请求操作，从后台拉取 App 当前版本对应的所有KVC配置，并将请求结果缓存起来，以提供给下一步使用。</li>
</ul>
</li>
</ul>
<h4 id="4-业务数据的收集与上报"><a href="#4-业务数据的收集与上报" class="headerlink" title="4. 业务数据的收集与上报"></a>4. 业务数据的收集与上报</h4><p>这一部分是 SDK 无埋点技术的核心，接下来详细介绍这部分的实现逻辑。它的实现流程如下：</p>
<p><img src="3.webp" alt="img"></p>
<p>这个环节的核心是基于<code>viewPath</code>的 view 匹配，主要实现是通过循环遍历<code>viewPath</code>的每个节点的信息与当前 view 及其父view 依次进行匹配。因此这一步会产生一定的时间与性能消耗。为了尽可能减少这部分的操作，SDK 中使用了一些方式进行优化，其中一个就是基于缓存view的优化。</p>
<h5 id="4-1-基于缓存view的优化"><a href="#4-1-基于缓存view的优化" class="headerlink" title="4.1 基于缓存view的优化"></a>4.1 基于缓存view的优化</h5><p>SDK 采用缓存上一次匹配成功的 view 信息的方式，来减少一些不必要的<code>viewPath</code>匹配操作。这里主要缓存的 view 信息有：</p>
<ul>
<li>targetView：上一次通过<code>viewPath</code>匹配成功的 view 对象。</li>
<li>indexPath： 上一次通过<code>viewPath</code>匹配成功的 view 的<code>indexPath</code>，如果没有则为nil。</li>
</ul>
<h5 id="1-viewEvent-匹配"><a href="#1-viewEvent-匹配" class="headerlink" title="1. viewEvent 匹配"></a>1. viewEvent 匹配</h5><p>第一步先进行事件类型的匹配。如果KVC配置信息指定的 viewEvent 是 ButtonClick，那么可以轻松的过滤掉 ListItemClick、ViewTap 等其它事件。这一步能够过滤一大部分事件，只有事件类型匹配成功才继续进行下一步。</p>
<h5 id="2-targetView-匹配"><a href="#2-targetView-匹配" class="headerlink" title="2. targetView 匹配"></a>2. targetView 匹配</h5><p>接下来就是将缓存的 targetView 与当前 view 进行比较。如果两者指向同一对象，则进行第3步，否则直接进入第4步</p>
<h5 id="3-indexPath-匹配"><a href="#3-indexPath-匹配" class="headerlink" title="3. indexPath 匹配"></a>3. indexPath 匹配</h5><p>有人可能不明白为何要添加这一步呢？其实这一步也很重要，是对第2步的补充，主要是用来处理 Cell 可复用性的情况。</p>
<p>如果第2步中缓存的 targetView 是 Cell 或 Cell 中的某个 subview，那么第2步的匹配成功，并不能保证当前 view 就是我们真正想匹配的 view。这个可能不太容易理解，还是举个简单的例子来说明一下：</p>
<ul>
<li>假如一个 Cell 中有一个 button，在第1行的 button 被点击时，通过<code>viewPath</code>匹配成功 了，那么这时 targetView 缓存了第1行的 button  对象。接下来向下滑动列表，第一行被划出屏幕，第10行划入屏幕，同时第10行复用了第1行的 Cell，这时再点击 button 去匹配时，由于  Cell 复用的原因，targetView 与当前 button 肯定指向同一个对象，但是却不是我们真正想匹配的第1行的  button。可以看出：在有 Cell 复用的情况下，无法确定第2步的结果一定正确。</li>
</ul>
<p>因此，在第2步的基础上又增加了<code>indexPath</code>匹配。<code>indexPath</code>的匹配逻辑为：如果缓存的<code>indexPath</code>不为<code>nil</code>并且与当前view的<code>indexPath</code>不相等，则进入第4步；否则表明当前的 view 就是上次刚刚匹配成功的，也就没必要进行<code>viewPath</code>匹配，可以直接进入第5步。</p>
<h5 id="4-viewPath-匹配"><a href="#4-viewPath-匹配" class="headerlink" title="4. viewPath 匹配"></a>4. viewPath 匹配</h5><p>这一步就是对当前的 view 及其父view 与<code>KVC</code>配置中的<code>viewPath</code>的各个节点进行逐个匹配。由于是一个循环操作，因此会有一定的时间消耗，其实在这部分的匹配中，也做了一些简单的优化。在真正进入循环匹配之前，先进行如下3步判断：</p>
<ul>
<li>判断 view 类名是否相等；</li>
<li>判断 view 所在的 viewController 类名是否相等；</li>
<li>判断 view 所在的 window 类名是否相等；</li>
</ul>
<p>上述的3个判断也能过滤很多不必要的匹配。只有这3个判断均通过后，才进行<code>viewPath</code>循环匹配。</p>
<h5 id="5-KVC-取值与上报"><a href="#5-KVC-取值与上报" class="headerlink" title="5. KVC 取值与上报"></a>5. KVC 取值与上报</h5><p>到了这一步，就已经验证了数据收集的时机是正确的。接下来就可以直接使用 KVC配置信息中的<code>keyPath</code>调用 <code>valueForKeyPath:</code> 方法获取对应的值。如果值不为<code>nil</code>，就与 keyName 组成一个键值对，放到当前的事件数据中一起上报上去。这样后台就可以通过key去查找到相应的业务数据了。</p>
<p>上面只是简要介绍了一下匹配时的逻辑，在实际开发中还会添加对 cell 的<code>indexPath</code>通配的情况的处理，由于文章篇幅这里不再详细讲解。</p>
<h3 id="5-增加对-KVC-的异常处理"><a href="#5-增加对-KVC-的异常处理" class="headerlink" title="5. 增加对 KVC 的异常处理"></a>5. 增加对 KVC 的异常处理</h3><p>SDK 的无埋点功能的实现其实主要依赖于<code>KVC</code>，但是众所周知，<code>KVC</code>是非常危险的，很容易造成程序崩溃。例如一旦 key 或 keyPath 所对应的属性名不存在，立刻会导致程序抛出一个<code>NSUndefinedKeyException</code>异常，如果应用没有处理此异常，程序就会Crash。</p>
<p>因此，为了避免程序Crash，SDK 内部增加了对<code>KVC</code>异常的处理。具体实现是给 <code>NSObject</code> 增加一个 Category ，重写 <code>valueForUndefinedKey:</code> 方法，并在方法中<code>return nil</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">KVCExceptionHandler</span>)</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="其它关键技术"><a href="#其它关键技术" class="headerlink" title="其它关键技术"></a>其它关键技术</h3><p>当然，SDK 的实现中还有很多关键技术点，比如：SDK 对 RN 页面的数据收集、页面别名方案的实现、<code>Method Swizzling</code>与<code>Aspects</code>的兼容等。由于本文的篇幅已经很长了，而且考虑到大家读文章的耐性都不会太长，所以这里就先不讲解了，后续会再写文章单独介绍。</p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>文章写了这么多，其实主要介绍了 SDK 中的两个关键技术点，希望对你们能有一些参考价值。另外，如果有人对本文的方案有更好的建议，欢迎一起讨论学习。</p>
<p>最后，要特别感谢我的同事王佳乐，由于他对文章的排版与校对工作，才使得本文能更好的展示给大家。同时也要感谢组内的所有同事，在我开发遇到困难时，给予了我很多的帮助。</p>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>关于对本文内容提出的一些问题，将全部记录在这里（简书评论里的除外），并进行统一解答。</p>
<h4 id="Q1-SDK-都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？"><a href="#Q1-SDK-都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？" class="headerlink" title="Q1: SDK 都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？"></a>Q1: SDK 都使用KVC配置获取业务数据，是否会增加维护KVC配置的工作？</h4><h4 id="A1-会有对-KVC配置-的维护与管理工作，不过-SDK-也简化了这块的管理工作。"><a href="#A1-会有对-KVC配置-的维护与管理工作，不过-SDK-也简化了这块的管理工作。" class="headerlink" title="A1: 会有对 KVC配置 的维护与管理工作，不过 SDK 也简化了这块的管理工作。"></a>A1: 会有对 KVC配置 的维护与管理工作，不过 SDK 也简化了这块的管理工作。</h4><p>一般来说，上传的所有的 KVC配置 需要与 App 的版本相对应，因为 App 版本不同会直接导致<code>keyPath</code>可能不一样。所以与 KVC配置 相关的工作有如下2个：</p>
<ol>
<li>针对当前 App 版本上传相应的 KVC配置，以获取想要的业务数据</li>
<li>当 App 新版本发布时，需要对之前版本上的 KVC配置 逐一验证，是否仍然适用于新版本。如果仍然适用，则直接在管理后台上把新的版本号添加到此 KVC配置；如果不再适用，则对新版本再上传一个新的KVC配置。</li>
</ol>
<p>从上面可以看出，在 App 版本不断迭代的过程中，KVC配置 会越来越多，相应的维护与管理工作也相当繁琐。</p>
<p>为了解决这个痛点，SDK 中增加了一种方案来避免这种重复且繁琐的工作。具体的方案是：</p>
<ul>
<li>在上传 KVC 配置时，指定某个区间的版本，或者不指定具体的版本（即应用到当前所有版本上）；</li>
<li>SDK 在使用KVC配置获取业务数据失败时，添加相关的错误日志，并上报上去。其中错误日志里包含了<code>appKey</code>、<code>appVersion</code>、<code>keyPath</code>等信息，这样就能在后台清晰的看到哪些 KVC配置 在哪个 App 版本上存在问题；</li>
<li>使用脚本监控与<code>KVC</code>相关的错误日志。如果监控到有错误日志上报，则发送邮件通知给相关人员；</li>
</ul>
<p>因此，SDK 采用此方案优化之后，KVC配置 的管理工作就只有1个了：</p>
<ul>
<li>根据Log信息快速找到对应的 KVC配置，并上传一个针对新版本的 KVC配置</li>
</ul>
<h4 id="Q2-对于-“内容与位置”-可能会随时间而变动时，如何实现数据收集与统计？"><a href="#Q2-对于-“内容与位置”-可能会随时间而变动时，如何实现数据收集与统计？" class="headerlink" title="Q2: 对于 “内容与位置” 可能会随时间而变动时，如何实现数据收集与统计？"></a>Q2: 对于 “内容与位置” 可能会随时间而变动时，如何实现数据收集与统计？</h4><h4 id="A2-使用圈选SDK与数据SDK共同完成动态数据的收集与统计"><a href="#A2-使用圈选SDK与数据SDK共同完成动态数据的收集与统计" class="headerlink" title="A2: 使用圈选SDK与数据SDK共同完成动态数据的收集与统计"></a>A2: 使用圈选SDK与数据SDK共同完成动态数据的收集与统计</h4><p>这个问题在实际产品中也比较常见，比如 App 首页的内容大多是通过后台配置的。<br> 这个问题其实可以转化或分解成如下的2个情况：</p>
<ul>
<li>同一位置会显示不同的内容</li>
<li>同一内容会显示在不同的位置</li>
</ul>
<p>注意，这2个并非同一个，它们分别对应于不同的场景，同时数据收集的方案也有所不同。</p>
<p>另外，“位置” 可以是在列表中，也可以是非列表中的，不过这个对整体的方案没有太大影响，仅仅是在不关心位置时<code>viewPath</code>中的通配符位置不同。</p>
<h5 id="A2-1-同一位置显示不同的内容"><a href="#A2-1-同一位置显示不同的内容" class="headerlink" title="A2.1 同一位置显示不同的内容"></a>A2.1 同一位置显示不同的内容</h5><p>例子：在 App 首页有一个展示最近活动的位置，先展示活动1的图片，过一段时间运营人员又配成活动2的图片。如何统计活动1、活动2各自的点击量？</p>
<p>针对这种场景，SDK 的解决方案是：<strong>“关心位置” + “关心内容”</strong>。<br> <strong>“关心位置”</strong> 的意思是只使用当前的位置，具体表现是<code>viewPath</code>中不包含任何通配符；<strong>“关心内容”</strong> 的意思是指定一个想要统计的内容。</p>
<p>整个过程可以分解为如下3个环节：</p>
<ul>
<li>圈选SDK上传<strong>“关心位置”</strong>的KVC配置。KVC配置中指定获取活动的<code>url</code>的<code>keyPath</code>。</li>
<li>数据SDK在活动发生点击时，收集当前活动对应的<code>url</code>，并跟随点击事件一起上报。</li>
<li>圈选SDK上传<strong>“关心位置” + “关心内容”</strong>的圈选配置，关心的内容指定为想要统计的活动的<code>url</code>值。</li>
</ul>
<h5 id="A2-2-同一内容显示在不同的位置"><a href="#A2-2-同一内容显示在不同的位置" class="headerlink" title="A2.2 同一内容显示在不同的位置"></a>A2.2 同一内容显示在不同的位置</h5><p>例子：App 首页有4个固定的入口，假设其中一个叫“热门推荐”，那么根据后台配置的顺序不同，“热门推荐”可能被显示在4个位置中的任何1个，即一段时间显示在第1个，过一段时间可能显示在第2个位置。这时如何统计出“热门推荐”的点击量？</p>
<p>针对这种场景，SDK 的解决方案是：<strong>“不关心位置” + “关心内容”</strong>。<br> <strong>“不关心位置”</strong> 是指<code>viewPath</code>中含有通配符，用于表示<code>viewTree</code>中的多个位置。例如想要匹配列表所有行时，则将<code>viewPath</code>中的<code>indexPath</code>替换为通配符。</p>
<p>这个问题的解决过程也分为如下3步：</p>
<ul>
<li>圈选SDK上传<strong>“不关心位置”</strong>的KVC配置。KVC配置中指定获取入口的 title 的<code>keyPath</code>。</li>
<li>数据SDK在4个中任何一个入口被点击时，都去收集入口的 title，并跟随点击事件一起上报。</li>
<li>圈选SDK上传<strong>“不关心位置” + “关心内容”</strong>的圈选配置，关心的内容指定为“热门推荐”。</li>
</ul>
<p>到这里，数据收集与圈选配置的工作都已经做完了，接下来就是后台的数据统计了。<br> 上述2种情况对后台进行统计没有区别，都使用一个统计方案，这里也介绍一下后台大概的统计思路：</p>
<ul>
<li>拿到第3步中上传的圈选配置，根据<code>viewPath</code> 与 <strong>“关心的内容”</strong> 生成一个正则表达式，然后从数据 SDK 上报的原始数据中进行正则匹配，进而统计出相应数据。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2023/01/03/iOS%E6%9E%B6%E6%9E%84/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB%E4%B9%8B%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/03/iOS%E6%9E%B6%E6%9E%84/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB%E4%B9%8B%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">移动端监控体系之技术原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-03 17:28:11 / 修改时间：18:40:08" itemprop="dateCreated datePublished" datetime="2023-01-03T17:28:11+08:00">2023-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文为转载：</p>
<p>作者：Joy_xx<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903498383900680">https://juejin.cn/post/6844903498383900680</a><br>来源：稀土掘金</p>
<p>在这样一个注重用户体验的时代，<code>APM</code> 技术快速发展，国内更是百花齐放，最近对各个公司的 <code>APM</code> 产品有一个调研，并在此基础上进行了自己的实践。这里就从 iOS 的角度出发，谈谈自己对移动端 APM 的技术上的理解，并提供相对应的实例。</p>
<h2 id="何为-APM"><a href="#何为-APM" class="headerlink" title="何为 APM"></a>何为 APM</h2><p><code>APM</code> 的全称是<code>Application performance management</code>，即应用性能管理，通过对应用的可靠性、稳定性等方面的监控，进而达到可以快速修复问题、提高用户体验的目的。</p>
<p>国内各大公司都有自己的一套监控体系，这个系统可能是自己研发，也可能是第三方提供，当然对于这个数据为王的时代，很多有实力的公司倾向于自主研发，掌握核心数据。比较有代表性的 APM 产品有：听云、阿里百川、腾讯 bugly、NewRelic、OneAPM、网易云捕等</p>
<p>说到监控，那么指标是我们所关注的呢？如下所示</p>
<ul>
<li>网络请求：成功率、状态码、流量、网络响应时间、HTTP与HTTPS的 DNS 解析、TCP握手、SSL握手（HTTP除外）、首包时间等时间</li>
<li>界面卡顿、卡顿堆栈</li>
<li>崩溃率、崩溃堆栈</li>
<li>Abort 率：也就是由于内存过高的等原因，被系统杀死的情况</li>
<li>交互监控：页面加载时间、页面的交互痕迹</li>
<li>维度信息：地域、运营商、网络接入方式、操作系统、应用版本等</li>
<li>其他：内存、帧率、CPU使用率、启动时间、电量等</li>
</ul>
<h2 id="聊聊原理"><a href="#聊聊原理" class="headerlink" title="聊聊原理"></a>聊聊原理</h2><h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3><p>当应用发生卡顿的时候，一般会伴随着掉帧，所以帧率是最容易想到的指标来判断卡顿。对于线下的测试环境，我们可以使用帧率来对开发做一些提示，告诉他们可能发生了卡顿。但是帧率不稳定性较高，所以一般会采取另一种方式来做卡顿检测。那就是Runloop，对于细节可以查看 <code>Runloop</code> 源码，会发现对于事件的处理主要就是在<code>kCFRunLoopBeforeSources</code>和<code>kCFRunLoopBeforeWaiting</code>状态之间,还有<code>kCFRunLoopAfterWaiting</code>之后。那我们就可以对两个状态进行监控，如果消耗时间太久，就代表着卡顿的发生。</p>
<p><img src="runloop.jpg" alt="runloop"></p>
<p>上图摘自阿里百川，如图所示，我们会对卡顿次数做一个判断，如果次数为1，但时间超时，则为单次耗时较长的卡顿，如果次数到达阀值，则证明是连续短时间卡顿。</p>
<p>当卡顿发生之后，我们为了定位，会收集当时的一个堆栈情况，在此你可以使用 <code>PLCrashReporter</code> 来做，也可以自己研发一个堆栈收集库（可<a href="http://www.jianshu.com%2Fp%2F7e4c7b94ca36">参考这里来做</a>）</p>
<p>对于实例，网上已经有很多开源的项目，你可以<a href="https://link.juejin.cn/?target=https://github.com/suifengqjn/PerformanceMonitor">参考这个</a></p>
<h3 id="崩溃检测"><a href="#崩溃检测" class="headerlink" title="崩溃检测"></a>崩溃检测</h3><p>对于崩溃的情况，一般是由 <code>Mach</code>异常或 <code>Objective-C</code> 异常（NSException）引起的。我们可以针对这两种情况抓取对应的 <code>Crash</code> 事件。</p>
<h4 id="Mach-异常捕获"><a href="#Mach-异常捕获" class="headerlink" title="Mach 异常捕获"></a>Mach 异常捕获</h4><p>如果想要做<code>mach</code> 异常捕获，需要注册一个异常端口，这个异常端口会对当前任务的所有线程有效，如果想要针对单个线程，可以通过 <code>thread_set_exception_ports</code>注册自己的异常端口，发生异常时，首先会将异常抛给线程的异常端口，然后尝试抛给任务的异常端口，当我们捕获异常时，就可以做一些自己的工作，比如，当前堆栈收集等。</p>
<p>对于如何注册一个异常端口，这里有示意图和 <a href="https://link.juejin.cn/?target=https://github.com/plausiblelabs/plcrashreporter">PLCrashReporter</a> 可以参考</p>
<p><img src="machport.jpg" alt="machport"></p>
<h3 id="Unix-信号捕获"><a href="#Unix-信号捕获" class="headerlink" title="Unix 信号捕获"></a>Unix 信号捕获</h3><p>对于Mach 异常，操作系统会将其转换为对应的 Unix信号，所以如果你对<code>Mach</code>不熟悉的话，也可以通过注册<code>signalHandler</code>的方式来做信号异常。对于实例，你可以<a href="https://link.juejin.cn/?target=https://github.com/xcysuccess/iOSCrashUncaught">参考这里</a></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGHUP, signalHandler);</span><br><span class="line"><span class="built_in">signal</span>(SIGINT, signalHandler);</span><br><span class="line"><span class="built_in">signal</span>(SIGQUIT, signalHandler);</span><br><span class="line">   </span><br><span class="line"><span class="built_in">signal</span>(SIGABRT, signalHandler);</span><br><span class="line"><span class="built_in">signal</span>(SIGILL, signalHandler);</span><br><span class="line"><span class="built_in">signal</span>(SIGSEGV, signalHandler);</span><br><span class="line"><span class="built_in">signal</span>(SIGFPE, signalHandler);</span><br><span class="line"><span class="built_in">signal</span>(SIGBUS, signalHandler);</span><br><span class="line"><span class="built_in">signal</span>(SIGPIPE, signalHandler);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="NSException-捕获"><a href="#NSException-捕获" class="headerlink" title="NSException 捕获"></a>NSException 捕获</h3><p>对于<code>NSException</code>异常，也比较容易处理，通过注册<code>NSUncaughtExceptionHandler</code>捕获异常信息即可，将拿到的<code>NSException</code>细节写入<code>Crash</code>日志，上传到后台做数据分析</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register the uncaught exception handler</span></span><br><span class="line"><span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;handler);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Abort-率检测"><a href="#Abort-率检测" class="headerlink" title="Abort 率检测"></a>Abort 率检测</h3><p>目前对于内存过高被杀死的情况是没有办法直接统计的，一般通过排除法来做百分比的统计，原理如下</p>
<ul>
<li>程序启动，设置标志位</li>
<li>程序正常退出，清楚标志</li>
<li>程序<code>Crash</code>，清楚标志</li>
<li>程序电量过低导致关机，这个也没办法直接监控，可以加入电量检测来辅助判断</li>
<li>第二次启动，标志位如果存在，则代表<code>Abort</code>一次，上传后台做统计</li>
</ul>
<p><img src="abort.jpg" alt="abort"></p>
<h3 id="交互监控"><a href="#交互监控" class="headerlink" title="交互监控"></a>交互监控</h3><p>对于页面的加载时间，这个比较容易实现，直接通过<code>Runtime hook</code>对应的生命周期方法即可，比如 <code>viewDidLoad</code>、<code>viewWillAppear</code>等</p>
<p>对于用户的交互痕迹，比如点击了那个按钮、跳转到了那个页面，这些信息偏于用户行为的收集，我们也独立研发了一个无埋点的SDK，专门来做用户行为数据的收集与分析，核心也是基于 <code>hook AOP</code>的思想。细节可以<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/69ce01e15042">参考我同事的作品</a></p>
<h3 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h3><p>对于成功率、状态码、流量，以及网络的响应时间之类的，我们可以主要可以通过两种方式来做</p>
<ul>
<li>针对<code>URLConnection</code>、<code>CFNetwork</code>、<code>NSURLSession</code>三种网络做<code>Hook</code>，<code>hook</code>的具体技术可以是<code>method swizzle</code> 也可以是<code>Proxy</code>、<code>Fishhook</code>之类的</li>
<li>也可以使用 <code>NSURLProtocol</code> 对网络请求的拦截，进而得到流量、响应时间等信息，但是<code>NSURLProtocol</code>有自己的局限，比如<code>NSURLProtocol</code>只能拦截<code>NSURLSession</code>，<code>NSURLConnection</code>以及<code>UIWebView</code>，但是对于<code>CFNetwork</code>则无能为力</li>
</ul>
<p>对于第一种方式可以<code>Hook</code>哪些方法的，可以参考这个图</p>
<p><img src="NSURLMonitor.jpg" alt="网络监控"></p>
<p>但是，因为我们所使用的<code>URLConnection</code>、<code>CFNetwork</code>、<code>NSURLSession</code>底层都是 <code>BSDSocket</code>，所以可以尝试在<code>socket</code>上动手脚来实现效果，类似于通过<code>ViewController</code>的生命周期方法来统计页面加载时间的做法，我们<code>Hook socket</code>相关的方法来做，比如通过<code>hook</code> <code>socket</code>连接时的 <code>connect</code>方法，拿到<code>tcp</code>握手的起始时间，通过<code>hook</code> <code>SSLHandshake</code>方法，在<code>SSLHandshake</code>执行的时候拿到 <code>SSL</code>握手的起始时间等。目前听云已经提供了 <code>HTTP</code> 的分段时间查询功能，大家去体验下</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>	<span class="title">connect</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *, <span class="type">socklen_t</span>)</span> __<span class="title">DARWIN_ALIAS_C</span><span class="params">(connect)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">OSStatus <span class="title">SSLHandshake</span><span class="params">(SSLContextRef ctx)</span> </span></span><br><span class="line"><span class="function">复制代码</span></span><br></pre></td></tr></table></figure>

<p>但是对于 iOS 9 Apple 加入 ATS 新特性，并要求开发者使用 HTTPS，我在  iOS9、10上对 HTTPS  网络请求<code>Hook socket</code>方法时候，有一些方法<code>hook</code> 失效，猜想应该是Apple 进行了加固、加密，导致一些系统方法没办法<code>hook</code>，所以在 iOS9、10 上无法通过<code>socket</code>来取得<code>HTTPS</code>网络的分段时间（纠正：fishhook 无法 hook socket 的原因：<a target="_blank" rel="noopener" href="https://github.com/facebook/fishhook/issues/40%EF%BC%89">https://github.com/facebook/fishhook/issues/40）</a></p>
<p>不过<code>apple</code>在 iOS 10 推出一个<code>API</code>，可以在 iOS10 版本以上进行网络信息的收集</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didFinishCollectingMetrics:(<span class="built_in">NSURLSessionTaskMetrics</span> *)metrics </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">Fetch</span> <span class="keyword">Start</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">06</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(Domain Lookup <span class="keyword">Start</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">06</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(Domain Lookup <span class="keyword">End</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">06</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(<span class="keyword">Connect</span> <span class="keyword">Start</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">14</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(Secure Connection <span class="keyword">Start</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">14</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(Secure Connection <span class="keyword">End</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">16</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(<span class="keyword">Connect</span> <span class="keyword">End</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">16</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(Request <span class="keyword">Start</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">16</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(Request <span class="keyword">End</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">16</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(Response <span class="keyword">Start</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">16</span> <span class="operator">+</span><span class="number">0000</span></span><br><span class="line">(Response <span class="keyword">End</span>) <span class="number">2017</span><span class="number">-02</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">16</span> <span class="operator">+</span><span class="number">0000</span></span><br></pre></td></tr></table></figure>

<p>当然，对于网络各层次的时间获取，如果你有好的方案，希望您可以留言告知。同时对于一些维度信息和内存等基础指标，很容易获取，这里就不细谈了</p>
<h2 id="大礼包"><a href="#大礼包" class="headerlink" title="大礼包"></a>大礼包</h2><p>在调研和学习APM技术的过程中，发现了很多优秀的博客，所以在此推荐给大家，有需要的可以自取</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/presentations/mobile-terminal-full-link-tracking-and-security-system">蘑菇街移动端全链路跟踪保障体系</a></li>
<li><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s/MwgjpHj_5RaG74Z0JjNv5g">美团外卖移动端性能监测体系实现</a></li>
<li><a target="_blank" rel="noopener" href="https://wereadteam.github.io/2016/12/12/Monitor/">微信读书 iOS 质量保证及性能监控</a></li>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/netease-ios-sdk-neteaseapm-technology-share">网易NeteaseAPM iOS SDK技术实现分享</a></li>
<li><a target="_blank" rel="noopener" href="http://www.imooc.com/article/14205?block_id=tuijian_wz">阿里百川码力APP监控来了 重量级选手进入APM市场</a></li>
<li><a href="https://link.juejin.cn/?target=https://github.com/joy0304/Joy-Blog/blob/master/iOS%20Collection.md">APM最佳实践系列文章专题合辑</a></li>
<li><a href="https://mp.weixin.qq.com%2Fs%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26mid%3D2650400312%26idx%3D1%26sn%3Dce8468991c70ab2e06634f59cd2b6865%26chksm%3D83952e20b4e2a736f701853a483da535312a258a56ca87d65b8ef77e8cf012dab9145659a0aa%26scene%3D0%26key%3D459eeebe1b51063320bc30b7024529048032de1a4d3a8e7cf01dbfc995da8f74fe85688c8be0471b1fdcb82d9b875d163a62f42e9ca04946e2c899194097fb93632ca7790f6fb7395d897442b9272213%26ascene%3D0%26uin%3DMTY3NzkzNjI0NA%3D%3D%26devicetype%3DiMac%2BMacBookPro12%2C1%2BOSX%2BOSX%2B10.12.2%2Bbuild(16C67)%26version%3D12020010%26nettype%3DWIFI%26fontScale%3D100%26pass_ticket%3DJE5tAT8H%2BfKdFzHQq72mWMIv%2BitHWOqOma3xmX5OeGGPWz2mPXxz3kaQE1WSKJlw">手机淘宝：亿级用户APP的快速运维交付实践</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/12/30/OC%E5%85%B6%E5%AE%83/apple%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/OC%E5%85%B6%E5%AE%83/apple%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">apple相关文档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-30 13:54:00" itemprop="dateCreated datePublished" datetime="2022-12-30T13:54:00+08:00">2022-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-03 15:52:59" itemprop="dateModified" datetime="2023-01-03T15:52:59+08:00">2023-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Apple/" itemprop="url" rel="index"><span itemprop="name">Apple</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th>编号</th>
<th>地址</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/cn/app-store/review/guidelines/#design">https://developer.apple.com/cn/app-store/review/guidelines/#design</a></td>
<td>Apple审核文档</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://help.apple.com/app-store-connect/#/dev28d17ed35">https://help.apple.com/app-store-connect/#/dev28d17ed35</a></td>
<td>App store的操作说明文档</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/">https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/</a></td>
<td>iOS 人机交互文档</td>
</tr>
<tr>
<td>4</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/wwdc19/">https://developer.apple.com/wwdc19/</a></td>
<td>WWDC 发布视频</td>
</tr>
<tr>
<td>5</td>
<td><a target="_blank" rel="noopener" href="http://appstoreconnect.apple.com/">http://appstoreconnect.apple.com</a></td>
<td>App store 后台</td>
</tr>
<tr>
<td>6</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/account/resources/certificates/list">https://developer.apple.com/account/resources/certificates/list</a></td>
<td>App证书管理后台</td>
</tr>
<tr>
<td>7</td>
<td><a target="_blank" rel="noopener" href="https://idmsa.apple.com/IDMSWebAuth/signin.html?path=/contact/app-store/?topic=expedite&appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757">https://idmsa.apple.com/IDMSWebAuth/signin.html?path=%2Fcontact%2Fapp-store%2F%3Ftopic%3Dexpedite&amp;appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757</a></td>
<td>反馈及申请加速后台</td>
</tr>
<tr>
<td>8</td>
<td>[<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/navigation/#section=Resource%20Types&topic=Sample%20Code]">https://developer.apple.com/library/archive/navigation/#section=Resource%20Types&amp;topic=Sample%20Code]</a>(<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/navigation/#section=Resource">https://developer.apple.com/library/archive/navigation/#section=Resource</a> Types&amp;topic&#x3D;Sample Code)</td>
<td>Apple 官方技术文档</td>
</tr>
<tr>
<td>9</td>
<td><a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/8.0/#/devc8c2a6be1">https://help.apple.com/xcode/mac/8.0/#/devc8c2a6be1</a></td>
<td>Apple开发工具说明文档</td>
</tr>
<tr>
<td>10</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008244-SW1">https://developer.apple.com/library/archive/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008244-SW1</a></td>
<td>iOS系统版本文档</td>
</tr>
<tr>
<td>11</td>
<td><a target="_blank" rel="noopener" href="https://appleid.apple.com/account/manage">https://appleid.apple.com/account/manage</a></td>
<td>账号更新、换绑</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/12/28/iOS%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/28/iOS%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">软件架构模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-28 16:24:23" itemprop="dateCreated datePublished" datetime="2022-12-28T16:24:23+08:00">2022-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-03 17:29:59" itemprop="dateModified" datetime="2023-01-03T17:29:59+08:00">2023-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件架构模式"><a href="#软件架构模式" class="headerlink" title="软件架构模式"></a>软件架构模式</h1><p>转载：原文地址：<a target="_blank" rel="noopener" href="https://gitlab.com/BangHeriSetiawan/android-tech-frontier/blob/00911a665a20cb4c85c1db7ade4410c292d32ed5/software-architecture-patterns/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.md#appendix">软件架构模式</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对程序员来说很常见一种情况是在没有合理的程序架构时就开始编程，没有一个清晰的和定义好的架构的时候，大多数开发者和架构师通常会使用标准式的传统分层架构模式（也被称为多层架构）——通过将源码模块分割为几个不同的层到不同的包中。不幸的是，这种编码方式会导致一系列没有组织性的代码模块，这些模块缺乏明确的规则、职责和同其他模块之间的关联。这通常被称为架构大泥球。</p>
<p>应用程序缺乏合理的架构一般会导致程序过度耦合、容易被破坏、难以应对变化，同时很难有一个清晰的版本或者方向性。这样的结果是，如果你没有充分理解程序系统里每个组件和模块，就很难定义这个程序的结构特征。有关于程序的部署和维护的基本问题都难以回答，比如：程序架构是什么规模?应用程序有什么性能特点?应用程序有多容易应对变化?应用程序的部署特点是什么?架构是如何反应的?</p>
<p>架构模式帮助你定义应用程序的基本特征和行为。例如，一些架构模式会让程序自己自然而然地朝着具有良好伸缩性的方向发展，而其他架构模式会让程序朝着高度灵活的方向发展。知道了这些特点，了解架构模式的优点和缺点是非常必要的，它帮助我们选择一个适合自己特定的业务需求和目标的的程序。</p>
<p>作为一个架构师,你必须证明你的架构模式的决策是正确的,特别是当需要选择一个特定的体系结构模式或方法的时候。这本迷你书的目的就是给你足够的信息让你去做出正确的架构决策。</p>
<h2 id="第一章-分层架构"><a href="#第一章-分层架构" class="headerlink" title="第一章 分层架构"></a>第一章 分层架构</h2><p>分层架构是一种很常见的架构模式，它也叫N层架构。这种架构是大多数Jave EE应用的实际标准，因此很多的架构师，设计师，还有程序员都知道它。许多传统IT公司的组织架构和分层模式十分的相似。所以它很自然的成为大多数应用的架构模式。</p>
<h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><p>分层架构模式里的组件被分成几个平行的层次，每一层都代表了应用的一个功能(展示逻辑或者业务逻辑)。尽管分层架构没有规定自身要分成几层几种，大多数的结构都分成四个层次:展示层，业务层，持久层，和数据库层。如表1-1，有时候，业务层和持久层会合并成单独的一个业务层，尤其是持久层的逻辑绑定在业务层的组件当中。因此，有一些小的应用可能只有3层，一些有着更复杂的业务的大应用可能有5层或者更多的分层。</p>
<p>分层架构中的每一层都着特定的角色和职能。举个例子，展示层负责处理所有的界面展示以及交互逻辑，业务层负责处理请求对应的业务。架构里的层次是具体工作的高度抽象，它们都是为了实现某种特定的业务请求。比如说展示层并不需要关心怎样得到用户数据，它只需在屏幕上以特定的格式展示信息。业务层并不关心要展示在屏幕上的用户数据格式，也不关心这些用户数据从哪里来。它只需要从持久层得到数据，执行与数据有关的相应业务逻辑，然后把这些信息传递给展示层。</p>
<p><img src="1-1.png" alt="1-1"></p>
<p>分层架构的一个突出特性是组件间关注点分离 (separation of concerns)。一个层中的组件只会处理本层的逻辑。比如说，展示层的组件只会处理展示逻辑，业务层中的组件只会去处理业务逻辑。多亏了组件分离，让我们更容易构造有效的角色和强力的模型。这样应用变的更好开发，测试，管理和维护。</p>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><p>注意表1-2中每一层都是封闭的。这是分层架构中非常重要的特点。这意味request必须一层一层的传递。举个例子，从展示层传递来的请求首先会传递到业务层，然后传递到持久层，最后才传递到数据层。</p>
<p><img src="1-2.png" alt="1-2"></p>
<p>那么为什么不允许展示层直接访问数据层呢。如果只是获得以及读取数据，展示层直接访问数据层，比穿过一层一层来得到数据来的快多了。这涉及到一个概念:层隔离。</p>
<p>层隔离就是说架构中的某一层的改变不会影响到其他层:这些变化的影响范围限于当前层次。如果展示层能够直接访问持久层了，假如持久层中的SQL变化了，这对业务层和展示层都有一定的影响。这只会让应用变得紧耦合，组件之间互相依赖。这种架构会非常的难以维护。</p>
<p>从另外一个方面来说，分层隔离使得层与层之间都是相互独立的，架构中的每一层的互相了解都很少。为了说明这个概念的牛逼之处，想象一个超级重构，把展示层从JSP换成JSF。假设展示层和业务层的之间的联系保持一致，业务层不会受到重构的影响，它和展示层所使用的界面架构完全独立。</p>
<p>然而封闭的架构层次也有不便之处，有时候也应该开放某一层。如果想往包含了一些由业务层的组件调用的普通服务组件的架构中添加一个分享服务层。在这个例子里，新建一个服务层通常是一个好主意，因为从架构上来说，它限制了分享服务访问业务层(也不允许访问展示层)。如果没有隔离层，就没有任何架构来限制展示层访问普通服务，难以进行权限管理。</p>
<p>在这个例子中，新的服务层是处于业务层之下的，展示层不能直接访问这个服务层中的组件。但是现在业务层还要通过服务层才能访问到持久层，这一点也不合理。这是分层架构中的老问题了，解决的办法是开放某些层。如表1-3所示，服务层现在是开放的了。请求可以绕过这一层，直接访问这一层下面的层。既然服务层是开放的，业务层可以绕过服务层，直接访问数据持久层。这样就非常合理。</p>
<p><img src="1-3.png" alt="1-3"></p>
<p>开放和封闭层的概念确定了架构层和请求流之间的关系，并且给设计师和开发人员提供了必要的信息理解架构里各种层之间的访问限制。如果随意的开放或者封闭架构里的层，整个项目可能都是紧耦合，一团糟的。以后也难以测试，维护和部署。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>为了演示分层架构是如何工作的，想象一个场景，如表1-4，用户发出了一个请求要获得客户的信息。黑色的箭头是从数据库中获得用户数据的请求流，红色箭头显示用户数据的返回流的方向。在这个例子中，用户信息由客户数据和订单数组组成(客户下的订单)。</p>
<p>用户界面只管接受请求以及显示客户信息。它不管怎么得到数据的，或者说得到这些数据要用到哪些数据表。如果用户界面接到了一个查询客户信息的请求，它就会转发这个请求给用户委托(Customer Delegate)模块。这个模块能找到业务层里对应的模块处理对应数据(约束关系)。业务层里的customer object聚合了业务请求需要的所有信息(在这个例子里获取客户信息)。这个模块调用持久层中的 customer dao 来得到客户信息，调用order dao来得到订单信息。这些模块会执行SQL语句，然后返回相应的数据给业务层。当 customer object收到数据以后，它就会聚合这些数据然后传递给 customer delegate,然后传递这些数据到customer screen 展示在用户面前。</p>
<p><img src="1-4.png" alt="1-4"></p>
<p>从技术的角度来说，有很多的方式能够实现这些模块。比如说在Java平台中，customer screen 对应的是 (JSF) Java Server Faces ,用 bean 组件来实现 customer delegate。用本地的Spring bean或者远程的EJB3 bean 来实现业务层中的customer object。上例中的数据访问可以用简单的POJP’s(Plain Old Java Objects)，或者可以用MyBatis，还可以用JDBC或者Hibernate 查询。Microsoft平台上，customer screen能用 .NET 库的ASP模块来访问业务层中的C#模块，用ADO来实现用户和订单数据的访问模块。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>分层架构是一个很可靠的架构模式。它适合大多数的应用。如果你不确定在项目中使用什么架构，分层架构是再好不过的了。然后，从架构的角度上来说，选择这个模式还要考虑很多的东西。</p>
<p>第一个要注意的就是 污水池反模式(architecture sinkhole anti-pattern)。 在这个模式中，请求流只是简单的穿过层次，不留一点云彩，或者说只留下一阵青烟。比如说界面层响应了一个获得数据的请求。响应层把这个请求传递给了业务层，业务层也只是传递了这个请求到持久层，持久层对数据库做简单的SQL查询获得用户的数据。这个数据按照原理返回，不会有任何的二次处理，返回到界面上。</p>
<p>每个分层架构或多或少都可能遇到这种场景。关键在于这样的请求有多少。80-20原则可以帮助你确定架构是否处于反污水模式。大概有百分之二十的请求仅仅是做简单的穿越，百分之八十的请求会做一些业务逻辑操作。然而，如果这个比例反过来，大部分的请求都是仅仅穿过层，不做逻辑操作。那么开放一些架构层会比较好。不过由于缺少了层次隔离，项目会变得难以控制。</p>
<h3 id="模式分析-1"><a href="#模式分析-1" class="headerlink" title="模式分析"></a>模式分析</h3><p>下面的的表里分析了分层架构的各个方面。</p>
<h5 id="整体灵活性"><a href="#整体灵活性" class="headerlink" title="整体灵活性"></a>整体灵活性</h5><p>评级:低<br> 分析:总体灵活性是响应环境变化的能力。尽管分层模式中的变化可以隔绝起来，想在这种架构中做一些也改变也是并且费时费力的。分层模式的笨重以及经常出现的组件之间的紧耦合是导致灵活性降低的原因。</p>
<h4 id="易于部署"><a href="#易于部署" class="headerlink" title="易于部署"></a>易于部署</h4><p>评级:低<br> 分析:这取决于你怎么发布这种模式，发布程序可能比较麻烦，尤其是很大的项目。一个组件的小小改动可能会影响到整个程序的发布(或者程序的大部分)。发布必须是按照计划，在非工作时间或者周末进行发布。因此。分层模式导致应用发布一点也不流畅，在发布上降低了灵活性。</p>
<h4 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h4><p>评级:高<br> 分析:因为组件都处于各自的层次中，可以模拟其他的层，或者说直接去掉层，所以分层模式很容易测试。开发者可以单独模拟一个展示组件，对业务组件进行隔绝测试。还可以模拟业务层来测试某个展示功能。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>评级:低<br> 分析:尽管某些分层架构的性能表现的确不错，但是这个模式的特点导致它无法带来高性能。因为一次业务请求要穿越所有的架构层，做了很多不必要的工作。</p>
<h4 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评级:低<br> 分析:由于这种模式以紧密耦合的趋势在发展，规模也比较大，用分层架构构建的程序都比较难以扩展。你可以把各个层分成单独的物理模块或者干脆把整个程序分成多个节点来扩展分层架构，但是总体的关系过于紧密，这样很难扩展。</p>
<h4 id="易开发性"><a href="#易开发性" class="headerlink" title="易开发性"></a>易开发性</h4><p>评级:容易<br> 分析:在开发难度上面，分层架构得到了比较高的分数。因为这种架构对大家来说很熟悉，不难实现。大部分公司在开发项目的都是通过层来区分技术的，这种模式对于大多数的商业项目开发来说都很合适。公司的组织架构和他们软件架构之间的联系被戏称为”Conway’s law”。你可以Google一下查查这个有趣的联系。</p>
<h2 id="第二章-事件驱动架构"><a href="#第二章-事件驱动架构" class="headerlink" title="第二章 事件驱动架构"></a>第二章 事件驱动架构</h2><blockquote>
<p>译者注：文章中 mediator 及 broker 的概念很容易混淆，在文章的结尾处译者对两者的区别（还有 proxy）进行了一定的阐述</p>
</blockquote>
<p>事件驱动架构模式是一种主流的异步分发事件架构模式，常用于设计高度可拓展的应用。当然了，它有很高的适应性，使得它在小型应用、大型应用、复杂应用中都能表现得很好。事件驱动架构模式由高度解耦、单一目的的事件处理组件构成，这些组件负责异步接收和处理事件。</p>
<p>事件驱动架构模式包含了两种主要的拓扑结构：**中介(mediator)<strong>拓扑结构和</strong>代理(broker)**拓扑结构。 mediator 拓扑结构通常在你需要在事件内使用一个核心中介分配、协调多个步骤间的关系、执行顺序时使用；而代理拓扑结构则在你想要不通过一个核心中介将多个事件串联在一起时使用。由于这两种结构在结构特征和实现策略上有很大的差别，所以如果你想要在你的应用中使用它们的话，一定要深入理解两者的技术实现细节，从而为你的实际使用场景选择最合理的结构。</p>
<h3 id="中介-Mediator-拓扑结构"><a href="#中介-Mediator-拓扑结构" class="headerlink" title="中介 ( Mediator )拓扑结构"></a>中介 ( Mediator )拓扑结构</h3><p>中介拓扑结构适合用于拥有多个步骤，并需要在处理事件时能通过某种程度的协调将事件分层的场景，举例来说吧：假设你现在需要进行股票交易，那你首先需要证券所批准你进行交易，然后检查进行这次交易是否违反了股票交易的某种规定，检查完成后将它交给一个经纪人，计算佣金，最后与经纪人确认交易。以上所有步骤都需要通过中介进行某种程度的分配和协调，以决定各个步骤的执行顺序，判断哪些步骤可以并行，哪些步骤可以串行。</p>
<p>在中介拓扑结构中主要有四种组件：事件队列（event queue）, 事件中介, 事件通道（event channel）, 和 事件处理器（event processor）。当事件流需要被处理，客户端将一个事件发送到某个事件队列中，由消息队列将其运输给事件中介进行处理和分发。事件中介接收到该消息后，并通过将额外的异步事件发送给事件通道，让事件通道执行该异步事件中的每一个步骤，使得事件中介能够对事件进行分配、协调。同时，又因为事件处理器是事件通道的监听器，所以事件通道对异步事件的处理会触发事件处理器的监听事件，使事件处理器能够接收来自事件中介的事件，执行事件中具体的业务逻辑，从而完成对传入事件的处理。事件驱动架构模式中的中介拓扑模式结构大体如下图：</p>
<p><img src="2-1.png" alt="2-1"></p>
<p>在事件驱动架构中拥有十几个，甚至几百个事件队列是很常见的情况，该模式并没有对事件队列的实现有明确的要求，这就意味着事件队列可以是消息队列，Web 服务端，或者其它类似的东西。</p>
<p>在事件驱动架构模式中主要有两种事件：初始事件和待处理事件。初始事件是中介所接收到的最原始的事件，没有经过其他组件的处理；而待处理事件是由事件中介生成，由事件处理器接收的组件，不能把待处理事件看作初始事件经过处理后得到的事件，两者是完全不同的概念。</p>
<p>事件中介负责分配、协调初始事件中的各个待执行步骤，事件中介需要为每一个初始事件中的步骤发送一个特定的待处理事件到事件通道中，触发事件处理器接收和处理该待处理事件。这里需要注意的是：事件 中介没有真正参与到对初始事件必须处理的业务逻辑的实现之中；相反，事件中介只是知道初始事件中有哪些步骤需要被处理。</p>
<p>事件中介通过事件通道将与初始事件每一个执行步骤相关联的特定待处理事件传递给事件处理器。尽管我们通常在待处理事件能被多个事件处理器处理时才会在中介拓扑结构中使用 消息主题，但事件通道仍可以是消息队列或 消息主题。（但需要注意的是，尽管在使用 消息主题 时待处理事件能被多个事件处理器处理，但由于接收到的待处理事件各异，所以对其处理的操作也各不相同）</p>
<p>为了能顺利处理待处理事件，事件处理器组件中包含了应用的业务逻辑。此外，事件处理器作为事件驱动架构中的组件，不依赖于其他组件，独立运作，高度解耦，在应用或系统中完成特定的任务。当事件处理器需要处理的事件从细粒度（例如：计算订单的营业税）变为粗粒度（例如：处理一项保险索赔事务），必须要注意的是：一般来说，每一个事件处理器组件都只完成一项唯一的业务工作，并且事件处理器在完成其特定的业务工作时不能依赖其他事件处理器。</p>
<p>虽然事件中介有许多方法可以实现，但作为一名架构工程师，你应该了解所有实现方式，以确保你能为你的实际需求选择了最合适的事件中介。</p>
<p>事件中介最简单、常见的实现就是使用开源框架，例如：Spring Integration，Apache Camel，或 Mule ESB。事件流在这些开源框架中通常用 Java 或 域特定语言（domain-specific language）。在调节过程和业务流程都很复杂的使用场景下，你可以使用业务流程执行语言（BPEL - business process execution language）结合类似开源框架 Apache ODE 的 BPEL 引擎进行开发。BPEL 是一种基于 XML 的服务编制编程语言，它为处理初始事件时需要描述的数据和步骤提供了描述。对每一个拥有复杂业务流程（包括与用户交互的执行步骤）的大型应用来说，你可以使用类似 jBPM 的业务处理管理系统（business process manager）实现事件中介。</p>
<p>如果你需要使用中介拓扑结构，那么理解你的需求，并为其匹配恰当的事件中介实现是构建事件驱动架构过程中至关重要的一环。使用开源框架去解决非常复杂的业务处理、管理、调节事件，注定会失败，因为开源框架只是用 BPM 的方式解决了一些简单的事件分发逻辑，比起你的业务逻辑，其中的事件分发逻辑简直是九牛一毛。</p>
<p>为了解释清楚中介拓扑结构是怎么运作的，我假设你在某家保险公司买了保险，成为了受保人，然后你打算搬家。在这种情况下，初始事件就是重定位事件，或者其他类似的事件。与重定位事件相关的处理步骤就像下图展示的那样，处于事件中介之中。对每一个初始事件的传入，事件中介都会创建一个待处理事件（例如：改变地址，重新计算保险报价，等等……），并将它发送给事件通道，等待发出响应的事件处理器处理待处理事件（例如：客户改变地址的操作流程、报价计算流程，等等……）。直到初始事件中的每一个需要处理的步骤完成了，这项处理才会继续（例如：把所有手续都完成之后，保险公司才会帮你改变地址）。事件中介中，重新报价和更新理赔步骤上面的直线表示这些步骤可以并行处理。</p>
<p><img src="2-2.png" alt="2-1"></p>
<h3 id="代理-Broker-拓扑结构"><a href="#代理-Broker-拓扑结构" class="headerlink" title="代理 (Broker) 拓扑结构"></a>代理 (Broker) 拓扑结构</h3><p>代理拓扑结构与中介拓扑结构不同之处在于：代理拓扑结构中没有核心的事件中介；相反，事件流在代理拓扑结构中通过一个轻量的消息代理（例如：ActiveMQ, HornetQ，等等……）将消息串联成链状，分发至事件处理器组件中进行处理。代理扑结构适用的使用场景大致上具有以下特征：你的事件处理流相对来说比较简单，而且你不想（不需要）使用核心的事件分配、调节机制以提高你处理事件的效率。</p>
<p>在代理拓扑结构中主要包括两种组件：代理和事件处理器。代理可被集中或相互关联在一起使用，此外，代理中还可以包含所有事件流中使用的事件通道。</p>
<p>存在于代理组件中的事件通道可以是消息队列，消息主题,或者是两者的组合。</p>
<p>代理拓扑结构大致如下图，如你所见，在这其中没有一个核心的事件中介组件控制和分发初始事件；相反，每一个事件处理器只负责处理一个事件，并向外发送一个事件，以标明其刚刚执行的动作。例如，假设存在一个事件处理器用于平衡证券交易，那么事件处理器可能会接受一个拆分股票的初始事件，为了处理这项初始事件，事件处理器则需要重新平衡股票的投资金额，而这个重新平衡的事件将由另一个事件处理器接收、处理。在这其中有一个细节需要注意：处理初始事件后，由事件处理器发出的事件不被其他事件处理器接收、处理的情况时常会发生，尤其是你在为应用添加功能和进行功能拓展时，这种情况更为常见。</p>
<p><img src="2-3.png" alt="2-3"></p>
<p>为了阐明代理拓扑结构的运行机制，我会用一个与讲解中介拓扑结构时类似的例子（受保人旅行的例子）进行解释。因为在代理拓扑结构中没有核心事件中介接收初始事件，那么事件将由客户处理组件直接接收，改变客户的地址，并发出一个事件告知系统客户的地址被其进行了改变（例如：改变地址的事件）。在这个例子中：有两个事件处理器会与改变地址的事件产生关联：报价处理和索赔处理。报价事件处理器将根据受保人的新地址重新计算保险的金额，并发出事件告知系统该受保人的保险金额被其改变。而索赔事件处理器将接受到相同的改变地址事件，不同的是，它将更新保险的赔偿金额，并发出一个更新索赔金额事件告知系统该受保人的赔偿金额被其改变。当这些新的事件被其他事件处理器接收、处理，使事件链一环扣一环地交由系统处理，直到事件链上的所有事件都被处理完，初始事件的处理才算完成。</p>
<p><img src="2-4.png" alt="2-4"></p>
<p>如上图所示，代理拓扑结构的设计思想就是将对事件流的处理转换为对事件链的业务功能处理，把代理拓扑结构看作是接力比赛是最好的理解方式：在一场4*100的接力比赛中，每一位运动员都需要拿着一根接力棒跑100米，运动员跑完自己的100米后需要将接力棒传递给下一位运动员，直到最后一位运动员拿着接力棒跑过终点线，整场接力比赛才算结束。根据这样的逻辑我们还可以知道：在代理拓扑结构中，一旦某个事件处理器将事件传递给另一个事件处理器，那么这个事件处理器不会与该事件的后续处理产生任何联系。</p>
<h3 id="顾虑"><a href="#顾虑" class="headerlink" title="顾虑"></a>顾虑</h3><p>实现事件驱动架构模式相对于实现其他架构模式会更困难一些，因为它通过异步处理进行事件分发。当你需要在你的应用中使用这种架构模式，你必须处理各种由事件分发处理带来的问题，例如：远程操作功能的可用性，缺少权限，以及在代理或中介中处理事件失败时，用于处理这种情况的重连逻辑。如果你不能很好地解决这些问题，那你的应用一定会出现各种 Bug，让开发团队痛苦不已。</p>
<p>在选择事件驱动架构时还有一点需要注意：在处理单个业务逻辑时，这种架构模式不能处理细粒度的事务。因为事件处理器都高度解耦、并且广泛分布，这使得在这些事件处理器中维持一个业务单元变得非常困难。因此，当你使用这种架构模式架构你的应用时，你必须不断地考虑哪些事件能单独被处理，哪些不能，并为此设计相应事件处理器的处理粒度。如果你发现你需要将一个业务单元切割成许多子单元，并一一匹配相应的事件处理器，那你就要为此进行代码设计；如果你发现你用多个不同的事件处理器处理的哪些业务其实是可以合并到一个业务事件之中的，那么这种模式可能并不适合你的应用，又或者是你的设计出了问题。</p>
<p>使用事件驱动架构模式最困难的地方就在于架构的创建、维护、以及对事件处理器的管理。通常每一个事件都拥有其指定的事件处理协议（例如：传递给事件处理器的数据类型、数据格式），这就使得设下标准的数据格式成为使用事件驱动架构模式中至关重要的一环（例如：XML，JSON，Java 对象，等等……），并在架构创建之初就为这些数据格式授权，以便处理。</p>
<h3 id="模式分析-2"><a href="#模式分析-2" class="headerlink" title="模式分析"></a>模式分析</h3><p>下面是基于对常见的架构模式特征进行评价的标准，对事件驱动架构模式所作的实际分析，评价是以常见的架构模式的相似实现作为标准进行的，如果你想知道进行对比的其他架构模式对应的特征，可以结尾处查看  <a href="#appendix">附录A</a> 的汇总表。</p>
<h4 id="整体灵活性-1"><a href="#整体灵活性-1" class="headerlink" title="整体灵活性"></a>整体灵活性</h4><p>评价：高<br> 分析：整体灵活性用于评价架构能否在不断改变的使用场景下快速响应，因为事件处理器组件使用目的单一、高度解耦、与其他事件处理器组件相互独立，不相关联，那么发生的改变对一个或多个事件处理器来说普遍都是独立的，使得对改变的反馈非常迅速，不需要依赖其他事件处理器的响应作出处理。</p>
<h4 id="易于部署-1"><a href="#易于部署-1" class="headerlink" title="易于部署"></a>易于部署</h4><p>评价：高<br> 分析：总的来看，事件驱动架构模式由于其高度解耦的事件处理器组件的存在，对事件的部署相对来说比较容易，而使用代理拓扑结构比使用中介拓扑结构进行事件调度会更容易一些，主要是因为在 中介拓扑结构中事件处理器与事件中介紧密地耦合在一起：事件处理器中发生改变后，事件中介也随之改变，如果我们需要改变某个被处理的事件，那么我们需要同时调度事件处理器和事件中介。</p>
<h4 id="可测试性-1"><a href="#可测试性-1" class="headerlink" title="可测试性"></a>可测试性</h4><p>评价：低<br> 分析：虽然在事件驱动架构模式中进行单元测试并不困难，但如果我们要进行单元测试，我们就需要某种特定的测试客户端或者是测试工具产生事件，为单元测试提供初始值。此外，由于事件驱动架构模式是异步进行事件分发的，其异步处理的特性也为单元测试带来了一定的困难。</p>
<h4 id="Performance-性能"><a href="#Performance-性能" class="headerlink" title="Performance 性能"></a>Performance 性能</h4><p>评价：高<br> 分析：对消息传递的架构可能会让设计出来的事件驱动架构的表现不如我们的期望，但通常来说，该模式都能通过其异步处理的特性展示优秀的性能表现；换句话来说，高度解耦，异步并行操作大大减少了传递消息过程中带来的时间开销。</p>
<h4 id="伸缩性-1"><a href="#伸缩性-1" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评价：高<br> 分析：事件驱动架构中的高度解耦、相互独立的事件处理器组件的存在，使得可拓展性成为该架构与生俱来的优点。架构的这些特定使得事件处理器能够进行细粒度的拓展，使得每一个事件处理器都能单独被拓展，而不影响其他事件处理器。</p>
<h4 id="易于开发"><a href="#易于开发" class="headerlink" title="易于开发"></a>易于开发</h4><p>评价：低<br> 分析：由于使用事件驱动架构进行开发需要考虑其异步处理机制、协议创建流程，并且开发者需要用代码为事件处理器和操作失败的代理提供优秀的错误控制环境，无疑使得用事件驱动架构进行开发会比使用其他架构进行开发要困难一些。</p>
<h3 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h3><p>读完整篇文章，我相信大家对 mediator 与 broker 这两个概念有一个大致的印象，但就两者的译文来看，中介和代理似乎没什么区别，尤其是了解 proxy 的读者会更加困惑，这三者之间到底是什么关系？它们的概念是互通的吗？为了解决这种混淆，译者将在此阐述三者间的区别：</p>
<p>假如现在我有一个事件&#x2F;事件流需要被处理，那么使用 mediator、broker、proxy 处理事件的区别在哪里呢？</p>
<ul>
<li>如果我们使用 mediator，那就意味着我将把事件流交给 mediator，mediator 会帮我把事件分解为多个步骤，并分析其中的执行逻辑，调整和分发事件（例如判断哪些事件可以并行，哪些事件可以串行），然后根据 mediator 分解、调节的结果去执行事件中的每一个步骤，把所有步骤完成后，就能把需要处理的事件处理好。</li>
<li>如果我们使用 broker，那就意味着我将把事件交给 broker，broker 获得事件后会把事件发出去（在本文中为：通知架构中所有可用的事件处理器），事件处理器们接收到事件以后，判断处理这个事件是否为自己的职责之一，如果不是则无视，与自己有关则把需要完成的工作完成，完成后如果事件还有后续需要处理的事件，则通过 broker 再次发布，再由相关的事件处理器接收、处理。以这样的方式将事件不断分解，沿着事件链一级一级地向下处理子事件，直到事件链中的所有事件被完成，我的事件也就处理好了。</li>
<li>如果我们使用 proxy，那就意味着我自己对需要处理的事件进行了分解，然后把不同的子事件一一委托给不同的 proxy，由被委托的 proxy 帮我完成子事件，从而完成我要做的事件。</li>
</ul>
<h2 id="第三章-微内核架构"><a href="#第三章-微内核架构" class="headerlink" title="第三章 微内核架构"></a>第三章 微内核架构</h2><p>微内核架构模式(也称为插件化应用架构)对于基于产品的应用程序来说是一个很自然的选择。基于产品的应用是指一个经过打包的、可以通过版本下载的一个典型的第三方产品。然而，很多公司也会开发和发布他们的内部商业软件，完整的版本号、发布日志和可插拔的新特性，这些就非常符合微内核架构的思想。微内核架构模式可以通过插件的形式添加额外的特性到核心系统中，这提供了很好的扩展性，也使得新特性与核心系统隔离开来。( 译者注: 比如，著名的Eclipse IDE就是基于插件化开发的，eclipse核心更像是一个微内核，或者我们可把它叫做开放平台，其他的功能通过安装插件的形式添加到eclipse中。 )</p>
<h3 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h3><p>微内核架构主要需要考虑两个方面: 核心系统和插件模块。应用逻辑被划分为独立的插件模块和核心系统，这样就提供良好的可扩展性、灵活性，应用的新特性和自定义处理逻辑也会被隔离。图3-1演示了基本的微内核架构。</p>
<p>微内核架构的核心系统一般情况下只包含一个能够使系统运作起来的最小化模块。很多操作系统的实现就是使用微内核架构，因此这也是该架构名字的由来。从商业应用的角度看，核心系统通常是为特定的使用场景、规则、或者复杂条件处理定义了通用的业务逻辑，而插件模块根据这些规则实现了具体的业务逻辑。</p>
<p><img src="3-1.png" alt="3-1"></p>
<p>插件模块是一个包含专业处理、额外特性的独立组件，自定义代码意味着增加或者扩展核心系统以达到产生附加的业务逻辑的能力。通常，插件模块之间应该是没有任何依赖性的，但是你也可以设计一个需要依赖另一个插件的插件。但无论如何，使得插件之间可以通信的同时避免插件之间产生依赖又是一个特别重要的问题。</p>
<p>核心系统需要了解插件模块的可用性以及如何获取到它们。一个通用的实现方法是通过一组插件注册表。这个插件注册表含有每个插件模块的信息，包括它的名字、数据规约和远程访问协议(取决于插件如何与核心系统建立连接)。例如，一个税务软件的用于标识高风险的税务审计插件可能会有一个含有插件名(比如AuditChecker)的注册入口，数据规约(输入数据、输出数据)和规约格式( 比如xml )。如果这个插件是通过SOAP服务访问，那么它可能会包含一个WSDL (Web Services Definition Language).</p>
<p>插件模块可以通过多种方式连接到核心系统，包括OSGi ( open service gateway initiative )、消息机制、web服务或者直接点对点的绑定 ( 比如对象实例化，即依赖注入 )。你使用的连接类型取决于你构建的应用类型和你的特殊需求（比如单机部署还是分布式部署）。微内核架构本身没有指定任何的实现方式，唯一的规定就是插件模块之间不要产生依赖。</p>
<p>插件和核心系统的通信规范包含标准规范和自定义规范。自定义规范典型的使用场景是插件组件是被第三方构建的。在这种情况下，通常是在第三方插件规约和你的标准规范创建一个Adapter来使核心系统根本不需要知道每个插件的具体细节。当创建标准规范 ( 通常是通过XML或者Java Map )时，从一开始就创建一个版本策略是非常重要的。</p>
<h3 id="架构示例"><a href="#架构示例" class="headerlink" title="架构示例"></a>架构示例</h3><p>也许微内核架构的最好示例就是大家熟知的Eclipse IDE了。下载最基本的Eclipse后，它只能提供一个编辑器。然后，一旦你开始添加插件，它就变成一个高度可定制化和非常有用的产品（译者注 : 更多内容大家可以参考 <a target="_blank" rel="noopener" href="http://www.ituring.com.cn/article/6817">开源软件架构 卷1：第6章 Eclipse之一</a> ）。浏览器是另一个使用微内核架构的产品示例，它由一个查看器和其他扩展的插件组成。</p>
<p>基于微内核架构的示例数不胜数，但是大型的商业应用呢？微内核应用架构也适用于这些情形。为了阐述这个观点，让我们来看看另一个保险公司的示例，但是这次的示例会涉及保险赔偿处理。</p>
<p>赔偿处理是一个非常复杂的过程。每个州都有不同的关于保险赔偿的规则和条文。例如一些州允许在你的挡风玻璃被石头砸碎时免费进行替换，但是一些州则不是这样。因为大家的标准都不一样，因此赔偿标准几乎可以是无限的。</p>
<p>有很多保险赔偿应用运用大型和复杂的规则处理引擎来处理不同规则带来的复杂性。然而，可能会因为某条规则的改变而引起其他规则的改变而使得这些规则处理引擎变成一个大泥球，或者使简单需求变更会需要一个很大的分析师、工程师、测试工程师来进行处理。使用微内核架构能够很好的解决这个问题，核心系统只知道根据赔偿规则处理，但这个赔偿规则是抽象的，系统将赔偿规则作为一个插件规范，具体的规则有对应的实现，然后注入到系统中即可。</p>
<p>图3-2中的一堆文件夹代表了赔偿处理核心系统。它包含一些处理保险赔偿的基本业务逻辑。每一个插件模块包含每个州的具体赔偿规则。在这个例子中，插件模块通过自定义源代码实现或者分离规则引起实例。不管具体实现如何，关键就在于赔偿规则和处理都从核心系统中分离，而这些规则和处理过程都可以被动态地添加、移除，而这些改变对于核心系统和其他插件只有很小的影响或者根本不产生影响。</p>
<p><img src="3-2.png" alt="3-2"></p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>对于微内核架构来说一个很重要的一点就是它能够被嵌入或者说作为另一种架构的一部分。例如，如果这个架构解决的是一个你应用中易变领域的特定的问题 ( 译者注 : 即插件化能够解决你应用中的某个特定模块的架构问题 )，你可能会发现你不能在整个应用中使用这种架构。在这种情况下，你可以将微内核架构嵌入到另一个架构模式中 ( 比如分层架构 )。同样的，在上一章节中描述的事件驱动架构中的事件处理器组件也可以使用微内核架构。</p>
<p>微内核架构对渐进式设计和增量开发提供了非常好的支持。你可以先构建一个单纯的核心系统，随着应用的演进，系统会逐渐添加越来越多的特性和功能，而这并不会引起核心系统的重大变化。</p>
<p>对基于产品的应用来说，微内核架构应该是你的第一选择。特别是那些你会在后续开发中发布附加特性和控制哪些用户能够获取哪些特性的应用。如果你在后续开发中发现这个架构不能满足你的需求了，你能够根据你的特殊需求将你的应用重构为另一个更好的架构。</p>
<h3 id="模式分析-3"><a href="#模式分析-3" class="headerlink" title="模式分析"></a>模式分析</h3><p>下面的表格中包含了微内核架构每个特性的评级和分析。以微内核架构的最经典的实现方式的自然趋势为依据对每个特性进行评级。关于微内核架构与其他模式的相关性比较请参考附录A。</p>
<h4 id="整体灵活性-2"><a href="#整体灵活性-2" class="headerlink" title="整体灵活性"></a>整体灵活性</h4><p>评级 : 高<br> 分析 : 整体灵活性是指能够快速适应不断变化的环境的能力。通过插件模块的松耦合实现，可以将变化隔离起来，并且快速满足需求。通常，微内核架构的核心系统很快趋于稳定，这样系统就变得很健壮，随着时间的推移它也不会发生多大改变。</p>
<h4 id="易于部署-2"><a href="#易于部署-2" class="headerlink" title="易于部署"></a>易于部署</h4><p>评级 : 高<br> 分析 : 根据实现方式，插件模块能够在运行时被动态地添加到核心系统中 （ 比如，热部署 ）,把停机时间减到最小。</p>
<h4 id="可测试性-2"><a href="#可测试性-2" class="headerlink" title="可测试性"></a>可测试性</h4><p>评级 : 高<br> 分析 : 插件模块能够被独立的测试，能够非常简单地被核心系统模拟出来进行演示，或者在对核心系统很小影响甚至没有影响的情况下对一个特定的特性进行原型展示。</p>
<h4 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h4><p>评级 : 高<br> 分析 : 使用微内核架构不会自然而然地使你的应用变得高性能。通常，很多使用微内核架构的应用运行得很好，因为你能定制和简化应用程序，使它只包含那些你需要的功能模块。JBoss应用服务器就是这方面的优秀示例: 依赖于它的插件化架构，你可以只加载你需要的功能模块，移除那些消耗资源但没有使用的功能特性，比如远程访问，消息传递，消耗内存、CPU的缓存，以及线程，从而减小应用服务器的资源消耗。</p>
<h4 id="伸缩性-2"><a href="#伸缩性-2" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评级 : 低<br> 分析 : 因为微内核架构的实现是基于产品的，它通常都比较小。它们以独立单元的形式实现，因此没有太高的伸缩性。此时，伸缩性就取决于你的插件模块，有时你可以在插件级别上提供可伸缩性，但是总的来说这个架构并不是以构建高度伸缩性的应用而著称的。</p>
<h4 id="易于开发-1"><a href="#易于开发-1" class="headerlink" title="易于开发"></a>易于开发</h4><p>评级 : 低<br> 分析 : 微内核架构需要考虑设计和规约管理，使它不会很难实现。规约的版本控制，内部的插件注册，插件粒度，丰富的插件连接的方式等是涉及到这个架构模式实现复杂度的重要因素。</p>
<h2 id="第四章-微服务架构"><a href="#第四章-微服务架构" class="headerlink" title="第四章 微服务架构"></a>第四章 微服务架构</h2><p>微服务架构模式作为替代单体应用和面向服务架构的一个可行的选择，在业内迅速取得进展。由于这个架构模式仍然在不断的发展中，在业界存在很多困惑——这种模式是关于什么的？它是如何实现的？本报告的这部分将为你提供关键概念和必要的基础知识来理解这一重要架构模式的好处(和取舍)，以此来判断这种架构是否适合你的应用。</p>
<h3 id="模式描述-1"><a href="#模式描述-1" class="headerlink" title="模式描述"></a>模式描述</h3><p>不管你选择哪种拓扑或实现风格,有几种常见的核心概念适用于一般架构模式。第一个概念是<em>单独部署单元</em>。如图4-1所示，微服务架构的每个组件都作为一个独立单元进行部署，让每个单元可以通过有效、简化的传输管道进行通信，同时它还有很强的扩展性，应用和组件之间高度解耦，使得部署更为简单。</p>
<p>也许要理解这种模式，最重要的概念就是服务组件（service component）。不要考虑微服务架构内部的服务，而最好是考虑服务组件，从粒度上讲它可以小到单一的模块，或者大至一个应用程序。服务组件包含一个或多个模块（如Java类），这些模块可以提供一个单一功能（如，为特定的城市或城镇提供天气情况），或也可以作为一个大型商业应用的一个独立部分（如，股票交易布局或测定汽车保险的费率）。在微服务架构中，正确设计服务组件的粒度是一个很大的挑战。在接下来的服务组件部分对这一挑战进行了详细的讨论。</p>
<p><img src="4-1.png" alt="4-1"></p>
<p>微服务架构模式的另一个关键概念是它是一个<em>分布式</em>的架构，这意味着架构内部的所有组件之间是完全解耦的，并通过某种远程访问协议（如， JMS, AMQP, REST, SOAP, RMI等）进行访问。这种架构的分布式特性是它实现一些优越的可扩展性和部署特性的关键所在。</p>
<p>微服务架构另一个令人兴奋的特性是它是由其他常见架构模式存在的问题演化来的，而不是作为一个解决方案被创造出来等待问题出现。微服务架构的演化有两个主要来源：使用分层架构模式的单体应用和使用面向服务架构的分布式应用。</p>
<p>由单体应用( 一个应用就是一个整体 )到微服务的发展过程主要是由持续交付开发促成的。从开发到生产的持续部署管道概念,简化了应用程序的部署。单体应用通常是由紧耦合的组件组成，这些组件同时又是另一个单一可部署单元的一部分，这使得它繁琐，难以改变、测试和部署应用（因此常见的“月度部署”周期出现并通常发生在大型IT商店项目）。这些因素通常会导致应用变得脆弱以至于每次有一点新功能部署后应用就不能运行。微服务架构模式通过将应用分隔成多个可部署的单元（服务组件）的方法来解决这一问题，这些服务组件可以独立于其他服务组件进行单独开发、测试和部署。</p>
<p>另一个导致微服务架构模式产生的演化过程是由面向服务架构模式（SOA）应用程序存在的问题引起的。虽然SOA模式非常强大，提供了无与伦比的抽象级别、异构连接、服务编排，并保证通过IT能力调整业务目标，但它仍然是复杂的,昂贵的,普遍存在，它很难理解和实现，对大多数应用程序来说过犹不及。微服务架构通过简化服务概念，消除编排需求、简化服务组件连接和访问来解决复杂度问题。</p>
<h3 id="模式拓扑"><a href="#模式拓扑" class="headerlink" title="模式拓扑"></a>模式拓扑</h3><p>虽然有很多方法来实现微服务架构模式,但三个主要的拓扑结构脱颖而出，最常见和流行的有:基于REST API的拓扑结构,基于REST的应用拓扑结构和集中式消息拓扑结构。</p>
<p>基于REST的API拓扑适用于网站，通过某些API对外提供小型的、自包含的服务。这种拓扑结构,如图4 - 2所示,由粒度非常细的服务组件（因此得名微服务）组成，这些服务组件包含一个或两个模块并独立于其他服务来执行特定业务功能。在这种拓结构扑中,这些细粒度的服务组件通常被REST-based的接口访问，而这个接口是通过一个单独部署的web API层实现的。此种拓扑的例子包含一些常见的专用的、基于云的RESTful web service，大型网站像Yahoo, Google, and Amazon都在使用。</p>
<p><img src="4-2.png" alt="4-2"></p>
<p>基于REST的应用拓扑结构与基于REST API的不同，它通过传统的基于web的或胖客户端业务应用来接收客户端请求，而不是通过一个简单的API层。如图4-3所示，应用的用户接口层（user interface layer）是一个web应用，可以通过简单的REST-based接口访问单独部署的服务组件（业务功能）。该拓扑结构中的服务组件与API-REST-based拓扑结构中的不同，这些服务组件往往会更大、粒度更粗、代表整个业务应用程序的一小部分，而不是细粒度的、单一操作的服务。这种拓扑结构常见于中小型企业等复程度相对较低的应用程序。</p>
<p><img src="4-3.png" alt="4-3"></p>
<p>微服务架构模式中另一个常见的方法是集中式消息拓扑。该拓扑（如图4-4所示）与前面提到的基于REST的应用拓扑类似，不同的是，application REST- based拓扑结构使用REST进行远程访问，而该拓扑结构则使用一个轻量级的集中式消息代理（如，ActiveMQ, HornetQ等等）。不要将该拓扑与面向服务架构模式混淆或将其当做SOA简化版（“SOA-Lite”），这点是极其重要的。该拓扑中的轻量级消息代理（Lightweight Message Broker）不执行任何编排,转换,或复杂的路由;相反,它只是一个轻量级访问远程服务组件的传输工具。</p>
<p>集中式消息拓扑结构通常应用在较大的业务应用程序中，或对于某些对传输层到用户接口层或者到服务组件层有较复杂的控制逻辑的应用程序中。该拓扑较之先前讨论的简单基于REST的拓扑结构，其好处是有先进的排队机制、异步消息传递、监控、错误处理和更好的负载均衡和可扩展性。与集中式代理相关的单点故障和架构瓶颈问题已通过代理集群和代理联盟（将一个代理实例为分多个代理实例，把基于系统功能区域的吞吐量负载划分开处理）解决。</p>
<p><img src="4-4.png" alt="4-4"></p>
<h3 id="避免依赖和编排"><a href="#避免依赖和编排" class="headerlink" title="避免依赖和编排"></a>避免依赖和编排</h3><p>微服务架构模式的主要挑战之一就是决定服务组件的粒度级别。如果服务组件粒度过粗，那你可能不会意识到这个架构模式带来的好处（部署、可扩展性、可测试性和松耦合），然而,服务组件粒度过细将导致服务编制要求,这会很快导致将微服务架构模式变成一个复杂、容易混淆、代价昂贵并易于出错的重量级面向服务架构。</p>
<p>如果你发现需要从应用内部的用户接口或API层编排服务组件，那么很有可能你服务组件的粒度太细了。如果你发现你需要在服务组件之间执行服务间通信来处理单个请求,那么很有可能要么是你服务组件的粒度太细了，要么是没有从业务功能角度正确划分服务组件。</p>
<p>服务间通信，可能导致组件之间产生耦合，但可以通过共享数据库进行处理。例如，若一个服务组件处理网络订单而需要用户信息时，它可以去数据库检索必要的数据，而不是调用客户服务组件的功能。</p>
<p>共享数据库可以处理信息需求，但是共享功能呢？如果一个服务组件需要的功能包含在另一个服务组件内，或是一个公共的功能,那么有时你可以将服务组件的共享功能复制一份（因此违反了DRY规则：don’t repeat yourself）。为了保持服务组件独立和部署分离，微服务架构模式实现中会存在一小部分由重复的业务逻辑而造成的冗余，这在大多数业务应用程序中是一个相当常见的问题。小工具类可能属于这一类重复的代码。</p>
<p>如果你发现就算不考虑服务组件粒度的级别，你仍不能避免服务组件编排,这是一个好迹象,可能此架构模式不适用于你的应用。由于这种模式的分布式特性，很难维护服务组件之间的单一工作事务单元。这种做法需要某种事务补偿框架回滚事务,这对此相对简单而优雅的架构模式来说，显著增加了复杂性。</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>微服务架构模式解决了很多单体应用和面向服务架构应用存在的问题。由于主要应用组件被分成更小的,单独部署单元,使用微服务架构模式构建的应用程序通常更健壮,并提供更好的可扩展性,支持持续交付也更容易。</p>
<p>该模式的另一个优点是,它提供了实时生产部署能力，从而大大减少了传统的月度或周末“大爆炸”生产部署的需求。因为变化通常被隔离成特定的服务组件，只有变化的服务组件才需要部署。如果你的服务组件只有一个实例，你可以在用户界面程序编写专门的代码用于检测一个活跃的热部署,一旦检测到就将用户重定向到一个错误页面或等待页面。你也可以在实时部署期间，将服务组件的多个实例进行交换，允许应用程序在部署期间保持持续可用性（分层架构模式很难做到这点）。</p>
<p>最后一个要重视的考虑是，由于微服务架构模式是分布式的架构，他与事件驱动架构模式具有一些共同的复杂的问题，包括约定的创建、维护，和管理，远程系统的可用性，远程访问身份验证和授权。</p>
<h3 id="模式分析-4"><a href="#模式分析-4" class="headerlink" title="模式分析"></a>模式分析</h3><p>下面这个表中包含了微服务架构模式的特点分析和评级，每个特性的评级是基于自然趋势，基于典型模式实现的能力特性,以及该模式是以什么闻名的。本报告中该模式与其他模式的并排比较，请参考报告最后的附件A。</p>
<h4 id="整体灵活性-3"><a href="#整体灵活性-3" class="headerlink" title="整体灵活性"></a>整体灵活性</h4><p>评级：高<br> 分析：整体的灵活性是能够快速响应不断变化的环境。由于单独部署单元的概念,变化通常被隔离成单独的服务组件,使得部署变得快而简单。同时，使用这种模式构建的应用往往是松耦合的，也有助于促进改变。</p>
<h4 id="易于部署-3"><a href="#易于部署-3" class="headerlink" title="易于部署"></a>易于部署</h4><p>评级：高<br> 分析：整体来讲，由于该模式的解耦特性和事件处理组件使得部署变得相对简单。broker拓扑往往比mediator拓扑更易于部署，主要是因为event-mediator组件与事件处理器是紧耦合的，事件处理器组件有一个变化可能导致event mediator跟着变化，有任何变化两者都需要部署。</p>
<h4 id="可测试性-3"><a href="#可测试性-3" class="headerlink" title="可测试性"></a>可测试性</h4><p>评级：高<br> 分析：由于业务功能被分离成独立的应用模块,可以在局部范围内进行测试，这样测试工作就更有针对性。对一个特定的服务组件进行回归测试比对整个单体应用程序进行回归测试更简单、更可行。而且,由于这种模式的服务组件是松散耦合的，从开发角度来看，由一个变化导致应用其他部分也跟着变化的几率很小，并能减小由于一个微小的变化而不得不对整个应用程序进行测试的负担。</p>
<h4 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h4><p>评级：低<br> 分析：虽然你可以从实现该模式来创建应用程序并可以很好的运行，整体来说，由于微服务架构模式的分布式特性，并不适用于高性能的应用程序。</p>
<h4 id="伸缩性-3"><a href="#伸缩性-3" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评级：高<br> 分析：由于应用程序被分为单独的部署单元,每个服务组件可以单独扩展，并允许对应用程序进行扩展调整。例如，股票交易的管理员功能区域可能不需要扩展，因为使用该功能的用户很少，但是交易布局服务组件可能需要扩展，因为大多数交易应用程序需要具备处理高吞吐量的功能。</p>
<h4 id="易于开发-2"><a href="#易于开发-2" class="headerlink" title="易于开发"></a>易于开发</h4><p>评级：高<br> 分析：由于功能被分隔成不同的服务组件，由于开发范围更小且被隔离，开发变得更简单。程序员在一个服务组件做出一个变化影响其他服务组件的几率是很小的，从而减少开发人员或开发团队之间的协调。</p>
<h2 id="第五章-基于空间的架构"><a href="#第五章-基于空间的架构" class="headerlink" title="第五章 基于空间的架构"></a>第五章 基于空间的架构</h2><p>大多数基于网站的商务应用都遵循相同的请求流程：一个请求从浏览器发到web服务器，然后到应用服务器，然后到数据库服务器。虽然这个模式在用户数不大的时候工作良好，但随着用户负载的增加,瓶颈会开始出现，首先出现在web服务器层，然后应用服务器层，最后数据库服务器层。通常的解决办法就是<strong>向外扩展</strong>，也就是增加服务器数量。这个方法相对来说简单和廉价，并能够解决问题。然而，对于大多数高访问量的情况，它只不过是把web服务器的问题移到了应用服务器。而扩展应用服务器会更复杂，而且成本更高，并且又只是把问题移动到了数据库服务器，那会更复杂，更贵。就算你能扩展数据库服务器，你最终会陷入一个金字塔式的情形，在金字塔最下面是web服务器，它会出现最多的问题，但也最好伸缩。金字塔顶部是数据库服务器，问题不多，但最难伸缩。</p>
<p>在一个高并发大容量的应用中，数据库通常是决定应用能够支持多少用户同时在线的关键因素。虽然各种缓存技术和数据库伸缩产品都在帮助解决这个问题，但数据库难以伸缩的现实并没有改变。</p>
<p>基于空间的架构模型是专门为了<strong>解决伸缩性和并发问题</strong>而设计的。它对于用户数量不可预测且数量级经常变化的情况同样适用。在架构级别来解决这个伸缩性问题通常是比增加服务器数量或者提高缓存技术更好的解决办法。</p>
<h3 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h3><p>基于空间的模型（有时也称为云架构模型）旨在减少限制应用伸缩的因素。模型的名字来源于分布式共享内存中的 tuple space（数组空间）概念。高伸缩性是通过去除中心数据库的限制，并使用从内存中复制的数据框架来获得的。保存在内存的应用数据被复制给所有运行的进程。进程可以动态的随着用户数量增减而启动或结束，以此来解决伸缩性问题。这样因为没有了中心数据库，数据库瓶颈就此解决，此后可以近乎无限制的扩展了。</p>
<p>大多数使用这个模型的应用都是标准的网站，它们接受来自浏览器的请求并进行相关操作。竞价拍卖网站是一个很好的例子 ( 12306更是一个典型的示例 )。网站不停的接受来自浏览器的报价。应用收到对某一商品的报价，记录下报价和时间，并且更新对该商品的报价，将信息返回给浏览器。</p>
<p>这个架构中有两个主要的模块：<strong>处理单元</strong> 和 <strong>虚拟化中间件</strong>。下图展示了这个架构和里面的主要模块。</p>
<p><img src="5-1.png" alt="5-1"></p>
<p>处理单元包含了应用模块（或者部分的应用模块）。具体来说就是包含了web组件以及后台业务逻辑。处理单元的内容根据应用的类型而异——小型的web应用可能会部署到单一的处理单元，而大型一些的应用会将应用的不同功能模块部署到不同的处理单元中。典型的处理单元包括应用模块，以及保存在内存的数据框架和为应用失败时准备的异步数据持久化模块。它还包括复制引擎，使得虚拟化中间件可以将处理单元修改的数据复制到其他活动的处理单元。</p>
<p>虚拟化中间件负责保护自身以及通信。它包含用于数据同步和处理请求的模块，以及通信框架，数据框架，处理框架和部署管理器。这些在下文中即将介绍的部分，可以自定义编写或者购买第三方产品来实现。</p>
<h3 id="组件间合作"><a href="#组件间合作" class="headerlink" title="组件间合作"></a>组件间合作</h3><p>基于空间的架构的魔力就在虚拟化中间件，以及各个处理单元中的内存中数据框架。下图展示了包含着应用模块、内存中数据框架、处理异步数据恢复的组件和复制引擎的处理单元架构。</p>
<p>虚拟化中间件本质上是架构的控制器，它管理请求，会话，数据复制，分布式的请求处理和处理单元的部署。虚拟化中间件有四个架构组件：通信框架，数据框架，处理框架和部署管理器。</p>
<p><img src="5-2.png" alt="5-2"></p>
<h4 id="通信框架"><a href="#通信框架" class="headerlink" title="通信框架"></a>通信框架</h4><p>通信框架管理输入请求和会话信息。当有请求进入虚拟化中间件，通信框架就决定有哪个处理单元可用，并将请求传递给这个处理单元。通信框架的复杂程度可以从简单的round robin算法到更复杂的用于监控哪个请求正在被哪个处理单元处理的next-available算法。</p>
<p><img src="5-3.png" alt="5-3"></p>
<h4 id="数据框架"><a href="#数据框架" class="headerlink" title="数据框架"></a>数据框架</h4><p>数据框架可能是这个架构中最重要和关键的组件。它与各个处理单元的数据复制引擎交互，在数据更新时来管理数据复制功能。由于通信框架可以将请求传递给任何可用的处理单元，所以每个处理单元包含完全一样的内存中数据就很关键。下图展示处理单元间如何同步数据复制，实际中是通过非常迅速的并行的异步复制来完成的，通常在微秒级。</p>
<p><img src="5-4.png" alt="5-4"></p>
<h4 id="处理框架"><a href="#处理框架" class="headerlink" title="处理框架"></a>处理框架</h4><p>处理框架，就像下图所示，是虚拟化中间件中一个可选组件，负责管理在有多个处理单元时的分布式请求处理，每个处理单元可能只负责应用中的某个特定功能。如果请求需要处理单元间合作（比如，一个订单处理单元和顾客处理单元），此时处理框架就充当处理单元见数据传递的媒介。</p>
<p><img src="5-5.png" alt="5-5"></p>
<h4 id="部署管理器"><a href="#部署管理器" class="headerlink" title="部署管理器"></a>部署管理器</h4><p>部署管理器根据负载情况管理处理单元的动态启动和关闭。它持续检测请求所需时间和在线用户量，在负载增加时启动新的处理单元，在负载下降时关闭处理单元。它是实现可变伸缩性需求的关键。</p>
<h3 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h3><p>基于空间的架构是一个复杂和实现起来相对昂贵的框架。对于有可变伸缩性需求的小型web应用是很好的选择，然而，对于拥有大量数据操作的传统大规模关系型数据库应用，并不那么适用。</p>
<p>虽然基于空间的架构模型不需要集中式的数据储存，但通常还是需要这样一个，来进行初始化内存中数据框架，和异步的更新各处理单元的数据。通常也会创建一个单独的分区，来从隔离常用的断电就消失的数据和不常用的数据，这样减少处理单元之间对对方内存数据的依赖。</p>
<p>值得注意的是，虽然这个架构的另一个名字是云架构，处理单元（以及虚拟化中间件）都没有放在云端服务或者PaaS上。他们同样可以简单的放在本地服务器，这也是为什么我更倾向叫它“基于空间的架构”。</p>
<p>从产品实现的角度讲，这个架构中的很多组件都可以从第三方获得，比如GemFire, JavaSpaces, GigaSpaces，IBM Object Grid，nCache，和 Oracle Coherence。由于架构的实现根据工程的预算和需求而异，所以作为架构师，你应该在实现或选购第三方产品前首先明确你的目标和需求。</p>
<h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h3><p>下面的表格是这个架构的特征分析和评分。每个特征的评分是基于一个典型的架构实现来给出的。要知道这个模式相对别的模式的对比，请参见最后的附录A。</p>
<h4 id="综合能力"><a href="#综合能力" class="headerlink" title="综合能力"></a>综合能力</h4><p>评分：高<br> 分析：综合能力是对环境变化做出快速反应的能力。因为处理单元（应用的部署实例）可以快速的启动和关闭，整个应用可以根据用户量和负载做出反应。使用这个架构通常在应对代码变化上，由于较小的应用规模和组件间相互依赖，也会反映良好。</p>
<h4 id="易于部署-4"><a href="#易于部署-4" class="headerlink" title="易于部署"></a>易于部署</h4><p>评分：高<br> 分析：虽然基于空间的架构通常没有解耦合并且功能分布，但他们是动态的，也是成熟的基于云的工具，允许应用轻松的部署到服务器。</p>
<h4 id="可测试性-4"><a href="#可测试性-4" class="headerlink" title="可测试性"></a>可测试性</h4><p>评分：低<br> 分析：测试高用户负载既昂贵又耗时，所以在测试架构的可伸缩性方面很困难</p>
<h4 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h4><p>评分：高<br> 分析：通过内存中数据存取和架构中的缓存机制可获得高性能</p>
<h4 id="伸缩性-4"><a href="#伸缩性-4" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评分：高<br> 分析：高伸缩性是源于几乎不依赖集中式的数据库，从而去除了这个限制伸缩性的瓶颈。</p>
<h4 id="易于开发-3"><a href="#易于开发-3" class="headerlink" title="易于开发"></a>易于开发</h4><p>评分：低<br> 分析：主要是因为难以熟悉这个架构开发所需得工具和第三方产品，因此使用该架构需要较大的学习成本。而且，开发过程中还需要特别注意不要影响到性能和可伸缩性。</p>
<h3 id="附录A"><a href="#附录A" class="headerlink" title="附录A"></a>附录A</h3><h4 id="模式分析总结"><a href="#模式分析总结" class="headerlink" title="模式分析总结"></a>模式分析总结</h4><p>图A-1 总结了在这个报告中，对于架构模式的每部分进行的模式分析所产生的影响。这个总结帮助你确定哪些模式可能是最适合你的情况。例如,如果你的架构模式重点是可伸缩性，你可以在这个图表看看事件驱动模式,microservices模式,和基于空间模式，这些对于你来说可能是很好的架构模式的选择。同样的,如果你的程序注重的是分层架构模式,你可以参考图看到部署、性能和可伸缩性的在你的架构中所存在的风险。</p>
<p><img src="a-1.png" alt="a-1"></p>
<p>同时这个图表将指导你选择正确的模式,因为在选择一种架构模式的时候，有更多的因素需要考虑。你必须分析你的环境的各个方面,包括基础设施的支持,开发人员技能,项目预算,项目最后期限,和应用程序大小等等。选择正确的架构模式是至关重要的,因为一旦一个架构被确定就很难改变。</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a target="_blank" rel="noopener" href="https://gitlab.com/BangHeriSetiawan/android-tech-frontier/blob/00911a665a20cb4c85c1db7ade4410c292d32ed5/software-architecture-patterns/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.md#appendix">软件架构模式</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/12/27/flutter/flutter-2Dart%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/27/flutter/flutter-2Dart%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" class="post-title-link" itemprop="url">flutter-2Dart语法快速上手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-27 11:48:08 / 修改时间：11:52:36" itemprop="dateCreated datePublished" datetime="2022-12-27T11:48:08+08:00">2022-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-几个重要概念"><a href="#一-几个重要概念" class="headerlink" title="一. 几个重要概念"></a>一. 几个重要概念</h2><p>在学习 Dart 语言时, 先要清楚以下几个事实和概念：</p>
<ul>
<li>Dart 语句是以分号 <code>;</code> 结尾的。</li>
<li>任何保存在变量中的都是一个对象，并且所有的对象都是对应一个类的实例。无论是数字，函数和 <code>null</code> 都是对象。所有对象继承自 Object 类。</li>
<li>尽管 Dart 是强类型的，但是 Dart 可以推断类型，所以类型注释是可选的。 如果要明确说明不需要任何类型， 需要使用特殊类型 dynamic 。</li>
<li>Dart 支持泛型，如 <code>List &lt;int&gt;</code>（整数列表）或 <code>List &lt;dynamic&gt;</code>（任何类型的对象列表）。</li>
<li>Dart 支持顶级函数，例如 <code>main()</code> ，同样函数绑定在类或对象上（分别是静态函数和实例函数）。以及支持函数内创建函数（ 嵌套或局部函数）。</li>
<li>Dart 支持顶级变量，同样变量绑定在类或对象上（静态变量和实例变量）。实例变量有时称为字段或属性。</li>
<li>与 Java 不同，Dart 没有关键字 <code>public</code> ， <code>protected</code> 和 <code>private</code> 。如果标识符以下划线 <code>_</code> 开头，则它相对于库是私有的。</li>
<li>标识符以字母或下划线 <code>_</code> 开头，后跟任意字母和数字组合。</li>
</ul>
<p>二. Dart关键字</p>
<p>Dart 语言关键字列表如下：</p>
<table>
<thead>
<tr>
<th>else</th>
<th>import</th>
<th>static</th>
<th>assert</th>
<th>enum</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>uper</td>
<td>async</td>
<td>export</td>
<td>interface</td>
</tr>
<tr>
<td>switch</td>
<td>await</td>
<td>extends</td>
<td>is</td>
<td>sync</td>
</tr>
<tr>
<td>break</td>
<td>external</td>
<td>library</td>
<td>this</td>
<td>case</td>
</tr>
<tr>
<td>factory</td>
<td>mixin</td>
<td>throw</td>
<td>catch</td>
<td>false</td>
</tr>
<tr>
<td>new</td>
<td>true</td>
<td>class</td>
<td>final</td>
<td>null</td>
</tr>
<tr>
<td>try</td>
<td>const</td>
<td>finally</td>
<td>on</td>
<td>typedef</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>operator</td>
<td>var</td>
<td>covariant</td>
</tr>
<tr>
<td>Function</td>
<td>part</td>
<td>void</td>
<td>default</td>
<td>get</td>
</tr>
<tr>
<td>rethrow</td>
<td>while</td>
<td>deferred</td>
<td>hide</td>
<td>return</td>
</tr>
<tr>
<td>with</td>
<td>do</td>
<td>if</td>
<td>set</td>
<td>yield</td>
</tr>
</tbody></table>
<p>使用 Dart 时应避免使用这些单词作为标识符。</p>
<h2 id="三-入口函数"><a href="#三-入口函数" class="headerlink" title="三. 入口函数"></a>三. 入口函数</h2><p>Dart 有两种入口主函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> main()&#123;</span><br><span class="line">  print(&#x27;Hello Dart!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加 void 表示没有返回值</span><br><span class="line">void main()&#123;</span><br><span class="line">  print(&#x27;Hello Flutter!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-代码注释"><a href="#四-代码注释" class="headerlink" title="四. 代码注释"></a>四. 代码注释</h2><p>Dart 支持单行注释、多行注释和文档注释：</p>
<ol>
<li>单行注释：单行注释以 <code>//</code> 开始。 所有在 <code>//</code> 和改行结尾之间的内容被编译器忽略。</li>
<li>多行注释：多行注释以 <code>/*</code> 开始， 以 <code>*/</code> 结尾。 所有在 <code>/*</code> 和 <code>*/</code> 之间的内容被编译器忽略 （不会忽略文档注释）。 多行注释可以嵌套。</li>
<li>文档注释：文档注释可以是多行注释，也可以是单行注释，文档注释以  <code>///</code> 或者 <code>/**</code> 开始。 在连续行上使用 <code>///</code> 与多行文档注释具有相同的效果。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 单行注释</span><br><span class="line">/* </span><br><span class="line"> * 多行注释</span><br><span class="line"> */ </span><br><span class="line"></span><br><span class="line">/// 文档注释</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 文档注释</span><br><span class="line"> */三、变量</span><br></pre></td></tr></table></figure>

<h2 id="五-变量"><a href="#五-变量" class="headerlink" title="五. 变量"></a>五. 变量</h2><p><strong>1. 定义变量</strong></p>
<p>Dart 中定义变量有两种方式，一种是静态类型语言常用的方式，即指定变量类型；另一种则是动态语言的常用方式，即不指定类型，由 Dart 自动类型判断，一般最好指定类型。</p>
<p> <code>// 指定变量类型：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = &#x27;ImportV&#x27;;</span><br><span class="line"></span><br><span class="line">// 使用关键字 var ，不指定变量类型：</span><br><span class="line">var name = &#x27;ImportV&#x27;;</span><br></pre></td></tr></table></figure>

<p>未初始化的变量默认值是 <code>null</code>。即使变量是数字类型默认值也是 <code>null</code>，因为在 Dart 中一切都是对象，数字类型也不例外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">print(a);  // 输出值为 null</span><br></pre></td></tr></table></figure>

<p>\2. 动态改变变量类型</p>
<p>如想动态改变变量的数据类型，应当使用 <code>dynamic</code> 或 <code>Object</code> 来定义变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dynamic a = &#x27;Dart&#x27;;  // 也可使用 Object a = &#x27;Dart&#x27;;</span><br><span class="line">a = 2021;</span><br><span class="line">print(a);  // 输出结果为 2021</span><br></pre></td></tr></table></figure>

<p>\3. 定义常量</p>
<p>Dart 中定义常量也有两种方式，一种使用 <code>final</code> 关键字，另一种是使用 <code>const</code> 关键字。需要注意的是， <code>final</code> 定义的常量是运行时常量，而 <code>const</code> 常量则是编译时常量，也就是说 <code>final</code> 定义常量时，其值可以是一个变量，而 <code>const</code> 定义的常量，其值必须是一个字面常量值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final a = DateTime.now();</span><br><span class="line">print(a);  // 输出现在的时间</span><br><span class="line"></span><br><span class="line">const a = DateTime.now();</span><br><span class="line">print(a);  // 报错</span><br><span class="line"></span><br><span class="line">六. 内建类型</span><br></pre></td></tr></table></figure>

<p>Dart 语言支持以下内建类型：</p>
<p><img src="http://space.babytree-inc.com/download/attachments/30609176/640.png?version=2&modificationDate=1645091354000&api=v2" alt="img"><br>\1. Number</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// int 必须是整型：</span><br><span class="line">int a = 123;</span><br><span class="line"></span><br><span class="line">// 从 Dart 2.0 开始，double 既可以是浮点数也可以是整型：</span><br><span class="line">double b = 12.34;</span><br><span class="line">double c = 6;    // 相当于 double c = 6.0</span><br></pre></td></tr></table></figure>

<p>\2. String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 用单引号或者双引号定义字符串：</span><br><span class="line">String s1 = &#x27;Hello Dart!&#x27;</span><br><span class="line">String s2 = &quot;Hello Flutter!&quot;</span><br><span class="line"></span><br><span class="line">// 当字符串有引号时：</span><br><span class="line">String s3 = &#x27;I\&#x27;m ImportV!&#x27;</span><br><span class="line">string s4 = &quot;I&#x27;m ImportV!&quot;</span><br><span class="line"></span><br><span class="line">// 使用连续三个单引号或者三个双引号实现多行字符串对象的创建：</span><br><span class="line">String s5 = &#x27;&#x27;&#x27;</span><br><span class="line">Hello Dart! </span><br><span class="line">Hello Flutter! </span><br><span class="line">Hello ImportV!</span><br><span class="line">&#x27;&#x27;&#x27;;</span><br><span class="line">// 使用 r 前缀，可以创建 “原始 raw” 字符串：</span><br><span class="line">String s6 = r&#x27;Hello Dart \n Hello Flutter!&#x27;</span><br><span class="line"></span><br><span class="line">// String -&gt; int：</span><br><span class="line">int a = int.parse(&#x27;123&#x27;);</span><br><span class="line"></span><br><span class="line">// String -&gt; double：</span><br><span class="line">double b = double.parse(&#x27;12.34&#x27;);</span><br><span class="line"></span><br><span class="line">// int -&gt; String：</span><br><span class="line">String str1 = 123.toString();</span><br><span class="line"></span><br><span class="line">// double -&gt; String：</span><br><span class="line">String str2 = 12.3456.toStringAsFixed(2);  // 括号内为要保留的小数位数</span><br><span class="line"></span><br><span class="line">// 字符串拼接，用“+”拼接，字面量字符串也可以直接写在一起：</span><br><span class="line">String s1 = &#x27;Hello Dart! &#x27; &#x27;Hello Flutter! &#x27; &#x27;Hello ImportV! &#x27;;</span><br><span class="line">String s2 = &#x27;Hello Dart! &#x27; + &#x27;Hello Flutter! &#x27; + &#x27;Hello ImportV! &#x27;;</span><br><span class="line"></span><br><span class="line">// 字符串可以通过 $&#123;expression&#125; 的方式内嵌表达式。 如果表达式是一个标识符，则 &#123;&#125; 可以省略:</span><br><span class="line">String s1 = &#x27;Hello Flutter!&#x27;;</span><br><span class="line">String s2 = &#x27;Hello Dart! $s1 Hello ImportV!&#x27;;</span><br></pre></td></tr></table></figure>

<p>\3. Boolean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 布尔类型默认值为null，字面量只有 true 和 false ，这两个对象都是编译时常量：</span><br><span class="line">bool b = true;</span><br></pre></td></tr></table></figure>

<p>\4. List</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 定义列表方法一：</span><br><span class="line">List lt1 = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// 定义列表方法二：</span><br><span class="line">List a = [];</span><br><span class="line">a.add(1);</span><br><span class="line">a.add(2);</span><br><span class="line">a.add(3);</span><br><span class="line"></span><br><span class="line">// 获取列表属性：</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;ImportV&#x27;];</span><br><span class="line">print(a.length);  // 获取列表长度</span><br><span class="line">print(a.isEmpty);  // 判断列表是否为空，如果是，输出 true</span><br><span class="line">print(a.isNotEmpty);  // 判断列表是否为空，如果不是，输出 true</span><br><span class="line">print(a.reversed);  // 将列表逆序输出（翻转列表）</span><br><span class="line"></span><br><span class="line">// 列表的下标索引是从0开始的：</span><br><span class="line">List a = [1, 2, 3, 4];</span><br><span class="line">print(a[0]);</span><br><span class="line"></span><br><span class="line">// 拼接与插入：</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;];</span><br><span class="line">a.add(&#x27;Android&#x27;);  // 拼接一个元素</span><br><span class="line">a.addAll([&#x27;Android&#x27;, &#x27;iOS&#x27;]);  // 拼接多个元素</span><br><span class="line">a.insert(2, &#x27;Android&#x27;);  // 插入一个元素，2 为插入位置的索引值</span><br><span class="line">a.insertAll(2, [&#x27;Android&#x27;, &#x27;iOS&#x27;]);  // 插入多个元素</span><br><span class="line"></span><br><span class="line">// 列表转字符串：</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;];</span><br><span class="line">String b = a.join(&#x27;-&gt;&#x27;);  // 此处 b 的字面量为 Dart-&gt;Flutter-&gt;Android</span><br><span class="line"></span><br><span class="line">// 字符串转列表：</span><br><span class="line">String a = &#x27;Dart-&gt;Flutter-&gt;Android&#x27;;</span><br><span class="line">List b = a.split(&#x27;-&gt;&#x27;);  // 此处 b 的字面量为 [Dart, Flutter, Android]</span><br><span class="line"></span><br><span class="line">// 指定列表类型：</span><br><span class="line">List a = &lt;String&gt;[];</span><br><span class="line">a.add(&#x27;Flutter&#x27;);</span><br><span class="line">a.add(1);  //报错</span><br><span class="line"></span><br><span class="line">// 在列表字面量前添加 const 关键字，定义一个不可改变的列表（编译时常量）：</span><br><span class="line">List a = const [1, 2, 3, 4];</span><br><span class="line">a[0] = 2;  // 报错</span><br></pre></td></tr></table></figure>

<p>\5. Set</p>
<p>Set 是没有顺序且元素不能重复的集合，因此不能通过索引去获取值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 定义集合方法一：</span><br><span class="line">Set a = &#123;&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;ImportV&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">// 定义集合方法二</span><br><span class="line">Set a = &#123;&#125;;</span><br><span class="line">a.add(&#x27;Dart&#x27;);</span><br><span class="line">a.add(&#x27;Flutter&#x27;);</span><br><span class="line">a.add(&#x27;ImportV&#x27;);</span><br><span class="line"></span><br><span class="line">// 创建空集合：</span><br><span class="line">Set a = &#123;&#125;;  //  方法一</span><br><span class="line">var a = &lt;String&gt;&#123;&#125;;  // 方法二</span><br><span class="line">var a = &#123;&#125;;  // 这样会创建一个空的 Map，而不是 Set</span><br><span class="line"></span><br><span class="line">// 获取集合中元素的个数：</span><br><span class="line">Set a = &#123;&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;ImportV&#x27;&#125;;</span><br><span class="line">print(a.length);  // 输出为 3</span><br><span class="line"></span><br><span class="line">// 创建一个不可改变的集合（编译时常量）：</span><br><span class="line">Set a = const &#123;&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;ImportV&#x27;&#125;;</span><br><span class="line">a.add(&#x27;Android&#x27;);  // 报错</span><br><span class="line"></span><br><span class="line">// 列表转集合：</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;];</span><br><span class="line">print(a.toSet());</span><br><span class="line"></span><br><span class="line">// 集合转列表：</span><br><span class="line">Set a = &#123;&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;&#125;;</span><br><span class="line">print(a.toList());</span><br></pre></td></tr></table></figure>

<p>\6. Map</p>
<p>Map（映射）是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 定义映射方法一：</span><br><span class="line">Map a = &#123;</span><br><span class="line">// key     value</span><br><span class="line">  &#x27;first&#x27;: &#x27;Dart&#x27;,</span><br><span class="line">  &#x27;second&#x27;: &#x27;Flutter&#x27;,</span><br><span class="line">  &#x27;third&#x27;: &#x27;Android&#x27;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">// 定义映射方法二：</span><br><span class="line">Map a = &#123;&#125;;</span><br><span class="line">a[&#x27;first&#x27;] = &#x27;Dart&#x27;;</span><br><span class="line">a[&#x27;second&#x27;] = &#x27;Flutter&#x27;;</span><br><span class="line">a[&#x27;third&#x27;] = &#x27;Android&#x27;;</span><br><span class="line"></span><br><span class="line">// 获取映射长度：</span><br><span class="line">print(a.length);</span><br><span class="line"></span><br><span class="line">// 获取指定 value 值：</span><br><span class="line">print(a[&#x27;first&#x27;]);</span><br><span class="line"></span><br><span class="line">// 在映射字面量前添加 const 关键字，定义一个不可改变的映射（编译时常量）：</span><br><span class="line">Map a = const &#123;&#x27;first&#x27;: &#x27;Dart&#x27;, &#x27;second&#x27;: &#x27;Flutter&#x27;, &#x27;third&#x27;: &#x27;Android&#x27;&#125;;</span><br><span class="line">a[&#x27;third&#x27;] = &#x27;iOS&#x27;  //报错五、运算符</span><br></pre></td></tr></table></figure>

<h2 id="七-运算符"><a href="#七-运算符" class="headerlink" title="七. 运算符"></a>七. 运算符</h2><p>下面是 Dart 定义的运算符：</p>
<p><strong>1. 算数运算符</strong></p>
<p>除了基本的算术运算外，Dart 还支持前缀和后缀、自增和自减运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a, b;</span><br><span class="line">a = 0;</span><br><span class="line"></span><br><span class="line">b = ++a;  // a自加1后赋值给b</span><br><span class="line">b = a++;  // a赋值给b后自加1</span><br><span class="line">b = --a;  // a自减1后赋值给b</span><br><span class="line">b = a--;  // a赋值给b后自减1</span><br></pre></td></tr></table></figure>

<h3 id="2-类型判断运算符"><a href="#2-类型判断运算符" class="headerlink" title="2. 类型判断运算符"></a>2. 类型判断运算符</h3><p>使用 <code>as</code> 运算符将对象强制转换为特定类型时，通常可以认为是 <code>is</code> 类型判定后，被判定对象调用函数的一种缩写形式。 请考虑以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (emp is Person) &#123;</span><br><span class="line">  emp.firstName = &#x27;Bob&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 as 运算符进行缩写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp as Person).firstName = &#x27;Bob&#x27;;</span><br></pre></td></tr></table></figure>

<p>【注意】以上代码并不是等价的。 如果 <code>emp</code> 为 <code>null</code> 或者不是 <code>Person</code> 对象， 那么第一个 <code>is</code> 的示例，后面将不执行； 第二个 <code>as</code> 的示例会抛出异常。</p>
<h3 id="3-赋值运算符"><a href="#3-赋值运算符" class="headerlink" title="3. 赋值运算符"></a>3. 赋值运算符</h3><p>下面示例使用几个赋值和复合赋值运算符，其他使用方法类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 123;  // 使用 = 直接为变量赋值。</span><br><span class="line"></span><br><span class="line">b ??= 456;  // 使用 ??= 运算符时，只有当 b 值为 null 时才会被赋值</span><br><span class="line"></span><br><span class="line">a *= 3;  // 赋值并做乘法运算，相当于 a = a * 3</span><br></pre></td></tr></table></figure>

<h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h3><p>下面是关于逻辑表达式的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!done &amp;&amp; (col == 0 || col == 3)) &#123;</span><br><span class="line">  // ...Do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5. 位运算符"></a>5. 位运算符</h3><p>位运算符把数字转为二进制来运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 按位与，参与运算的两个值，如果两个相应二进位都为 1，则该位结果为 1，否则为 0</span><br><span class="line">print(a &amp; b);  // 结果为 4</span><br><span class="line"></span><br><span class="line">// 按位或，只要对应的两个二进位有一个为 1，结果位就为 1</span><br><span class="line">print(a | b);  // 结果为 14</span><br><span class="line"></span><br><span class="line">// 按位异或，当两个对应的二进位相异时，结果位为 1，否则为 0</span><br><span class="line">print(a ^ b);  // 结果为 10</span><br><span class="line"></span><br><span class="line">// 按位取反，对数据的每一个二进位，把 1 变为 0，把 0 变为 1</span><br><span class="line">print(~a);  // 结果我为 -13</span><br><span class="line"></span><br><span class="line">// 左移，把 &lt;&lt; 左边的数的各二进位左移若干位，由 &lt;&lt; 右边的数指定移动位数，高位丢弃，低位补 0</span><br><span class="line">print(a &lt;&lt; 2);  // 结果为 48，相当于乘以 2 的 2 次方</span><br><span class="line"></span><br><span class="line">// 右移，把 &lt;&lt; 左边的数的各二进位右移若干位，由 &lt;&lt; 右边的数指定移动位数</span><br><span class="line">print(a &gt;&gt; 2);  // 结果为 3，相当于除以 2 的 2 次方</span><br></pre></td></tr></table></figure>

<h3 id="6-条件表达式"><a href="#6-条件表达式" class="headerlink" title="6. 条件表达式"></a>6. 条件表达式</h3><p>Dart有两个运算符，有时可以替换 if-else 表达式， 让表达式更简洁，称为条件表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expr1 : expr2</span><br></pre></td></tr></table></figure>

<p>如果条件为 <code>true</code>, 执行 <code>expr1</code> (并返回它的值)： 否则, 执行并返回 <code>expr2</code> 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr1 ?? expr2</span><br></pre></td></tr></table></figure>

<p>如果 <code>expr1</code> 不是 <code>null</code>， 返回 <code>expr1</code> 的值； 否则, 执行并返回 <code>expr2</code> 的值。</p>
<p>如果条件判断是根据布尔值， 考虑使用第一种，如果是根据是否为 <code>null</code>，考虑使用第二种。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &#x27;Dart&#x27;;</span><br><span class="line">var b = &#x27;Flutter&#x27;;</span><br><span class="line">var c = a ?? b.toUpperCase();  // 此处 c 的字面量为 Dart</span><br></pre></td></tr></table></figure>

<h3 id="7-级联运算符"><a href="#7-级联运算符" class="headerlink" title="7. 级联运算符"></a>7. 级联运算符</h3><p>级联运算符 <code>..</code> 可以实现对同一个对像进行一系列的操作。 除了调用函数外， 还可以访问同一对象上的字段属性。 这通常可以节省创建临时变量的步骤， 同时编写出更流畅的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">querySelector(&#x27;#confirm&#x27;)   // 获取对象。</span><br><span class="line">  ..text = &#x27;Confirm&#x27;    // 调用成员变量。</span><br><span class="line">  ..classes.add(&#x27;important&#x27;)</span><br><span class="line">  ..onClick.listen((e) =&gt; window.alert(&#x27;Confirmed!&#x27;));</span><br></pre></td></tr></table></figure>

<p>第一句调用函数 <code>querySelector()</code> ，返回获取到的对象。 获取的对象依次执行级联运算符后面的代码， 代码执行后的返回值会被忽略。</p>
<p>上面的代码等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var button = querySelector(&#x27;#confirm&#x27;);</span><br><span class="line">button.text = &#x27;Confirm&#x27;;</span><br><span class="line">button.classes.add(&#x27;important&#x27;);</span><br><span class="line">button.onClick.listen((e) =&gt; window.alert(&#x27;Confirmed!&#x27;));</span><br></pre></td></tr></table></figure>

<p>级联运算符是可以嵌套的。但要注意，在返回对象的函数中谨慎使用级联操作符。 例如，下面的代码是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sb = StringBuffer();</span><br><span class="line">sb.write(&#x27;foo&#x27;)</span><br><span class="line">  ..write(&#x27;bar&#x27;);   // sb.write() 函数调用返回 void， 不能在 void 对象上创建级联操作。六、流程控制语句</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="八-流程控制语句"><a href="#八-流程控制语句" class="headerlink" title="八. 流程控制语句"></a>八. 流程控制语句</h2><p>Dart 中的流程控制语句与 Java 相似。</p>
<p><strong>1. if - else 分支</strong></p>
<p>和 JavaScript 不同， Dart 的判断条件必须是布尔值，不能是其他类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">if (a &lt; 0) &#123;</span><br><span class="line">  a++;</span><br><span class="line">&#125; else if (a &gt; 0) &#123;</span><br><span class="line">  a--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-switch-case-语句"><a href="#2-switch-case-语句" class="headerlink" title="2. switch - case 语句"></a>2. switch - case 语句</h3><p>在 Dart 中 <code>switch</code> 语句使用 <code>==</code> 比较整数、字符串、编译时常量或者枚举类型。 比较的对象必须都是同一个类的实例（并且不可以是子类）， 类必须没有对 <code>==</code> 重写。</p>
<p>在 <code>case</code> 语句中，每个非空的 <code>case</code> 语句结尾需要跟一个 <code>break</code> 语句。 除  <code>break</code>以外，还有可以使用 <code>continue</code>， <code>throw</code> 或者 <code>return</code>。当没有 <code>case</code> 语句匹配时，执行 <code>default</code> 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = &#x27;yes&#x27;;</span><br><span class="line">switch (a) &#123;</span><br><span class="line">  case &#x27;yes&#x27;:</span><br><span class="line">    print(&#x27;yes&#x27;);</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;no&#x27;:</span><br><span class="line">    print(&#x27;no&#x27;);</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    print(&#x27;fault&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h3><p>进行迭代操作，可以使用标准 for 语句。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 计算 5 的阶乘</span><br><span class="line">int result = 1;</span><br><span class="line">for (int i = 1; i &lt; 6; i++) &#123;</span><br><span class="line">  result = result * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包在 Dart 的 for 循环中会捕获循环的初始索引值， 来避免 JavaScript 中常见的陷阱。下面的代码输出的是 0 和 1，但是在 JavaScript 中会连续输出两个 2 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = [];</span><br><span class="line">for (var i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">  callbacks.add(() =&gt; print(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) =&gt; c());</span><br></pre></td></tr></table></figure>

<h3 id="4-while-和-do-while-循环"><a href="#4-while-和-do-while-循环" class="headerlink" title="4. while 和 do while 循环"></a>4. while 和 do while 循环</h3><p><code>while</code> 循环是在执行前判断执行条件，<code>do-while</code> 循环是在执行后判断执行条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 计算 5 的阶乘</span><br><span class="line">int i = 1;</span><br><span class="line">int result = 1;</span><br><span class="line">// 使用 while 循环</span><br><span class="line">while (i &lt; 6) &#123;</span><br><span class="line">  result = result * i;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line">// 使用 do - while 循环</span><br><span class="line">do &#123;</span><br><span class="line">  result = result * i;</span><br><span class="line">  i++;</span><br><span class="line">&#125; while (i &lt; 6);</span><br></pre></td></tr></table></figure>

<h3 id="5-break-和-continue"><a href="#5-break-和-continue" class="headerlink" title="5. break 和 continue"></a>5. break 和 continue</h3><p>使用 <code>break</code> 停止程序循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">  if (i == 3) &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  print(i);  // 输出结果为 1 2（i = 3 时循环结束）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>continue</code> 跳转到下一次循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">  if (i == 3) &#123;</span><br><span class="line">    continue;</span><br><span class="line">  &#125;</span><br><span class="line">  print(i);  // 输出结果为 1 2 4（i = 3 时跳到下一次循环）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-其他循环"><a href="#6-其他循环" class="headerlink" title="6. 其他循环"></a>6. 其他循环</h3><p>使用 <code>for...in...</code> 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 遍历数组</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;];</span><br><span class="line">for (var item in a) &#123;</span><br><span class="line">  print(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>forEach</code> 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 遍历数组</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;];</span><br><span class="line">a.forEach((var item) &#123;</span><br><span class="line">  print(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="7-assert-语句"><a href="#7-assert-语句" class="headerlink" title="7. assert 语句"></a>7. assert 语句</h3><p>使用 <code>assert</code> 语句进行判断，如果 <code>assert</code> 语句中的布尔条件为 <code>false</code> ， 那么正常的程序执行流程会被中断:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 确认变量值不为空。</span><br><span class="line">assert(text != null);</span><br><span class="line"></span><br><span class="line">// 确认变量值小于100。</span><br><span class="line">assert(number &lt; 100);</span><br></pre></td></tr></table></figure>

<p>【注意】<code>assert</code> 语句只在开发环境中有效， 在生产环境是无效的； Flutter 中的 <code>assert</code> 只在 debug 模式中有效。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="九-异常处理"><a href="#九-异常处理" class="headerlink" title="九. 异常处理"></a>九. 异常处理</h2><p>Dart 代码可以抛出和捕获异常。和 Java 有所不同， Dart 中的所有异常是非检查异常。方法不会声明它们抛出的异常，也不要求捕获任何异常。</p>
<p>Dart 提供了 <code>Exception</code> 和 <code>Error</code> 类型， 以及一些子类型，也可以定义自己的异常类型。Dart 程序可以抛出任何非 <code>null</code> 对象， 不仅限 <code>Exception</code> 和 <code>Error</code> 对象。</p>
<h3 id="1-throw-抛出异常"><a href="#1-throw-抛出异常" class="headerlink" title="1. throw 抛出异常"></a>1. throw 抛出异常</h3><p>下面是关于抛出或者引发异常的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw FormatException(&#x27;Expected at least 1 section&#x27;);</span><br></pre></td></tr></table></figure>

<p>也可以抛出任意的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw &#x27;Out of llamas!&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="2-try…catch…finally-捕获异常"><a href="#2-try…catch…finally-捕获异常" class="headerlink" title="2. try…catch…finally 捕获异常"></a>2. try…catch…finally 捕获异常</h3><p>Dart 语言中通过指定多个 <code>catch</code> 语句，可以处理可能抛出多种类型异常的代码，并由与抛出异常类型匹配的第一个 <code>catch</code> 语句处理异常。 如果 <code>catch</code> 语句未指定类型， 则该语句可以处理任何类型的抛出对象。</p>
<p>此外，<code>catch()</code> 函数可以指定1到2个参数， 第一个参数为抛出的异常对象， 第二个为堆栈信息。</p>
<p>使用 <code>finally</code> 语句时，无论是否抛出异常，<code>finally</code> 中的代码都会被执行。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  print(10 ~/ 0);</span><br><span class="line">&#125; on IntegerDivisionByZeroException catch (e, s) &#123;</span><br><span class="line">  print(e);</span><br><span class="line">  print(s);</span><br><span class="line">&#125; on Exception catch (e, s) &#123;</span><br><span class="line">  print(e);</span><br><span class="line">  print(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 捕获的异常</span><br><span class="line">IntegerDivisionByZeroException  </span><br><span class="line">// 堆栈信息</span><br><span class="line">#0      int.~/ (dart:core-patch/integers.dart:22:7)  </span><br><span class="line">#1      main (file:///c:/Users/27884/Desktop/test.dart:3:14)</span><br><span class="line">#2      _startIsolate.&lt;anonymous closure&gt; (dart:isolate-patch/isolate_patch.dart:301:19)</span><br><span class="line">#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:168:12)</span><br><span class="line">// finally 语句后的代码执行结果</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/12/27/flutter/flutter-1%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/27/flutter/flutter-1%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">flutter-1学习相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-27 11:12:42 / 修改时间：11:52:30" itemprop="dateCreated datePublished" datetime="2022-12-27T11:12:42+08:00">2022-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、环境及基础"><a href="#1、环境及基础" class="headerlink" title="1、环境及基础"></a>1、环境及基础</h1><ul>
<li>官网<br><a target="_blank" rel="noopener" href="https://flutter.cn/docs/get-started/install">https://flutter.cn/docs/get-started/install</a></li>
<li>中文网<br><a target="_blank" rel="noopener" href="https://flutterchina.club/get-started/install/">https://flutterchina.club/get-started/install/</a></li>
<li>公开库<br><a target="_blank" rel="noopener" href="https://pub.dev/">https://pub.dev</a></li>
<li>电子书<br><a target="_blank" rel="noopener" href="https://book.flutterchina.club/">https://book.flutterchina.club</a></li>
<li>cookbook<br><a target="_blank" rel="noopener" href="https://docs.flutter.dev/cookbook">https://docs.flutter.dev/cookbook</a></li>
</ul>
<h1 id="2、优秀开源"><a href="#2、优秀开源" class="headerlink" title="2、优秀开源"></a>2、优秀开源</h1><table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://github.com/toly1994328/FlutterUnit">https://github.com/toly1994328/FlutterUnit</a></th>
<th>项目架构设计，UI及动画学习</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://laomengit.com/">http://laomengit.com</a></td>
<td>UI、动画学习</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/fluttercandies/">https://github.com/fluttercandies/</a></td>
<td>flutter 一桶天下</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://help.syncfusion.com/flutter/introduction/overview">https://help.syncfusion.com/flutter/introduction/overview</a></td>
<td>pdf，图表，日历，地图，表格等硬核插件</td>
</tr>
</tbody></table>
<h1 id="3、较活跃的论坛"><a href="#3、较活跃的论坛" class="headerlink" title="3、较活跃的论坛"></a>3、较活跃的论坛</h1><ul>
<li>掘金<br><a target="_blank" rel="noopener" href="https://juejin.cn/ios/Flutter">https://juejin.cn/ios/Flutter</a></li>
</ul>
<h1 id="4、公众号"><a href="#4、公众号" class="headerlink" title="4、公众号"></a>4、公众号</h1><ul>
<li>Flutter社区</li>
<li>Flutter编程指南</li>
<li>谷歌开发者</li>
<li>老孟Flutter</li>
<li>flutter开发精选</li>
</ul>
<h1 id="5、关于cocoapods"><a href="#5、关于cocoapods" class="headerlink" title="5、关于cocoapods"></a>5、关于cocoapods</h1><ul>
<li><p>不推荐使用bundle管理多个cocoapods版本。</p>
</li>
<li><p>备注：如果cocoapods安装指定版本不成功试下:</p>
<p>MacOS 10.11以后用此命令安装或卸载cocoapods（为了运行Flutter）<br>sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods -v 1.11.3<br>sudo gem uninstall -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods -v 1.11.3</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/04/18/OC%E5%85%B6%E5%AE%83/iOS%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/OC%E5%85%B6%E5%AE%83/iOS%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">iOS包大小优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-18 18:18:49" itemprop="dateCreated datePublished" datetime="2022-04-18T18:18:49+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/12/28/swift/1-Class-Struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/28/swift/1-Class-Struct/" class="post-title-link" itemprop="url">Class & Struct</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-28 17:08:10" itemprop="dateCreated datePublished" datetime="2021-12-28T17:08:10+08:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><ol>
<li>定义存储值的属性</li>
<li>定义方法</li>
<li>定义下标以及使用下标语法提供对其值的访问</li>
<li>定义初始化器</li>
<li>使用extension来拓展功能</li>
<li>遵循协议来提供功能</li>
</ol>
<h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><ol>
<li>类有继承特性，结构体没有</li>
<li>类型转换，在运行时检查和解释类实例的类型</li>
<li>类有析构函数用来释放器分配的资源</li>
<li>引用计数允许对一个类实例有多个引用</li>
<li>类是引用类型，存储在堆上，也就意味着一个类类型的变量并不是直接存储具体的的实例对象，是对当前存储具体实例内存地址的引用。</li>
<li>Struct结构体是值类型，存储在栈上。如果值类型中有引用类型的属性，则该属性的地址在栈上，但是引用的值存储在堆上。</li>
<li>尽可能多的使用值类型，是内存安全的，运行效率也会比值类型高。</li>
</ol>
<h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><ol>
<li>类中添加属性，不会自动提供成员初始化器，必须提供对应的的指定初始化器（或者提供便捷初始化器）。</li>
<li>结构体会提供默认的成员初始化器。</li>
</ol>
<h3 id="便捷初始化器"><a href="#便捷初始化器" class="headerlink" title="便捷初始化器"></a>便捷初始化器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init(name: String, age: Int) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convenience init()&#123;</span><br><span class="line">// 这里需要调用初始化</span><br><span class="line">    self.init(name: &quot;name&quot;, age: 18)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>便捷初始化器必须从相同的类里调用另一个初始化器，否则会报错。</p>
<h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><ol>
<li>指定初始化器必须在调用父类初始化器之前，对其所有属性完成初始化。（确保成员变量使用安全）</li>
<li>指定初始化器必须在调用父类初始化器之后，才能为继承的属性设置新值，否则指定初始化器中赋的新值会被父类的初始化所覆盖。</li>
<li>便捷初始化器必须先调用同类中的初始化器之后，再为任意属性赋值，否则会报错，（属性的值也会被指定初始化覆盖）。</li>
<li>初始化器在初始化完成之前，不能调用任何实例方法，不能读取任何实例属性的值，也不能引用self作为值。必须保证内存是安全的</li>
</ol>
<h4 id="可失败初始化：init"><a href="#可失败初始化：init" class="headerlink" title="可失败初始化：init?"></a>可失败初始化：init?</h4><p>当参数不合法或者条件不满足时存在失败的情况，return nil。</p>
<h4 id="必要初始化：require"><a href="#必要初始化：require" class="headerlink" title="必要初始化：require"></a>必要初始化：require</h4><p>在类的初始化之前添加required关键字来修饰。表明该类的子类都必须实现该初始化器。</p>
<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>refCount ：64位的位域信息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/12/27/flutter/flutter-%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/27/flutter/flutter-%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">flutter-规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-27 10:04:25" itemprop="dateCreated datePublished" datetime="2021-12-27T10:04:25+08:00">2021-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h2><p>代码应该简洁易懂，逻辑清晰；<br>代码应优先保证正确性、可用性；<br>在保证程序可用的情况下，代码应该具备可扩展性，易修改，而不是需求有一点改动代码就需要大动干戈；</p>
<h2 id="禁止使用print直接提交到发版分支，使用debugPrint替换。"><a href="#禁止使用print直接提交到发版分支，使用debugPrint替换。" class="headerlink" title="禁止使用print直接提交到发版分支，使用debugPrint替换。"></a>禁止使用print直接提交到发版分支，使用debugPrint替换。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void tryCatch(Function f) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    f?.call();</span><br><span class="line">  &#125; catch (e, stack) &#123;</span><br><span class="line">    debugPrint(&#x27;$e&#x27;);</span><br><span class="line">    debugPrint(&#x27;$stack&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用-来连接它们。"><a href="#两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用-来连接它们。" class="headerlink" title="两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用 + 来连接它们。"></a>两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用 + 来连接它们。</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(</span><br><span class="line">    &#x27;ERROR: Parts of the spaceship are on fire. Other &#x27;</span><br><span class="line">    &#x27;parts are overrun by martians. Unclear which are which.&#x27;);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;ERROR: Parts of the spaceship are on fire. Other &#x27; +</span><br><span class="line">    &#x27;parts are overrun by martians. Unclear which are which.&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="优先使用插值来组合字符串和值。"><a href="#优先使用插值来组合字符串和值。" class="headerlink" title="优先使用插值来组合字符串和值。"></a>优先使用插值来组合字符串和值。</h3><p>如果您之前是用其他语言做开发的，那么您习惯使用+的长链来构建文字和其他值的字符串。 这在Dart中有效，但使用插值总是更清晰，更简短：</p>
<p>推荐写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Hello, $name! You are $&#123;year - birth&#125; years old.&#x27;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Hello, &#x27; + name + &#x27;! You are &#x27; + (year - birth).toString() + &#x27; y...&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="不要在字符串中使用不必要的大括号"><a href="#不要在字符串中使用不必要的大括号" class="headerlink" title="不要在字符串中使用不必要的大括号"></a>不要在字符串中使用不必要的大括号</h3><p>当表达式的值可以为真、假或null，并且您需要将结果传递给不接受null的对象时，此规则适用。一个常见的情况是一个判断空值的方法调用被用作条件:</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Hi, $name!&#x27;</span><br><span class="line">&quot;Wear your wildest $decade&#x27;s outfit.&quot;</span><br><span class="line">//标识符后面有紧跟着的字母了 加上大括号用以区分</span><br><span class="line">&#x27;Wear your wildest $&#123;decade&#125;s outfit.&#x27;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Hi, $&#123;name&#125;!&#x27;</span><br><span class="line">&quot;Wear your wildest $&#123;decade&#125;&#x27;s outfit.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="使用-将空值转换为布尔值。"><a href="#使用-将空值转换为布尔值。" class="headerlink" title="使用? ?将空值转换为布尔值。"></a>使用? ?将空值转换为布尔值。</h3><p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (optionalThing?.isEnabled) &#123;</span><br><span class="line">  print(&quot;Have enabled thing.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果optionalThing为空，此代码将抛出异常。（if只支持判断bool值，不支持null）要解决这个问题，您需要将null值“转换”为true或false。虽然您可以使用&#x3D;&#x3D;来完成此操作，但我们建议使用?? :</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果你想要optionalThing是空值时返回false</span><br><span class="line">optionalThing?.isEnabled ?? false;</span><br><span class="line">//如果你想要optionalThing是空值时返回true</span><br><span class="line">optionalThing?.isEnabled ?? true;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果你想要optionalThing是空值时返回false</span><br><span class="line">optionalThing?.isEnabled == true;</span><br><span class="line">// 如果你想要optionalThing是空值时返回true</span><br><span class="line">optionalThing?.isEnabled != false;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="尽可能的使用集合字面量。"><a href="#尽可能的使用集合字面量。" class="headerlink" title="尽可能的使用集合字面量。"></a>尽可能的使用集合字面量。</h3><p>两种方式来构造一个空的可变 list ： [] 和 List() 。 同样，有三种方式来构造一个空的Map map：{}， Map()， 和 LinkedHashMap() 。 如果想创建一个固定不变的 list 或者其他自定义集合类型，这种情况下你需要使用构造函数。 否则，使用字面量语法更加优雅。 核心库中暴露这些构造函数易于扩展，但是通常在 Dart 代码中并不使用构造函数。</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points = [];</span><br><span class="line">var addresses = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points = List();</span><br><span class="line">var addresses = Map();</span><br></pre></td></tr></table></figure>

<h3 id="如果需要的话，你可以提供一个泛型"><a href="#如果需要的话，你可以提供一个泛型" class="headerlink" title="如果需要的话，你可以提供一个泛型"></a>如果需要的话，你可以提供一个泛型</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points = &lt;Point&gt;[];</span><br><span class="line">var addresses = &lt;String, Address&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points = List&lt;Point&gt;();</span><br><span class="line">var addresses = Map&lt;String, Address&gt;();</span><br></pre></td></tr></table></figure>

<p>注意，对于集合类的 命名 构造函数则不适用上面的规则。 List.from()、 Map.fromIterable() 都有其使用场景。 如果需要一个固定长度的结合，使用 List() 来创建一个固定长度的 list 也是合理的。</p>
<h3 id="不要使用-length-来判断一个集合是否为空。"><a href="#不要使用-length-来判断一个集合是否为空。" class="headerlink" title="不要使用 .length 来判断一个集合是否为空。"></a>不要使用 .length 来判断一个集合是否为空。</h3><p>通过调用 .length 来判断集合是否包含内容是非常低效的。相反，Dart 提供了更加高效率和易用的 getter 函数：.isEmpty 和.isNotEmpty。 使用这些函数并不需要对结果再次取非(list.length ! &#x3D;0)</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lunchBox.isEmpty) return &#x27;so hungry...&#x27;;</span><br><span class="line">if (words.isNotEmpty) return words.join(&#x27; &#x27;);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lunchBox.length == 0) return &#x27;so hungry...&#x27;;</span><br><span class="line">if (!words.isEmpty) return words.join(&#x27; &#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="不要使用-List-from-除非想修改结果的类型。"><a href="#不要使用-List-from-除非想修改结果的类型。" class="headerlink" title="不要使用 List.from() 除非想修改结果的类型。"></a>不要使用 List.from() 除非想修改结果的类型。</h3><p>给定一个可迭代的对象，有两种常见方式来生成一个包含相同元素的 list：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var copy1 = iterable.toList();</span><br><span class="line">var copy2 = List.from(iterable);</span><br></pre></td></tr></table></figure>
<p>推荐的写法<br>明显的区别是前一个更短。 更重要的区别在于第一个保留了原始对象的类型参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 List&lt;int&gt;:</span><br><span class="line">var iterable = [1, 2, 3];</span><br><span class="line"> </span><br><span class="line">// 输出 &quot;List&lt;int&gt;&quot;:</span><br><span class="line">print(iterable.toList().runtimeType);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 List&lt;int&gt;:</span><br><span class="line">var iterable = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">// 输出 &quot;List&lt;dynamic&gt;&quot;:</span><br><span class="line">print(List.from(iterable).runtimeType);</span><br></pre></td></tr></table></figure>

<h3 id="如果你想要改变原始对象的类型参数，那么可以调用-List-from-："><a href="#如果你想要改变原始对象的类型参数，那么可以调用-List-from-：" class="headerlink" title="如果你想要改变原始对象的类型参数，那么可以调用 List.from() ："></a>如果你想要改变原始对象的类型参数，那么可以调用 List.from() ：</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2.3, 4]; // List&lt;num&gt;.</span><br><span class="line">numbers.removeAt(1); // 现在集合里只包含int型</span><br><span class="line">var ints = List&lt;int&gt;.from(numbers);</span><br></pre></td></tr></table></figure>
<p>但是如果你的目的只是复制可迭代对象并且保留元素原始类型， 或者并不在乎类型，那么请使用 toList() 。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="使用-x3D-来分隔参数名和参数默认值。"><a href="#使用-x3D-来分隔参数名和参数默认值。" class="headerlink" title="使用 &#x3D; 来分隔参数名和参数默认值。"></a>使用 &#x3D; 来分隔参数名和参数默认值。</h3><p>由于遗留原因，Dart 同时支持 : 和 &#x3D; 作为参数名和默认值的分隔符。 为了与可选的位置参数保持一致，请使用 &#x3D; 。</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert(Object item, &#123;int at = 0&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert(Object item, &#123;int at: 0&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="不要-为字段创建不必要的-getter-和-setter-方法"><a href="#不要-为字段创建不必要的-getter-和-setter-方法" class="headerlink" title="不要 为字段创建不必要的 getter 和 setter 方法"></a>不要 为字段创建不必要的 getter 和 setter 方法</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var _contents;</span><br><span class="line">  get contents =&gt; _contents;</span><br><span class="line">  set contents(value) &#123;</span><br><span class="line">    _contents = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要使用this-在重定向命名函数和避免冲突的情况下除外"><a href="#不要使用this-在重定向命名函数和避免冲突的情况下除外" class="headerlink" title="不要使用this. 在重定向命名函数和避免冲突的情况下除外"></a>不要使用this. 在重定向命名函数和避免冲突的情况下除外</h3><p>只有当局部变量和成员变量名字一样的时候，你才需要使用 this. 来访问成员变量。 只有两种情况需要使用 this. 。其中一种情况是要访问的局部变量和成员变量命名一样的时候：</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var value;</span><br><span class="line"></span><br><span class="line">  void clear() &#123;</span><br><span class="line">    update(null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void update(value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var value;</span><br><span class="line"></span><br><span class="line">  void clear() &#123;</span><br><span class="line">    this.update(null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void update(value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要尽可能的在定义变量的时候初始化变量值。"><a href="#要尽可能的在定义变量的时候初始化变量值。" class="headerlink" title="要尽可能的在定义变量的时候初始化变量值。"></a>要尽可能的在定义变量的时候初始化变量值。</h3><p>如果一个字段不依赖于构造函数中的参数， 则应该在定义的时候就初始化字段值。 这样可以减少需要的代码并可以确保在有多个构造函数的时候你不会忘记初始化该字段。</p>
<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Folder &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final List&lt;Document&gt; contents;</span><br><span class="line"> </span><br><span class="line">  Folder(this.name) : contents = [];</span><br><span class="line">  Folder.temp() : name = &#x27;temporary&#x27;; // Oops! Forgot contents.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Folder &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final List&lt;Document&gt; contents = [];</span><br><span class="line"> </span><br><span class="line">  Folder(this.name);</span><br><span class="line">  Folder.temp() : name = &#x27;temporary&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，对于变量取值依赖构造函数参数的情况以及不同的构造函数取值也不一样的情况， 则不适合本条规则。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="不要-使用-new"><a href="#不要-使用-new" class="headerlink" title="不要 使用 new"></a>不要 使用 new</h3><p>创建对象不要使用new</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Row(</span><br><span class="line">    children: [</span><br><span class="line">      RaisedButton(</span><br><span class="line">        child: Text(&#x27;Increment&#x27;),</span><br><span class="line">      ),</span><br><span class="line">      Text(&#x27;Click!&#x27;),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return new Row(</span><br><span class="line">    children: [</span><br><span class="line">      new RaisedButton(</span><br><span class="line">        child: new Text(&#x27;Increment&#x27;),</span><br><span class="line">      ),</span><br><span class="line">      new Text(&#x27;Click!&#x27;),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要用-来替代空的构造函数体-。"><a href="#要用-来替代空的构造函数体-。" class="headerlink" title="要用 ; 来替代空的构造函数体 {}。"></a>要用 ; 来替代空的构造函数体 {}。</h3><p>在 Dart 中，没有具体函数体的构造函数可以使用分号结尾。 （事实上，这是不可变构造函数的要求。）</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  Point(this.x, this.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  Point(this.x, this.y) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要尽可能的使用初始化形式。"><a href="#要尽可能的使用初始化形式。" class="headerlink" title="要尽可能的使用初始化形式。"></a>要尽可能的使用初始化形式。</h3><p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y;</span><br><span class="line">  Point(num x, num y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y,z;</span><br><span class="line">  Point(this.x, this.y,&#123;this.z&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的位于构造函数参数之前的 this. 语法被称之为初始化形式（initializing formal）。 有些情况下这无法使用这种形式。特别是，这种形式下在初始化列表中无法看到变量。 但是如果能使用该方式，就应该尽量使用。（如果使用命名参数）</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。"><a href="#dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。" class="headerlink" title="dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。"></a>dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。</h3><p>不推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="推荐-使用-async-x2F-await-而不是直接使用底层的特性。"><a href="#推荐-使用-async-x2F-await-而不是直接使用底层的特性。" class="headerlink" title="推荐 使用 async&#x2F;await 而不是直接使用底层的特性。"></a>推荐 使用 async&#x2F;await 而不是直接使用底层的特性。</h3><p>显式的异步代码是非常难以阅读和调试的， 即使使用很好的抽象（比如 future）也是如此。 这就是为何 Dart 提供了 async&#x2F;await。 这样可以显著的提高代码的可读性并且让你可以在异步代码中使用语言提供的所有流程控制语句。</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;int&gt; countActivePlayers(String teamName) async &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var team = await downloadTeam(teamName);</span><br><span class="line">    if (team == null) return 0;</span><br><span class="line"></span><br><span class="line">    var players = await team.roster;</span><br><span class="line">    return players.where((player) =&gt; player.isActive).length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;int&gt; countActivePlayers(String teamName) &#123;</span><br><span class="line">  return downloadTeam(teamName).then((team) &#123;</span><br><span class="line">    if (team == null) return Future.value(0);</span><br><span class="line"></span><br><span class="line">    return team.roster.then((players) &#123;</span><br><span class="line">      return players.where((player) =&gt; player.isActive).length;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).catchError((e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在 Dart 中标识符有三种类型。 • UpperCamelCase 每个单词的首字母都大写，包含第一个单词。 • lowerCamelCase 每个单词的首字母都大写，除了第一个单词， 第一个单词首字母小写，即使是缩略词。 • lowercase_with_underscores 只是用小写字母单词，即使是缩略词， 并且单词之间使用 _ 连接。</p>
<h3 id="使用-UpperCamelCase-风格命名类型。"><a href="#使用-UpperCamelCase-风格命名类型。" class="headerlink" title="使用 UpperCamelCase 风格命名类型。"></a>使用 UpperCamelCase 风格命名类型。</h3><p>Classes（类名）、 enums（枚举类型）、 typedefs（类型定义）、 以及 type parameters（类型参数）应该把每个单词的首字母都大写（包含第一个单词）， 不使用分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SliderMenu &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">class HttpRequest &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">typedef Predicate = bool Function&lt;T&gt;(T value);</span><br></pre></td></tr></table></figure>

<h3 id="要在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名要用-lowercase-with-underscores-风格命名库和源文件名。"><a href="#要在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名要用-lowercase-with-underscores-风格命名库和源文件名。" class="headerlink" title="要在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名要用 lowercase_with_underscores 风格命名库和源文件名。"></a>要在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名要用 lowercase_with_underscores 风格命名库和源文件名。</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library peg_parser.source_scanner;</span><br><span class="line"></span><br><span class="line">import &#x27;file_system.dart&#x27;;</span><br><span class="line">import &#x27;slider_menu.dart&#x27;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library pegparser.SourceScanner;</span><br><span class="line">import &#x27;file-system.dart&#x27;;</span><br><span class="line">import &#x27;SliderMenu.dart&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="要使用-lowercase-with-underscores-风格命名导入的前缀"><a href="#要使用-lowercase-with-underscores-风格命名导入的前缀" class="headerlink" title="要使用 lowercase_with_underscores 风格命名导入的前缀"></a>要使用 lowercase_with_underscores 风格命名导入的前缀</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27; as math;</span><br><span class="line">import &#x27;package:angular_components/angular_components&#x27;</span><br><span class="line">    as angular_components;</span><br><span class="line">import &#x27;package:js/js.dart&#x27; as js;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27; as Math;</span><br><span class="line">import &#x27;package:angular_components/angular_components&#x27;</span><br><span class="line">    as angularComponents;</span><br><span class="line">import &#x27;package:js/js.dart&#x27; as JS;</span><br></pre></td></tr></table></figure>

<h3 id="要-使用-lowerCamelCase-风格来命名其他的标识符。"><a href="#要-使用-lowerCamelCase-风格来命名其他的标识符。" class="headerlink" title="要 使用 lowerCamelCase 风格来命名其他的标识符。"></a>要 使用 lowerCamelCase 风格来命名其他的标识符。</h3><p>类成员、顶级定义、变量、参数以及命名参数等 除了第一个单词，每个单词首字母都应大写，并且不使用分隔符。</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var item;</span><br><span class="line"></span><br><span class="line">HttpRequest httpRequest;</span><br><span class="line"></span><br><span class="line">void align(bool clearItems) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。"><a href="#要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。" class="headerlink" title="要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。"></a>要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。</h3><p>首字母大写缩略词比较难阅读， 特别是多个缩略词连载一起的时候会引起歧义。 例如，一个以 HTTPSFTP 开头的名字， 没有办法判断它是指 HTTPS FTP 还是 HTTP SFTP 。 为了避免上面的情况，缩略词和缩写词要像普通单词一样首字母大写， 两个字母的单词除外。 （像 ID 和 Mr. 这样的双字母缩写词仍然像一般单词一样首字母大写。）</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpConnectionInfo</span><br><span class="line">uiHandler</span><br><span class="line">IOStream</span><br><span class="line">HttpRequest</span><br><span class="line">Id</span><br><span class="line">DB</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPConnection</span><br><span class="line">UiHandler</span><br><span class="line">IoStream</span><br><span class="line">HTTPRequest</span><br><span class="line">ID</span><br><span class="line">Db</span><br></pre></td></tr></table></figure>

<p>• acronyms ：首字母缩略词，指取若干单词首字母组成一个新单词，如：HTTP &#x3D; HyperText Transfer Protocol • abbreviations : 缩写词，指取某一单词的部分字母（或其他缩短单词的方式）代表整个单词，如：ID &#x3D; identification</p>
<h3 id="不要-使用前缀字母"><a href="#不要-使用前缀字母" class="headerlink" title="不要 使用前缀字母"></a>不要 使用前缀字母</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultTimeout</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kDefaultTimeout</span><br></pre></td></tr></table></figure>

<h3 id="要-使用-googlestyle-格式化你的代码"><a href="#要-使用-googlestyle-格式化你的代码" class="headerlink" title="要 使用 googlestyle 格式化你的代码"></a>要 使用 googlestyle 格式化你的代码</h3><p>格式化是一项繁琐的工作，尤其在重构过程中特别耗时。 庆幸的是，你不必担心。 使用Android studio默认的googlestyle。</p>
<h3 id="要对所有流控制结构使用花括号。"><a href="#要对所有流控制结构使用花括号。" class="headerlink" title="要对所有流控制结构使用花括号。"></a>要对所有流控制结构使用花括号。</h3><p>这样可以避免 dangling else （else悬挂）的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (isWeekDay) &#123;</span><br><span class="line">  print(&#x27;Bike to work!&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print(&#x27;Go dancing or read a book!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个例外：一个没有 else 的 if 语句， 并且这个 if 语句以及它的执行体适合在一行中实现。 在这种情况下，如果您愿意，可以不用括号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (arg == null) return defaultValue;</span><br></pre></td></tr></table></figure>

<p>但是，如果执行体包含下一行，请使用大括号：</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (overflowChars != other.overflowChars) &#123;</span><br><span class="line">  return overflowChars &lt; other.overflowChars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (overflowChars != other.overflowChars)</span><br><span class="line">  return overflowChars &lt; other.overflowChars;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
