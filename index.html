<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS, Swift, GitHub, CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>不会飞的小白</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不会飞的小白</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/12/30/OC%E5%85%B6%E5%AE%83/apple%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/30/OC%E5%85%B6%E5%AE%83/apple%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">apple相关文档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-30 13:54:00 / 修改时间：14:39:28" itemprop="dateCreated datePublished" datetime="2022-12-30T13:54:00+08:00">2022-12-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Apple/" itemprop="url" rel="index"><span itemprop="name">Apple</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/cn/app-store/review/guidelines/#design">https://developer.apple.com/cn/app-store/review/guidelines/#design</a></td>
<td>Apple审核文档</td>
</tr>
<tr>
<td>2</td>
<td><a target="_blank" rel="noopener" href="https://help.apple.com/app-store-connect/#/dev28d17ed35">https://help.apple.com/app-store-connect/#/dev28d17ed35</a></td>
<td>App store的操作说明文档</td>
</tr>
<tr>
<td>3</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/">https://developer.apple.com/design/human-interface-guidelines/ios/overview/themes/</a></td>
<td>iOS 人机交互文档</td>
</tr>
<tr>
<td>4</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/wwdc19/">https://developer.apple.com/wwdc19/</a></td>
<td>WWDC 发布视频</td>
</tr>
<tr>
<td>5</td>
<td><a target="_blank" rel="noopener" href="http://appstoreconnect.apple.com/">http://appstoreconnect.apple.com</a></td>
<td>App store 后台</td>
</tr>
<tr>
<td>6</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/account/resources/certificates/list">https://developer.apple.com/account/resources/certificates/list</a></td>
<td>App证书管理后台</td>
</tr>
<tr>
<td>7</td>
<td><a target="_blank" rel="noopener" href="https://idmsa.apple.com/IDMSWebAuth/signin.html?path=/contact/app-store/?topic=expedite&appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757">https://idmsa.apple.com/IDMSWebAuth/signin.html?path=%2Fcontact%2Fapp-store%2F%3Ftopic%3Dexpedite&amp;appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757</a></td>
<td>反馈及申请加速后台</td>
</tr>
<tr>
<td>8</td>
<td>[<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/navigation/#section=Resource%20Types&topic=Sample%20Code]">https://developer.apple.com/library/archive/navigation/#section=Resource%20Types&amp;topic=Sample%20Code]</a>(<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/navigation/#section=Resource">https://developer.apple.com/library/archive/navigation/#section=Resource</a> Types&amp;topic&#x3D;Sample Code)</td>
<td>Apple 官方技术文档</td>
</tr>
<tr>
<td>9</td>
<td><a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/8.0/#/devc8c2a6be1">https://help.apple.com/xcode/mac/8.0/#/devc8c2a6be1</a></td>
<td>Apple开发工具说明文档</td>
</tr>
<tr>
<td>10</td>
<td><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008244-SW1">https://developer.apple.com/library/archive/releasenotes/General/WhatsNewIniOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008244-SW1</a></td>
<td>iOS系统版本文档</td>
</tr>
<tr>
<td>11</td>
<td><a target="_blank" rel="noopener" href="https://appleid.apple.com/account/manage">https://appleid.apple.com/account/manage</a></td>
<td>账号更新、换绑</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/12/28/iOS%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/28/iOS%E6%9E%B6%E6%9E%84/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">软件架构模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-28 16:24:23 / 修改时间：19:22:12" itemprop="dateCreated datePublished" datetime="2022-12-28T16:24:23+08:00">2022-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件架构模式"><a href="#软件架构模式" class="headerlink" title="软件架构模式"></a>软件架构模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对程序员来说很常见一种情况是在没有合理的程序架构时就开始编程，没有一个清晰的和定义好的架构的时候，大多数开发者和架构师通常会使用标准式的传统分层架构模式（也被称为多层架构）——通过将源码模块分割为几个不同的层到不同的包中。不幸的是，这种编码方式会导致一系列没有组织性的代码模块，这些模块缺乏明确的规则、职责和同其他模块之间的关联。这通常被称为架构大泥球。</p>
<p>应用程序缺乏合理的架构一般会导致程序过度耦合、容易被破坏、难以应对变化，同时很难有一个清晰的版本或者方向性。这样的结果是，如果你没有充分理解程序系统里每个组件和模块，就很难定义这个程序的结构特征。有关于程序的部署和维护的基本问题都难以回答，比如：程序架构是什么规模?应用程序有什么性能特点?应用程序有多容易应对变化?应用程序的部署特点是什么?架构是如何反应的?</p>
<p>架构模式帮助你定义应用程序的基本特征和行为。例如，一些架构模式会让程序自己自然而然地朝着具有良好伸缩性的方向发展，而其他架构模式会让程序朝着高度灵活的方向发展。知道了这些特点，了解架构模式的优点和缺点是非常必要的，它帮助我们选择一个适合自己特定的业务需求和目标的的程序。</p>
<p>作为一个架构师,你必须证明你的架构模式的决策是正确的,特别是当需要选择一个特定的体系结构模式或方法的时候。这本迷你书的目的就是给你足够的信息让你去做出正确的架构决策。</p>
<h2 id="第一章-分层架构"><a href="#第一章-分层架构" class="headerlink" title="第一章 分层架构"></a>第一章 分层架构</h2><p>分层架构是一种很常见的架构模式，它也叫N层架构。这种架构是大多数Jave EE应用的实际标准，因此很多的架构师，设计师，还有程序员都知道它。许多传统IT公司的组织架构和分层模式十分的相似。所以它很自然的成为大多数应用的架构模式。</p>
<h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><p>分层架构模式里的组件被分成几个平行的层次，每一层都代表了应用的一个功能(展示逻辑或者业务逻辑)。尽管分层架构没有规定自身要分成几层几种，大多数的结构都分成四个层次:展示层，业务层，持久层，和数据库层。如表1-1，有时候，业务层和持久层会合并成单独的一个业务层，尤其是持久层的逻辑绑定在业务层的组件当中。因此，有一些小的应用可能只有3层，一些有着更复杂的业务的大应用可能有5层或者更多的分层。</p>
<p>分层架构中的每一层都着特定的角色和职能。举个例子，展示层负责处理所有的界面展示以及交互逻辑，业务层负责处理请求对应的业务。架构里的层次是具体工作的高度抽象，它们都是为了实现某种特定的业务请求。比如说展示层并不需要关心怎样得到用户数据，它只需在屏幕上以特定的格式展示信息。业务层并不关心要展示在屏幕上的用户数据格式，也不关心这些用户数据从哪里来。它只需要从持久层得到数据，执行与数据有关的相应业务逻辑，然后把这些信息传递给展示层。</p>
<p><img src="1-1.png" alt="img"></p>
<p>分层架构的一个突出特性是组件间关注点分离 (separation of concerns)。一个层中的组件只会处理本层的逻辑。比如说，展示层的组件只会处理展示逻辑，业务层中的组件只会去处理业务逻辑。多亏了组件分离，让我们更容易构造有效的角色和强力的模型。这样应用变的更好开发，测试，管理和维护。</p>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><p>注意表1-2中每一层都是封闭的。这是分层架构中非常重要的特点。这意味request必须一层一层的传递。举个例子，从展示层传递来的请求首先会传递到业务层，然后传递到持久层，最后才传递到数据层。</p>
<p><img src="1-2.png" alt="img"></p>
<p>那么为什么不允许展示层直接访问数据层呢。如果只是获得以及读取数据，展示层直接访问数据层，比穿过一层一层来得到数据来的快多了。这涉及到一个概念:层隔离。</p>
<p>层隔离就是说架构中的某一层的改变不会影响到其他层:这些变化的影响范围限于当前层次。如果展示层能够直接访问持久层了，假如持久层中的SQL变化了，这对业务层和展示层都有一定的影响。这只会让应用变得紧耦合，组件之间互相依赖。这种架构会非常的难以维护。</p>
<p>从另外一个方面来说，分层隔离使得层与层之间都是相互独立的，架构中的每一层的互相了解都很少。为了说明这个概念的牛逼之处，想象一个超级重构，把展示层从JSP换成JSF。假设展示层和业务层的之间的联系保持一致，业务层不会受到重构的影响，它和展示层所使用的界面架构完全独立。</p>
<p>然而封闭的架构层次也有不便之处，有时候也应该开放某一层。如果想往包含了一些由业务层的组件调用的普通服务组件的架构中添加一个分享服务层。在这个例子里，新建一个服务层通常是一个好主意，因为从架构上来说，它限制了分享服务访问业务层(也不允许访问展示层)。如果没有隔离层，就没有任何架构来限制展示层访问普通服务，难以进行权限管理。</p>
<p>在这个例子中，新的服务层是处于业务层之下的，展示层不能直接访问这个服务层中的组件。但是现在业务层还要通过服务层才能访问到持久层，这一点也不合理。这是分层架构中的老问题了，解决的办法是开放某些层。如表1-3所示，服务层现在是开放的了。请求可以绕过这一层，直接访问这一层下面的层。既然服务层是开放的，业务层可以绕过服务层，直接访问数据持久层。这样就非常合理。</p>
<p><img src="1-3.png" alt="img"></p>
<p>开放和封闭层的概念确定了架构层和请求流之间的关系，并且给设计师和开发人员提供了必要的信息理解架构里各种层之间的访问限制。如果随意的开放或者封闭架构里的层，整个项目可能都是紧耦合，一团糟的。以后也难以测试，维护和部署。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>为了演示分层架构是如何工作的，想象一个场景，如表1-4，用户发出了一个请求要获得客户的信息。黑色的箭头是从数据库中获得用户数据的请求流，红色箭头显示用户数据的返回流的方向。在这个例子中，用户信息由客户数据和订单数组组成(客户下的订单)。</p>
<p>用户界面只管接受请求以及显示客户信息。它不管怎么得到数据的，或者说得到这些数据要用到哪些数据表。如果用户界面接到了一个查询客户信息的请求，它就会转发这个请求给用户委托(Customer Delegate)模块。这个模块能找到业务层里对应的模块处理对应数据(约束关系)。业务层里的customer object聚合了业务请求需要的所有信息(在这个例子里获取客户信息)。这个模块调用持久层中的 customer dao 来得到客户信息，调用order dao来得到订单信息。这些模块会执行SQL语句，然后返回相应的数据给业务层。当 customer object收到数据以后，它就会聚合这些数据然后传递给 customer delegate,然后传递这些数据到customer screen 展示在用户面前。</p>
<p><img src="1-4.png" alt="1-4"></p>
<p>从技术的角度来说，有很多的方式能够实现这些模块。比如说在Java平台中，customer screen 对应的是 (JSF) Java Server Faces ,用 bean 组件来实现 customer delegate。用本地的Spring bean或者远程的EJB3 bean 来实现业务层中的customer object。上例中的数据访问可以用简单的POJP’s(Plain Old Java Objects)，或者可以用MyBatis，还可以用JDBC或者Hibernate 查询。Microsoft平台上，customer screen能用 .NET 库的ASP模块来访问业务层中的C#模块，用ADO来实现用户和订单数据的访问模块。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>分层架构是一个很可靠的架构模式。它适合大多数的应用。如果你不确定在项目中使用什么架构，分层架构是再好不过的了。然后，从架构的角度上来说，选择这个模式还要考虑很多的东西。</p>
<p>第一个要注意的就是 污水池反模式(architecture sinkhole anti-pattern)。 在这个模式中，请求流只是简单的穿过层次，不留一点云彩，或者说只留下一阵青烟。比如说界面层响应了一个获得数据的请求。响应层把这个请求传递给了业务层，业务层也只是传递了这个请求到持久层，持久层对数据库做简单的SQL查询获得用户的数据。这个数据按照原理返回，不会有任何的二次处理，返回到界面上。</p>
<p>每个分层架构或多或少都可能遇到这种场景。关键在于这样的请求有多少。80-20原则可以帮助你确定架构是否处于反污水模式。大概有百分之二十的请求仅仅是做简单的穿越，百分之八十的请求会做一些业务逻辑操作。然而，如果这个比例反过来，大部分的请求都是仅仅穿过层，不做逻辑操作。那么开放一些架构层会比较好。不过由于缺少了层次隔离，项目会变得难以控制。</p>
<h3 id="模式分析-1"><a href="#模式分析-1" class="headerlink" title="模式分析"></a>模式分析</h3><p>下面的的表里分析了分层架构的各个方面。</p>
<h5 id="整体灵活性"><a href="#整体灵活性" class="headerlink" title="整体灵活性"></a>整体灵活性</h5><p>评级:低<br> 分析:总体灵活性是响应环境变化的能力。尽管分层模式中的变化可以隔绝起来，想在这种架构中做一些也改变也是并且费时费力的。分层模式的笨重以及经常出现的组件之间的紧耦合是导致灵活性降低的原因。</p>
<h4 id="易于部署"><a href="#易于部署" class="headerlink" title="易于部署"></a>易于部署</h4><p>评级:低<br> 分析:这取决于你怎么发布这种模式，发布程序可能比较麻烦，尤其是很大的项目。一个组件的小小改动可能会影响到整个程序的发布(或者程序的大部分)。发布必须是按照计划，在非工作时间或者周末进行发布。因此。分层模式导致应用发布一点也不流畅，在发布上降低了灵活性。</p>
<h4 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h4><p>评级:高<br> 分析:因为组件都处于各自的层次中，可以模拟其他的层，或者说直接去掉层，所以分层模式很容易测试。开发者可以单独模拟一个展示组件，对业务组件进行隔绝测试。还可以模拟业务层来测试某个展示功能。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>评级:低<br> 分析:尽管某些分层架构的性能表现的确不错，但是这个模式的特点导致它无法带来高性能。因为一次业务请求要穿越所有的架构层，做了很多不必要的工作。</p>
<h4 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评级:低<br> 分析:由于这种模式以紧密耦合的趋势在发展，规模也比较大，用分层架构构建的程序都比较难以扩展。你可以把各个层分成单独的物理模块或者干脆把整个程序分成多个节点来扩展分层架构，但是总体的关系过于紧密，这样很难扩展。</p>
<h4 id="易开发性"><a href="#易开发性" class="headerlink" title="易开发性"></a>易开发性</h4><p>评级:容易<br> 分析:在开发难度上面，分层架构得到了比较高的分数。因为这种架构对大家来说很熟悉，不难实现。大部分公司在开发项目的都是通过层来区分技术的，这种模式对于大多数的商业项目开发来说都很合适。公司的组织架构和他们软件架构之间的联系被戏称为”Conway’s law”。你可以Google一下查查这个有趣的联系。</p>
<h2 id="第二章-事件驱动架构"><a href="#第二章-事件驱动架构" class="headerlink" title="第二章 事件驱动架构"></a>第二章 事件驱动架构</h2><blockquote>
<p>译者注：文章中 mediator 及 broker 的概念很容易混淆，在文章的结尾处译者对两者的区别（还有 proxy）进行了一定的阐述</p>
</blockquote>
<p>事件驱动架构模式是一种主流的异步分发事件架构模式，常用于设计高度可拓展的应用。当然了，它有很高的适应性，使得它在小型应用、大型应用、复杂应用中都能表现得很好。事件驱动架构模式由高度解耦、单一目的的事件处理组件构成，这些组件负责异步接收和处理事件。</p>
<p>事件驱动架构模式包含了两种主要的拓扑结构：**中介(mediator)<strong>拓扑结构和</strong>代理(broker)**拓扑结构。 mediator 拓扑结构通常在你需要在事件内使用一个核心中介分配、协调多个步骤间的关系、执行顺序时使用；而代理拓扑结构则在你想要不通过一个核心中介将多个事件串联在一起时使用。由于这两种结构在结构特征和实现策略上有很大的差别，所以如果你想要在你的应用中使用它们的话，一定要深入理解两者的技术实现细节，从而为你的实际使用场景选择最合理的结构。</p>
<h3 id="中介-Mediator-拓扑结构"><a href="#中介-Mediator-拓扑结构" class="headerlink" title="中介 ( Mediator )拓扑结构"></a>中介 ( Mediator )拓扑结构</h3><p>中介拓扑结构适合用于拥有多个步骤，并需要在处理事件时能通过某种程度的协调将事件分层的场景，举例来说吧：假设你现在需要进行股票交易，那你首先需要证券所批准你进行交易，然后检查进行这次交易是否违反了股票交易的某种规定，检查完成后将它交给一个经纪人，计算佣金，最后与经纪人确认交易。以上所有步骤都需要通过中介进行某种程度的分配和协调，以决定各个步骤的执行顺序，判断哪些步骤可以并行，哪些步骤可以串行。</p>
<p>在中介拓扑结构中主要有四种组件：事件队列（event queue）, 事件中介, 事件通道（event channel）, 和 事件处理器（event processor）。当事件流需要被处理，客户端将一个事件发送到某个事件队列中，由消息队列将其运输给事件中介进行处理和分发。事件中介接收到该消息后，并通过将额外的异步事件发送给事件通道，让事件通道执行该异步事件中的每一个步骤，使得事件中介能够对事件进行分配、协调。同时，又因为事件处理器是事件通道的监听器，所以事件通道对异步事件的处理会触发事件处理器的监听事件，使事件处理器能够接收来自事件中介的事件，执行事件中具体的业务逻辑，从而完成对传入事件的处理。事件驱动架构模式中的中介拓扑模式结构大体如下图：</p>
<p><img src="2-1.png" alt="2-1"></p>
<p>在事件驱动架构中拥有十几个，甚至几百个事件队列是很常见的情况，该模式并没有对事件队列的实现有明确的要求，这就意味着事件队列可以是消息队列，Web 服务端，或者其它类似的东西。</p>
<p>在事件驱动架构模式中主要有两种事件：初始事件和待处理事件。初始事件是中介所接收到的最原始的事件，没有经过其他组件的处理；而待处理事件是由事件中介生成，由事件处理器接收的组件，不能把待处理事件看作初始事件经过处理后得到的事件，两者是完全不同的概念。</p>
<p>事件中介负责分配、协调初始事件中的各个待执行步骤，事件中介需要为每一个初始事件中的步骤发送一个特定的待处理事件到事件通道中，触发事件处理器接收和处理该待处理事件。这里需要注意的是：事件 中介没有真正参与到对初始事件必须处理的业务逻辑的实现之中；相反，事件中介只是知道初始事件中有哪些步骤需要被处理。</p>
<p>事件中介通过事件通道将与初始事件每一个执行步骤相关联的特定待处理事件传递给事件处理器。尽管我们通常在待处理事件能被多个事件处理器处理时才会在中介拓扑结构中使用 消息主题，但事件通道仍可以是消息队列或 消息主题。（但需要注意的是，尽管在使用 消息主题 时待处理事件能被多个事件处理器处理，但由于接收到的待处理事件各异，所以对其处理的操作也各不相同）</p>
<p>为了能顺利处理待处理事件，事件处理器组件中包含了应用的业务逻辑。此外，事件处理器作为事件驱动架构中的组件，不依赖于其他组件，独立运作，高度解耦，在应用或系统中完成特定的任务。当事件处理器需要处理的事件从细粒度（例如：计算订单的营业税）变为粗粒度（例如：处理一项保险索赔事务），必须要注意的是：一般来说，每一个事件处理器组件都只完成一项唯一的业务工作，并且事件处理器在完成其特定的业务工作时不能依赖其他事件处理器。</p>
<p>虽然事件中介有许多方法可以实现，但作为一名架构工程师，你应该了解所有实现方式，以确保你能为你的实际需求选择了最合适的事件中介。</p>
<p>事件中介最简单、常见的实现就是使用开源框架，例如：Spring Integration，Apache Camel，或 Mule ESB。事件流在这些开源框架中通常用 Java 或 域特定语言（domain-specific language）。在调节过程和业务流程都很复杂的使用场景下，你可以使用业务流程执行语言（BPEL - business process execution language）结合类似开源框架 Apache ODE 的 BPEL 引擎进行开发。BPEL 是一种基于 XML 的服务编制编程语言，它为处理初始事件时需要描述的数据和步骤提供了描述。对每一个拥有复杂业务流程（包括与用户交互的执行步骤）的大型应用来说，你可以使用类似 jBPM 的业务处理管理系统（business process manager）实现事件中介。</p>
<p>如果你需要使用中介拓扑结构，那么理解你的需求，并为其匹配恰当的事件中介实现是构建事件驱动架构过程中至关重要的一环。使用开源框架去解决非常复杂的业务处理、管理、调节事件，注定会失败，因为开源框架只是用 BPM 的方式解决了一些简单的事件分发逻辑，比起你的业务逻辑，其中的事件分发逻辑简直是九牛一毛。</p>
<p>为了解释清楚中介拓扑结构是怎么运作的，我假设你在某家保险公司买了保险，成为了受保人，然后你打算搬家。在这种情况下，初始事件就是重定位事件，或者其他类似的事件。与重定位事件相关的处理步骤就像下图展示的那样，处于事件中介之中。对每一个初始事件的传入，事件中介都会创建一个待处理事件（例如：改变地址，重新计算保险报价，等等……），并将它发送给事件通道，等待发出响应的事件处理器处理待处理事件（例如：客户改变地址的操作流程、报价计算流程，等等……）。直到初始事件中的每一个需要处理的步骤完成了，这项处理才会继续（例如：把所有手续都完成之后，保险公司才会帮你改变地址）。事件中介中，重新报价和更新理赔步骤上面的直线表示这些步骤可以并行处理。</p>
<p><img src="2-2.png" alt="2-1"></p>
<h3 id="代理-Broker-拓扑结构"><a href="#代理-Broker-拓扑结构" class="headerlink" title="代理 (Broker) 拓扑结构"></a>代理 (Broker) 拓扑结构</h3><p>代理拓扑结构与中介拓扑结构不同之处在于：代理拓扑结构中没有核心的事件中介；相反，事件流在代理拓扑结构中通过一个轻量的消息代理（例如：ActiveMQ, HornetQ，等等……）将消息串联成链状，分发至事件处理器组件中进行处理。代理扑结构适用的使用场景大致上具有以下特征：你的事件处理流相对来说比较简单，而且你不想（不需要）使用核心的事件分配、调节机制以提高你处理事件的效率。</p>
<p>在代理拓扑结构中主要包括两种组件：代理和事件处理器。代理可被集中或相互关联在一起使用，此外，代理中还可以包含所有事件流中使用的事件通道。</p>
<p>存在于代理组件中的事件通道可以是消息队列，消息主题,或者是两者的组合。</p>
<p>代理拓扑结构大致如下图，如你所见，在这其中没有一个核心的事件中介组件控制和分发初始事件；相反，每一个事件处理器只负责处理一个事件，并向外发送一个事件，以标明其刚刚执行的动作。例如，假设存在一个事件处理器用于平衡证券交易，那么事件处理器可能会接受一个拆分股票的初始事件，为了处理这项初始事件，事件处理器则需要重新平衡股票的投资金额，而这个重新平衡的事件将由另一个事件处理器接收、处理。在这其中有一个细节需要注意：处理初始事件后，由事件处理器发出的事件不被其他事件处理器接收、处理的情况时常会发生，尤其是你在为应用添加功能和进行功能拓展时，这种情况更为常见。</p>
<p><img src="2-3.png" alt="2-3"></p>
<p>为了阐明代理拓扑结构的运行机制，我会用一个与讲解中介拓扑结构时类似的例子（受保人旅行的例子）进行解释。因为在代理拓扑结构中没有核心事件中介接收初始事件，那么事件将由客户处理组件直接接收，改变客户的地址，并发出一个事件告知系统客户的地址被其进行了改变（例如：改变地址的事件）。在这个例子中：有两个事件处理器会与改变地址的事件产生关联：报价处理和索赔处理。报价事件处理器将根据受保人的新地址重新计算保险的金额，并发出事件告知系统该受保人的保险金额被其改变。而索赔事件处理器将接受到相同的改变地址事件，不同的是，它将更新保险的赔偿金额，并发出一个更新索赔金额事件告知系统该受保人的赔偿金额被其改变。当这些新的事件被其他事件处理器接收、处理，使事件链一环扣一环地交由系统处理，直到事件链上的所有事件都被处理完，初始事件的处理才算完成。</p>
<p><img src="2-4.png" alt="2-4"></p>
<p>如上图所示，代理拓扑结构的设计思想就是将对事件流的处理转换为对事件链的业务功能处理，把代理拓扑结构看作是接力比赛是最好的理解方式：在一场4*100的接力比赛中，每一位运动员都需要拿着一根接力棒跑100米，运动员跑完自己的100米后需要将接力棒传递给下一位运动员，直到最后一位运动员拿着接力棒跑过终点线，整场接力比赛才算结束。根据这样的逻辑我们还可以知道：在代理拓扑结构中，一旦某个事件处理器将事件传递给另一个事件处理器，那么这个事件处理器不会与该事件的后续处理产生任何联系。</p>
<h3 id="顾虑"><a href="#顾虑" class="headerlink" title="顾虑"></a>顾虑</h3><p>实现事件驱动架构模式相对于实现其他架构模式会更困难一些，因为它通过异步处理进行事件分发。当你需要在你的应用中使用这种架构模式，你必须处理各种由事件分发处理带来的问题，例如：远程操作功能的可用性，缺少权限，以及在代理或中介中处理事件失败时，用于处理这种情况的重连逻辑。如果你不能很好地解决这些问题，那你的应用一定会出现各种 Bug，让开发团队痛苦不已。</p>
<p>在选择事件驱动架构时还有一点需要注意：在处理单个业务逻辑时，这种架构模式不能处理细粒度的事务。因为事件处理器都高度解耦、并且广泛分布，这使得在这些事件处理器中维持一个业务单元变得非常困难。因此，当你使用这种架构模式架构你的应用时，你必须不断地考虑哪些事件能单独被处理，哪些不能，并为此设计相应事件处理器的处理粒度。如果你发现你需要将一个业务单元切割成许多子单元，并一一匹配相应的事件处理器，那你就要为此进行代码设计；如果你发现你用多个不同的事件处理器处理的哪些业务其实是可以合并到一个业务事件之中的，那么这种模式可能并不适合你的应用，又或者是你的设计出了问题。</p>
<p>使用事件驱动架构模式最困难的地方就在于架构的创建、维护、以及对事件处理器的管理。通常每一个事件都拥有其指定的事件处理协议（例如：传递给事件处理器的数据类型、数据格式），这就使得设下标准的数据格式成为使用事件驱动架构模式中至关重要的一环（例如：XML，JSON，Java 对象，等等……），并在架构创建之初就为这些数据格式授权，以便处理。</p>
<h3 id="模式分析-2"><a href="#模式分析-2" class="headerlink" title="模式分析"></a>模式分析</h3><p>下面是基于对常见的架构模式特征进行评价的标准，对事件驱动架构模式所作的实际分析，评价是以常见的架构模式的相似实现作为标准进行的，如果你想知道进行对比的其他架构模式对应的特征，可以结尾处查看  <a href="#appendix">附录A</a> 的汇总表。</p>
<h4 id="整体灵活性-1"><a href="#整体灵活性-1" class="headerlink" title="整体灵活性"></a>整体灵活性</h4><p>评价：高<br> 分析：整体灵活性用于评价架构能否在不断改变的使用场景下快速响应，因为事件处理器组件使用目的单一、高度解耦、与其他事件处理器组件相互独立，不相关联，那么发生的改变对一个或多个事件处理器来说普遍都是独立的，使得对改变的反馈非常迅速，不需要依赖其他事件处理器的响应作出处理。</p>
<h4 id="易于部署-1"><a href="#易于部署-1" class="headerlink" title="易于部署"></a>易于部署</h4><p>评价：高<br> 分析：总的来看，事件驱动架构模式由于其高度解耦的事件处理器组件的存在，对事件的部署相对来说比较容易，而使用代理拓扑结构比使用中介拓扑结构进行事件调度会更容易一些，主要是因为在 中介拓扑结构中事件处理器与事件中介紧密地耦合在一起：事件处理器中发生改变后，事件中介也随之改变，如果我们需要改变某个被处理的事件，那么我们需要同时调度事件处理器和事件中介。</p>
<h4 id="可测试性-1"><a href="#可测试性-1" class="headerlink" title="可测试性"></a>可测试性</h4><p>评价：低<br> 分析：虽然在事件驱动架构模式中进行单元测试并不困难，但如果我们要进行单元测试，我们就需要某种特定的测试客户端或者是测试工具产生事件，为单元测试提供初始值。此外，由于事件驱动架构模式是异步进行事件分发的，其异步处理的特性也为单元测试带来了一定的困难。</p>
<h4 id="Performance-性能"><a href="#Performance-性能" class="headerlink" title="Performance 性能"></a>Performance 性能</h4><p>评价：高<br> 分析：对消息传递的架构可能会让设计出来的事件驱动架构的表现不如我们的期望，但通常来说，该模式都能通过其异步处理的特性展示优秀的性能表现；换句话来说，高度解耦，异步并行操作大大减少了传递消息过程中带来的时间开销。</p>
<h4 id="伸缩性-1"><a href="#伸缩性-1" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评价：高<br> 分析：事件驱动架构中的高度解耦、相互独立的事件处理器组件的存在，使得可拓展性成为该架构与生俱来的优点。架构的这些特定使得事件处理器能够进行细粒度的拓展，使得每一个事件处理器都能单独被拓展，而不影响其他事件处理器。</p>
<h4 id="易于开发"><a href="#易于开发" class="headerlink" title="易于开发"></a>易于开发</h4><p>评价：低<br> 分析：由于使用事件驱动架构进行开发需要考虑其异步处理机制、协议创建流程，并且开发者需要用代码为事件处理器和操作失败的代理提供优秀的错误控制环境，无疑使得用事件驱动架构进行开发会比使用其他架构进行开发要困难一些。</p>
<h3 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h3><p>读完整篇文章，我相信大家对 mediator 与 broker 这两个概念有一个大致的印象，但就两者的译文来看，中介和代理似乎没什么区别，尤其是了解 proxy 的读者会更加困惑，这三者之间到底是什么关系？它们的概念是互通的吗？为了解决这种混淆，译者将在此阐述三者间的区别：</p>
<p>假如现在我有一个事件&#x2F;事件流需要被处理，那么使用 mediator、broker、proxy 处理事件的区别在哪里呢？</p>
<ul>
<li>如果我们使用 mediator，那就意味着我将把事件流交给 mediator，mediator 会帮我把事件分解为多个步骤，并分析其中的执行逻辑，调整和分发事件（例如判断哪些事件可以并行，哪些事件可以串行），然后根据 mediator 分解、调节的结果去执行事件中的每一个步骤，把所有步骤完成后，就能把需要处理的事件处理好。</li>
<li>如果我们使用 broker，那就意味着我将把事件交给 broker，broker 获得事件后会把事件发出去（在本文中为：通知架构中所有可用的事件处理器），事件处理器们接收到事件以后，判断处理这个事件是否为自己的职责之一，如果不是则无视，与自己有关则把需要完成的工作完成，完成后如果事件还有后续需要处理的事件，则通过 broker 再次发布，再由相关的事件处理器接收、处理。以这样的方式将事件不断分解，沿着事件链一级一级地向下处理子事件，直到事件链中的所有事件被完成，我的事件也就处理好了。</li>
<li>如果我们使用 proxy，那就意味着我自己对需要处理的事件进行了分解，然后把不同的子事件一一委托给不同的 proxy，由被委托的 proxy 帮我完成子事件，从而完成我要做的事件。</li>
</ul>
<h2 id="第三章-微内核架构"><a href="#第三章-微内核架构" class="headerlink" title="第三章 微内核架构"></a>第三章 微内核架构</h2><p>微内核架构模式(也称为插件化应用架构)对于基于产品的应用程序来说是一个很自然的选择。基于产品的应用是指一个经过打包的、可以通过版本下载的一个典型的第三方产品。然而，很多公司也会开发和发布他们的内部商业软件，完整的版本号、发布日志和可插拔的新特性，这些就非常符合微内核架构的思想。微内核架构模式可以通过插件的形式添加额外的特性到核心系统中，这提供了很好的扩展性，也使得新特性与核心系统隔离开来。( 译者注: 比如，著名的Eclipse IDE就是基于插件化开发的，eclipse核心更像是一个微内核，或者我们可把它叫做开放平台，其他的功能通过安装插件的形式添加到eclipse中。 )</p>
<h3 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h3><p>微内核架构主要需要考虑两个方面: 核心系统和插件模块。应用逻辑被划分为独立的插件模块和核心系统，这样就提供良好的可扩展性、灵活性，应用的新特性和自定义处理逻辑也会被隔离。图3-1演示了基本的微内核架构。</p>
<p>微内核架构的核心系统一般情况下只包含一个能够使系统运作起来的最小化模块。很多操作系统的实现就是使用微内核架构，因此这也是该架构名字的由来。从商业应用的角度看，核心系统通常是为特定的使用场景、规则、或者复杂条件处理定义了通用的业务逻辑，而插件模块根据这些规则实现了具体的业务逻辑。</p>
<p><img src="3-1.png" alt="3-1"></p>
<p>插件模块是一个包含专业处理、额外特性的独立组件，自定义代码意味着增加或者扩展核心系统以达到产生附加的业务逻辑的能力。通常，插件模块之间应该是没有任何依赖性的，但是你也可以设计一个需要依赖另一个插件的插件。但无论如何，使得插件之间可以通信的同时避免插件之间产生依赖又是一个特别重要的问题。</p>
<p>核心系统需要了解插件模块的可用性以及如何获取到它们。一个通用的实现方法是通过一组插件注册表。这个插件注册表含有每个插件模块的信息，包括它的名字、数据规约和远程访问协议(取决于插件如何与核心系统建立连接)。例如，一个税务软件的用于标识高风险的税务审计插件可能会有一个含有插件名(比如AuditChecker)的注册入口，数据规约(输入数据、输出数据)和规约格式( 比如xml )。如果这个插件是通过SOAP服务访问，那么它可能会包含一个WSDL (Web Services Definition Language).</p>
<p>插件模块可以通过多种方式连接到核心系统，包括OSGi ( open service gateway initiative )、消息机制、web服务或者直接点对点的绑定 ( 比如对象实例化，即依赖注入 )。你使用的连接类型取决于你构建的应用类型和你的特殊需求（比如单机部署还是分布式部署）。微内核架构本身没有指定任何的实现方式，唯一的规定就是插件模块之间不要产生依赖。</p>
<p>插件和核心系统的通信规范包含标准规范和自定义规范。自定义规范典型的使用场景是插件组件是被第三方构建的。在这种情况下，通常是在第三方插件规约和你的标准规范创建一个Adapter来使核心系统根本不需要知道每个插件的具体细节。当创建标准规范 ( 通常是通过XML或者Java Map )时，从一开始就创建一个版本策略是非常重要的。</p>
<h3 id="架构示例"><a href="#架构示例" class="headerlink" title="架构示例"></a>架构示例</h3><p>也许微内核架构的最好示例就是大家熟知的Eclipse IDE了。下载最基本的Eclipse后，它只能提供一个编辑器。然后，一旦你开始添加插件，它就变成一个高度可定制化和非常有用的产品（译者注 : 更多内容大家可以参考 <a target="_blank" rel="noopener" href="http://www.ituring.com.cn/article/6817">开源软件架构 卷1：第6章 Eclipse之一</a> ）。浏览器是另一个使用微内核架构的产品示例，它由一个查看器和其他扩展的插件组成。</p>
<p>基于微内核架构的示例数不胜数，但是大型的商业应用呢？微内核应用架构也适用于这些情形。为了阐述这个观点，让我们来看看另一个保险公司的示例，但是这次的示例会涉及保险赔偿处理。</p>
<p>赔偿处理是一个非常复杂的过程。每个州都有不同的关于保险赔偿的规则和条文。例如一些州允许在你的挡风玻璃被石头砸碎时免费进行替换，但是一些州则不是这样。因为大家的标准都不一样，因此赔偿标准几乎可以是无限的。</p>
<p>有很多保险赔偿应用运用大型和复杂的规则处理引擎来处理不同规则带来的复杂性。然而，可能会因为某条规则的改变而引起其他规则的改变而使得这些规则处理引擎变成一个大泥球，或者使简单需求变更会需要一个很大的分析师、工程师、测试工程师来进行处理。使用微内核架构能够很好的解决这个问题，核心系统只知道根据赔偿规则处理，但这个赔偿规则是抽象的，系统将赔偿规则作为一个插件规范，具体的规则有对应的实现，然后注入到系统中即可。</p>
<p>图3-2中的一堆文件夹代表了赔偿处理核心系统。它包含一些处理保险赔偿的基本业务逻辑。每一个插件模块包含每个州的具体赔偿规则。在这个例子中，插件模块通过自定义源代码实现或者分离规则引起实例。不管具体实现如何，关键就在于赔偿规则和处理都从核心系统中分离，而这些规则和处理过程都可以被动态地添加、移除，而这些改变对于核心系统和其他插件只有很小的影响或者根本不产生影响。</p>
<p><img src="3-2.png" alt="3-2"></p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>对于微内核架构来说一个很重要的一点就是它能够被嵌入或者说作为另一种架构的一部分。例如，如果这个架构解决的是一个你应用中易变领域的特定的问题 ( 译者注 : 即插件化能够解决你应用中的某个特定模块的架构问题 )，你可能会发现你不能在整个应用中使用这种架构。在这种情况下，你可以将微内核架构嵌入到另一个架构模式中 ( 比如分层架构 )。同样的，在上一章节中描述的事件驱动架构中的事件处理器组件也可以使用微内核架构。</p>
<p>微内核架构对渐进式设计和增量开发提供了非常好的支持。你可以先构建一个单纯的核心系统，随着应用的演进，系统会逐渐添加越来越多的特性和功能，而这并不会引起核心系统的重大变化。</p>
<p>对基于产品的应用来说，微内核架构应该是你的第一选择。特别是那些你会在后续开发中发布附加特性和控制哪些用户能够获取哪些特性的应用。如果你在后续开发中发现这个架构不能满足你的需求了，你能够根据你的特殊需求将你的应用重构为另一个更好的架构。</p>
<h3 id="模式分析-3"><a href="#模式分析-3" class="headerlink" title="模式分析"></a>模式分析</h3><p>下面的表格中包含了微内核架构每个特性的评级和分析。以微内核架构的最经典的实现方式的自然趋势为依据对每个特性进行评级。关于微内核架构与其他模式的相关性比较请参考附录A。</p>
<h4 id="整体灵活性-2"><a href="#整体灵活性-2" class="headerlink" title="整体灵活性"></a>整体灵活性</h4><p>评级 : 高<br> 分析 : 整体灵活性是指能够快速适应不断变化的环境的能力。通过插件模块的松耦合实现，可以将变化隔离起来，并且快速满足需求。通常，微内核架构的核心系统很快趋于稳定，这样系统就变得很健壮，随着时间的推移它也不会发生多大改变。</p>
<h4 id="易于部署-2"><a href="#易于部署-2" class="headerlink" title="易于部署"></a>易于部署</h4><p>评级 : 高<br> 分析 : 根据实现方式，插件模块能够在运行时被动态地添加到核心系统中 （ 比如，热部署 ）,把停机时间减到最小。</p>
<h4 id="可测试性-2"><a href="#可测试性-2" class="headerlink" title="可测试性"></a>可测试性</h4><p>评级 : 高<br> 分析 : 插件模块能够被独立的测试，能够非常简单地被核心系统模拟出来进行演示，或者在对核心系统很小影响甚至没有影响的情况下对一个特定的特性进行原型展示。</p>
<h4 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h4><p>评级 : 高<br> 分析 : 使用微内核架构不会自然而然地使你的应用变得高性能。通常，很多使用微内核架构的应用运行得很好，因为你能定制和简化应用程序，使它只包含那些你需要的功能模块。JBoss应用服务器就是这方面的优秀示例: 依赖于它的插件化架构，你可以只加载你需要的功能模块，移除那些消耗资源但没有使用的功能特性，比如远程访问，消息传递，消耗内存、CPU的缓存，以及线程，从而减小应用服务器的资源消耗。</p>
<h4 id="伸缩性-2"><a href="#伸缩性-2" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评级 : 低<br> 分析 : 因为微内核架构的实现是基于产品的，它通常都比较小。它们以独立单元的形式实现，因此没有太高的伸缩性。此时，伸缩性就取决于你的插件模块，有时你可以在插件级别上提供可伸缩性，但是总的来说这个架构并不是以构建高度伸缩性的应用而著称的。</p>
<h4 id="易于开发-1"><a href="#易于开发-1" class="headerlink" title="易于开发"></a>易于开发</h4><p>评级 : 低<br> 分析 : 微内核架构需要考虑设计和规约管理，使它不会很难实现。规约的版本控制，内部的插件注册，插件粒度，丰富的插件连接的方式等是涉及到这个架构模式实现复杂度的重要因素。</p>
<h2 id="第四章-微服务架构"><a href="#第四章-微服务架构" class="headerlink" title="第四章 微服务架构"></a>第四章 微服务架构</h2><p>微服务架构模式作为替代单体应用和面向服务架构的一个可行的选择，在业内迅速取得进展。由于这个架构模式仍然在不断的发展中，在业界存在很多困惑——这种模式是关于什么的？它是如何实现的？本报告的这部分将为你提供关键概念和必要的基础知识来理解这一重要架构模式的好处(和取舍)，以此来判断这种架构是否适合你的应用。</p>
<h3 id="模式描述-1"><a href="#模式描述-1" class="headerlink" title="模式描述"></a>模式描述</h3><p>不管你选择哪种拓扑或实现风格,有几种常见的核心概念适用于一般架构模式。第一个概念是<em>单独部署单元</em>。如图4-1所示，微服务架构的每个组件都作为一个独立单元进行部署，让每个单元可以通过有效、简化的传输管道进行通信，同时它还有很强的扩展性，应用和组件之间高度解耦，使得部署更为简单。</p>
<p>也许要理解这种模式，最重要的概念就是服务组件（service component）。不要考虑微服务架构内部的服务，而最好是考虑服务组件，从粒度上讲它可以小到单一的模块，或者大至一个应用程序。服务组件包含一个或多个模块（如Java类），这些模块可以提供一个单一功能（如，为特定的城市或城镇提供天气情况），或也可以作为一个大型商业应用的一个独立部分（如，股票交易布局或测定汽车保险的费率）。在微服务架构中，正确设计服务组件的粒度是一个很大的挑战。在接下来的服务组件部分对这一挑战进行了详细的讨论。</p>
<p><img src="4-1.png" alt="4-1"></p>
<p>微服务架构模式的另一个关键概念是它是一个<em>分布式</em>的架构，这意味着架构内部的所有组件之间是完全解耦的，并通过某种远程访问协议（如， JMS, AMQP, REST, SOAP, RMI等）进行访问。这种架构的分布式特性是它实现一些优越的可扩展性和部署特性的关键所在。</p>
<p>微服务架构另一个令人兴奋的特性是它是由其他常见架构模式存在的问题演化来的，而不是作为一个解决方案被创造出来等待问题出现。微服务架构的演化有两个主要来源：使用分层架构模式的单体应用和使用面向服务架构的分布式应用。</p>
<p>由单体应用( 一个应用就是一个整体 )到微服务的发展过程主要是由持续交付开发促成的。从开发到生产的持续部署管道概念,简化了应用程序的部署。单体应用通常是由紧耦合的组件组成，这些组件同时又是另一个单一可部署单元的一部分，这使得它繁琐，难以改变、测试和部署应用（因此常见的“月度部署”周期出现并通常发生在大型IT商店项目）。这些因素通常会导致应用变得脆弱以至于每次有一点新功能部署后应用就不能运行。微服务架构模式通过将应用分隔成多个可部署的单元（服务组件）的方法来解决这一问题，这些服务组件可以独立于其他服务组件进行单独开发、测试和部署。</p>
<p>另一个导致微服务架构模式产生的演化过程是由面向服务架构模式（SOA）应用程序存在的问题引起的。虽然SOA模式非常强大，提供了无与伦比的抽象级别、异构连接、服务编排，并保证通过IT能力调整业务目标，但它仍然是复杂的,昂贵的,普遍存在，它很难理解和实现，对大多数应用程序来说过犹不及。微服务架构通过简化服务概念，消除编排需求、简化服务组件连接和访问来解决复杂度问题。</p>
<h3 id="模式拓扑"><a href="#模式拓扑" class="headerlink" title="模式拓扑"></a>模式拓扑</h3><p>虽然有很多方法来实现微服务架构模式,但三个主要的拓扑结构脱颖而出，最常见和流行的有:基于REST API的拓扑结构,基于REST的应用拓扑结构和集中式消息拓扑结构。</p>
<p>基于REST的API拓扑适用于网站，通过某些API对外提供小型的、自包含的服务。这种拓扑结构,如图4 - 2所示,由粒度非常细的服务组件（因此得名微服务）组成，这些服务组件包含一个或两个模块并独立于其他服务来执行特定业务功能。在这种拓结构扑中,这些细粒度的服务组件通常被REST-based的接口访问，而这个接口是通过一个单独部署的web API层实现的。此种拓扑的例子包含一些常见的专用的、基于云的RESTful web service，大型网站像Yahoo, Google, and Amazon都在使用。</p>
<p><img src="4-2.png" alt="4-2"></p>
<p>基于REST的应用拓扑结构与基于REST API的不同，它通过传统的基于web的或胖客户端业务应用来接收客户端请求，而不是通过一个简单的API层。如图4-3所示，应用的用户接口层（user interface layer）是一个web应用，可以通过简单的REST-based接口访问单独部署的服务组件（业务功能）。该拓扑结构中的服务组件与API-REST-based拓扑结构中的不同，这些服务组件往往会更大、粒度更粗、代表整个业务应用程序的一小部分，而不是细粒度的、单一操作的服务。这种拓扑结构常见于中小型企业等复程度相对较低的应用程序。</p>
<p><img src="4-3.png" alt="4-3"></p>
<p>微服务架构模式中另一个常见的方法是集中式消息拓扑。该拓扑（如图4-4所示）与前面提到的基于REST的应用拓扑类似，不同的是，application REST- based拓扑结构使用REST进行远程访问，而该拓扑结构则使用一个轻量级的集中式消息代理（如，ActiveMQ, HornetQ等等）。不要将该拓扑与面向服务架构模式混淆或将其当做SOA简化版（“SOA-Lite”），这点是极其重要的。该拓扑中的轻量级消息代理（Lightweight Message Broker）不执行任何编排,转换,或复杂的路由;相反,它只是一个轻量级访问远程服务组件的传输工具。</p>
<p>集中式消息拓扑结构通常应用在较大的业务应用程序中，或对于某些对传输层到用户接口层或者到服务组件层有较复杂的控制逻辑的应用程序中。该拓扑较之先前讨论的简单基于REST的拓扑结构，其好处是有先进的排队机制、异步消息传递、监控、错误处理和更好的负载均衡和可扩展性。与集中式代理相关的单点故障和架构瓶颈问题已通过代理集群和代理联盟（将一个代理实例为分多个代理实例，把基于系统功能区域的吞吐量负载划分开处理）解决。</p>
<p><img src="4-4.png" alt="4-4"></p>
<h3 id="避免依赖和编排"><a href="#避免依赖和编排" class="headerlink" title="避免依赖和编排"></a>避免依赖和编排</h3><p>微服务架构模式的主要挑战之一就是决定服务组件的粒度级别。如果服务组件粒度过粗，那你可能不会意识到这个架构模式带来的好处（部署、可扩展性、可测试性和松耦合），然而,服务组件粒度过细将导致服务编制要求,这会很快导致将微服务架构模式变成一个复杂、容易混淆、代价昂贵并易于出错的重量级面向服务架构。</p>
<p>如果你发现需要从应用内部的用户接口或API层编排服务组件，那么很有可能你服务组件的粒度太细了。如果你发现你需要在服务组件之间执行服务间通信来处理单个请求,那么很有可能要么是你服务组件的粒度太细了，要么是没有从业务功能角度正确划分服务组件。</p>
<p>服务间通信，可能导致组件之间产生耦合，但可以通过共享数据库进行处理。例如，若一个服务组件处理网络订单而需要用户信息时，它可以去数据库检索必要的数据，而不是调用客户服务组件的功能。</p>
<p>共享数据库可以处理信息需求，但是共享功能呢？如果一个服务组件需要的功能包含在另一个服务组件内，或是一个公共的功能,那么有时你可以将服务组件的共享功能复制一份（因此违反了DRY规则：don’t repeat yourself）。为了保持服务组件独立和部署分离，微服务架构模式实现中会存在一小部分由重复的业务逻辑而造成的冗余，这在大多数业务应用程序中是一个相当常见的问题。小工具类可能属于这一类重复的代码。</p>
<p>如果你发现就算不考虑服务组件粒度的级别，你仍不能避免服务组件编排,这是一个好迹象,可能此架构模式不适用于你的应用。由于这种模式的分布式特性，很难维护服务组件之间的单一工作事务单元。这种做法需要某种事务补偿框架回滚事务,这对此相对简单而优雅的架构模式来说，显著增加了复杂性。</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>微服务架构模式解决了很多单体应用和面向服务架构应用存在的问题。由于主要应用组件被分成更小的,单独部署单元,使用微服务架构模式构建的应用程序通常更健壮,并提供更好的可扩展性,支持持续交付也更容易。</p>
<p>该模式的另一个优点是,它提供了实时生产部署能力，从而大大减少了传统的月度或周末“大爆炸”生产部署的需求。因为变化通常被隔离成特定的服务组件，只有变化的服务组件才需要部署。如果你的服务组件只有一个实例，你可以在用户界面程序编写专门的代码用于检测一个活跃的热部署,一旦检测到就将用户重定向到一个错误页面或等待页面。你也可以在实时部署期间，将服务组件的多个实例进行交换，允许应用程序在部署期间保持持续可用性（分层架构模式很难做到这点）。</p>
<p>最后一个要重视的考虑是，由于微服务架构模式是分布式的架构，他与事件驱动架构模式具有一些共同的复杂的问题，包括约定的创建、维护，和管理，远程系统的可用性，远程访问身份验证和授权。</p>
<h3 id="模式分析-4"><a href="#模式分析-4" class="headerlink" title="模式分析"></a>模式分析</h3><p>下面这个表中包含了微服务架构模式的特点分析和评级，每个特性的评级是基于自然趋势，基于典型模式实现的能力特性,以及该模式是以什么闻名的。本报告中该模式与其他模式的并排比较，请参考报告最后的附件A。</p>
<h4 id="整体灵活性-3"><a href="#整体灵活性-3" class="headerlink" title="整体灵活性"></a>整体灵活性</h4><p>评级：高<br> 分析：整体的灵活性是能够快速响应不断变化的环境。由于单独部署单元的概念,变化通常被隔离成单独的服务组件,使得部署变得快而简单。同时，使用这种模式构建的应用往往是松耦合的，也有助于促进改变。</p>
<h4 id="易于部署-3"><a href="#易于部署-3" class="headerlink" title="易于部署"></a>易于部署</h4><p>评级：高<br> 分析：整体来讲，由于该模式的解耦特性和事件处理组件使得部署变得相对简单。broker拓扑往往比mediator拓扑更易于部署，主要是因为event-mediator组件与事件处理器是紧耦合的，事件处理器组件有一个变化可能导致event mediator跟着变化，有任何变化两者都需要部署。</p>
<h4 id="可测试性-3"><a href="#可测试性-3" class="headerlink" title="可测试性"></a>可测试性</h4><p>评级：高<br> 分析：由于业务功能被分离成独立的应用模块,可以在局部范围内进行测试，这样测试工作就更有针对性。对一个特定的服务组件进行回归测试比对整个单体应用程序进行回归测试更简单、更可行。而且,由于这种模式的服务组件是松散耦合的，从开发角度来看，由一个变化导致应用其他部分也跟着变化的几率很小，并能减小由于一个微小的变化而不得不对整个应用程序进行测试的负担。</p>
<h4 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h4><p>评级：低<br> 分析：虽然你可以从实现该模式来创建应用程序并可以很好的运行，整体来说，由于微服务架构模式的分布式特性，并不适用于高性能的应用程序。</p>
<h4 id="伸缩性-3"><a href="#伸缩性-3" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评级：高<br> 分析：由于应用程序被分为单独的部署单元,每个服务组件可以单独扩展，并允许对应用程序进行扩展调整。例如，股票交易的管理员功能区域可能不需要扩展，因为使用该功能的用户很少，但是交易布局服务组件可能需要扩展，因为大多数交易应用程序需要具备处理高吞吐量的功能。</p>
<h4 id="易于开发-2"><a href="#易于开发-2" class="headerlink" title="易于开发"></a>易于开发</h4><p>评级：高<br> 分析：由于功能被分隔成不同的服务组件，由于开发范围更小且被隔离，开发变得更简单。程序员在一个服务组件做出一个变化影响其他服务组件的几率是很小的，从而减少开发人员或开发团队之间的协调。</p>
<h2 id="第五章-基于空间的架构"><a href="#第五章-基于空间的架构" class="headerlink" title="第五章 基于空间的架构"></a>第五章 基于空间的架构</h2><p>大多数基于网站的商务应用都遵循相同的请求流程：一个请求从浏览器发到web服务器，然后到应用服务器，然后到数据库服务器。虽然这个模式在用户数不大的时候工作良好，但随着用户负载的增加,瓶颈会开始出现，首先出现在web服务器层，然后应用服务器层，最后数据库服务器层。通常的解决办法就是<strong>向外扩展</strong>，也就是增加服务器数量。这个方法相对来说简单和廉价，并能够解决问题。然而，对于大多数高访问量的情况，它只不过是把web服务器的问题移到了应用服务器。而扩展应用服务器会更复杂，而且成本更高，并且又只是把问题移动到了数据库服务器，那会更复杂，更贵。就算你能扩展数据库服务器，你最终会陷入一个金字塔式的情形，在金字塔最下面是web服务器，它会出现最多的问题，但也最好伸缩。金字塔顶部是数据库服务器，问题不多，但最难伸缩。</p>
<p>在一个高并发大容量的应用中，数据库通常是决定应用能够支持多少用户同时在线的关键因素。虽然各种缓存技术和数据库伸缩产品都在帮助解决这个问题，但数据库难以伸缩的现实并没有改变。</p>
<p>基于空间的架构模型是专门为了<strong>解决伸缩性和并发问题</strong>而设计的。它对于用户数量不可预测且数量级经常变化的情况同样适用。在架构级别来解决这个伸缩性问题通常是比增加服务器数量或者提高缓存技术更好的解决办法。</p>
<h3 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h3><p>基于空间的模型（有时也称为云架构模型）旨在减少限制应用伸缩的因素。模型的名字来源于分布式共享内存中的 tuple space（数组空间）概念。高伸缩性是通过去除中心数据库的限制，并使用从内存中复制的数据框架来获得的。保存在内存的应用数据被复制给所有运行的进程。进程可以动态的随着用户数量增减而启动或结束，以此来解决伸缩性问题。这样因为没有了中心数据库，数据库瓶颈就此解决，此后可以近乎无限制的扩展了。</p>
<p>大多数使用这个模型的应用都是标准的网站，它们接受来自浏览器的请求并进行相关操作。竞价拍卖网站是一个很好的例子 ( 12306更是一个典型的示例 )。网站不停的接受来自浏览器的报价。应用收到对某一商品的报价，记录下报价和时间，并且更新对该商品的报价，将信息返回给浏览器。</p>
<p>这个架构中有两个主要的模块：<strong>处理单元</strong> 和 <strong>虚拟化中间件</strong>。下图展示了这个架构和里面的主要模块。</p>
<p><img src="5-1.png" alt="5-1"></p>
<p>处理单元包含了应用模块（或者部分的应用模块）。具体来说就是包含了web组件以及后台业务逻辑。处理单元的内容根据应用的类型而异——小型的web应用可能会部署到单一的处理单元，而大型一些的应用会将应用的不同功能模块部署到不同的处理单元中。典型的处理单元包括应用模块，以及保存在内存的数据框架和为应用失败时准备的异步数据持久化模块。它还包括复制引擎，使得虚拟化中间件可以将处理单元修改的数据复制到其他活动的处理单元。</p>
<p>虚拟化中间件负责保护自身以及通信。它包含用于数据同步和处理请求的模块，以及通信框架，数据框架，处理框架和部署管理器。这些在下文中即将介绍的部分，可以自定义编写或者购买第三方产品来实现。</p>
<h3 id="组件间合作"><a href="#组件间合作" class="headerlink" title="组件间合作"></a>组件间合作</h3><p>基于空间的架构的魔力就在虚拟化中间件，以及各个处理单元中的内存中数据框架。下图展示了包含着应用模块、内存中数据框架、处理异步数据恢复的组件和复制引擎的处理单元架构。</p>
<p>虚拟化中间件本质上是架构的控制器，它管理请求，会话，数据复制，分布式的请求处理和处理单元的部署。虚拟化中间件有四个架构组件：通信框架，数据框架，处理框架和部署管理器。</p>
<p><img src="5-2.png" alt="5-2"></p>
<h4 id="通信框架"><a href="#通信框架" class="headerlink" title="通信框架"></a>通信框架</h4><p>通信框架管理输入请求和会话信息。当有请求进入虚拟化中间件，通信框架就决定有哪个处理单元可用，并将请求传递给这个处理单元。通信框架的复杂程度可以从简单的round robin算法到更复杂的用于监控哪个请求正在被哪个处理单元处理的next-available算法。</p>
<p><img src="5-3.png" alt="5-3"></p>
<h4 id="数据框架"><a href="#数据框架" class="headerlink" title="数据框架"></a>数据框架</h4><p>数据框架可能是这个架构中最重要和关键的组件。它与各个处理单元的数据复制引擎交互，在数据更新时来管理数据复制功能。由于通信框架可以将请求传递给任何可用的处理单元，所以每个处理单元包含完全一样的内存中数据就很关键。下图展示处理单元间如何同步数据复制，实际中是通过非常迅速的并行的异步复制来完成的，通常在微秒级。</p>
<p><img src="5-4.png" alt="5-4"></p>
<h4 id="处理框架"><a href="#处理框架" class="headerlink" title="处理框架"></a>处理框架</h4><p>处理框架，就像下图所示，是虚拟化中间件中一个可选组件，负责管理在有多个处理单元时的分布式请求处理，每个处理单元可能只负责应用中的某个特定功能。如果请求需要处理单元间合作（比如，一个订单处理单元和顾客处理单元），此时处理框架就充当处理单元见数据传递的媒介。</p>
<p><img src="5-5.png" alt="5-5"></p>
<h4 id="部署管理器"><a href="#部署管理器" class="headerlink" title="部署管理器"></a>部署管理器</h4><p>部署管理器根据负载情况管理处理单元的动态启动和关闭。它持续检测请求所需时间和在线用户量，在负载增加时启动新的处理单元，在负载下降时关闭处理单元。它是实现可变伸缩性需求的关键。</p>
<h3 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h3><p>基于空间的架构是一个复杂和实现起来相对昂贵的框架。对于有可变伸缩性需求的小型web应用是很好的选择，然而，对于拥有大量数据操作的传统大规模关系型数据库应用，并不那么适用。</p>
<p>虽然基于空间的架构模型不需要集中式的数据储存，但通常还是需要这样一个，来进行初始化内存中数据框架，和异步的更新各处理单元的数据。通常也会创建一个单独的分区，来从隔离常用的断电就消失的数据和不常用的数据，这样减少处理单元之间对对方内存数据的依赖。</p>
<p>值得注意的是，虽然这个架构的另一个名字是云架构，处理单元（以及虚拟化中间件）都没有放在云端服务或者PaaS上。他们同样可以简单的放在本地服务器，这也是为什么我更倾向叫它“基于空间的架构”。</p>
<p>从产品实现的角度讲，这个架构中的很多组件都可以从第三方获得，比如GemFire, JavaSpaces, GigaSpaces，IBM Object Grid，nCache，和 Oracle Coherence。由于架构的实现根据工程的预算和需求而异，所以作为架构师，你应该在实现或选购第三方产品前首先明确你的目标和需求。</p>
<h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h3><p>下面的表格是这个架构的特征分析和评分。每个特征的评分是基于一个典型的架构实现来给出的。要知道这个模式相对别的模式的对比，请参见最后的附录A。</p>
<h4 id="综合能力"><a href="#综合能力" class="headerlink" title="综合能力"></a>综合能力</h4><p>评分：高<br> 分析：综合能力是对环境变化做出快速反应的能力。因为处理单元（应用的部署实例）可以快速的启动和关闭，整个应用可以根据用户量和负载做出反应。使用这个架构通常在应对代码变化上，由于较小的应用规模和组件间相互依赖，也会反映良好。</p>
<h4 id="易于部署-4"><a href="#易于部署-4" class="headerlink" title="易于部署"></a>易于部署</h4><p>评分：高<br> 分析：虽然基于空间的架构通常没有解耦合并且功能分布，但他们是动态的，也是成熟的基于云的工具，允许应用轻松的部署到服务器。</p>
<h4 id="可测试性-4"><a href="#可测试性-4" class="headerlink" title="可测试性"></a>可测试性</h4><p>评分：低<br> 分析：测试高用户负载既昂贵又耗时，所以在测试架构的可伸缩性方面很困难</p>
<h4 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h4><p>评分：高<br> 分析：通过内存中数据存取和架构中的缓存机制可获得高性能</p>
<h4 id="伸缩性-4"><a href="#伸缩性-4" class="headerlink" title="伸缩性"></a>伸缩性</h4><p>评分：高<br> 分析：高伸缩性是源于几乎不依赖集中式的数据库，从而去除了这个限制伸缩性的瓶颈。</p>
<h4 id="易于开发-3"><a href="#易于开发-3" class="headerlink" title="易于开发"></a>易于开发</h4><p>评分：低<br> 分析：主要是因为难以熟悉这个架构开发所需得工具和第三方产品，因此使用该架构需要较大的学习成本。而且，开发过程中还需要特别注意不要影响到性能和可伸缩性。</p>
<h3 id="附录A"><a href="#附录A" class="headerlink" title="附录A"></a>附录A</h3><h4 id="模式分析总结"><a href="#模式分析总结" class="headerlink" title="模式分析总结"></a>模式分析总结</h4><p>图A-1 总结了在这个报告中，对于架构模式的每部分进行的模式分析所产生的影响。这个总结帮助你确定哪些模式可能是最适合你的情况。例如,如果你的架构模式重点是可伸缩性，你可以在这个图表看看事件驱动模式,microservices模式,和基于空间模式，这些对于你来说可能是很好的架构模式的选择。同样的,如果你的程序注重的是分层架构模式,你可以参考图看到部署、性能和可伸缩性的在你的架构中所存在的风险。</p>
<p><img src="a-1.png" alt="a-1"></p>
<p>同时这个图表将指导你选择正确的模式,因为在选择一种架构模式的时候，有更多的因素需要考虑。你必须分析你的环境的各个方面,包括基础设施的支持,开发人员技能,项目预算,项目最后期限,和应用程序大小等等。选择正确的架构模式是至关重要的,因为一旦一个架构被确定就很难改变。</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a target="_blank" rel="noopener" href="https://gitlab.com/BangHeriSetiawan/android-tech-frontier/blob/00911a665a20cb4c85c1db7ade4410c292d32ed5/software-architecture-patterns/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.md#appendix">软件架构模式</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/12/27/flutter/flutter-2Dart%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/27/flutter/flutter-2Dart%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" class="post-title-link" itemprop="url">flutter-2Dart语法快速上手</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-27 11:48:08 / 修改时间：11:52:36" itemprop="dateCreated datePublished" datetime="2022-12-27T11:48:08+08:00">2022-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-几个重要概念"><a href="#一-几个重要概念" class="headerlink" title="一. 几个重要概念"></a>一. 几个重要概念</h2><p>在学习 Dart 语言时, 先要清楚以下几个事实和概念：</p>
<ul>
<li>Dart 语句是以分号 <code>;</code> 结尾的。</li>
<li>任何保存在变量中的都是一个对象，并且所有的对象都是对应一个类的实例。无论是数字，函数和 <code>null</code> 都是对象。所有对象继承自 Object 类。</li>
<li>尽管 Dart 是强类型的，但是 Dart 可以推断类型，所以类型注释是可选的。 如果要明确说明不需要任何类型， 需要使用特殊类型 dynamic 。</li>
<li>Dart 支持泛型，如 <code>List &lt;int&gt;</code>（整数列表）或 <code>List &lt;dynamic&gt;</code>（任何类型的对象列表）。</li>
<li>Dart 支持顶级函数，例如 <code>main()</code> ，同样函数绑定在类或对象上（分别是静态函数和实例函数）。以及支持函数内创建函数（ 嵌套或局部函数）。</li>
<li>Dart 支持顶级变量，同样变量绑定在类或对象上（静态变量和实例变量）。实例变量有时称为字段或属性。</li>
<li>与 Java 不同，Dart 没有关键字 <code>public</code> ， <code>protected</code> 和 <code>private</code> 。如果标识符以下划线 <code>_</code> 开头，则它相对于库是私有的。</li>
<li>标识符以字母或下划线 <code>_</code> 开头，后跟任意字母和数字组合。</li>
</ul>
<p>二. Dart关键字</p>
<p>Dart 语言关键字列表如下：</p>
<table>
<thead>
<tr>
<th>else</th>
<th>import</th>
<th>static</th>
<th>assert</th>
<th>enum</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>uper</td>
<td>async</td>
<td>export</td>
<td>interface</td>
</tr>
<tr>
<td>switch</td>
<td>await</td>
<td>extends</td>
<td>is</td>
<td>sync</td>
</tr>
<tr>
<td>break</td>
<td>external</td>
<td>library</td>
<td>this</td>
<td>case</td>
</tr>
<tr>
<td>factory</td>
<td>mixin</td>
<td>throw</td>
<td>catch</td>
<td>false</td>
</tr>
<tr>
<td>new</td>
<td>true</td>
<td>class</td>
<td>final</td>
<td>null</td>
</tr>
<tr>
<td>try</td>
<td>const</td>
<td>finally</td>
<td>on</td>
<td>typedef</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>operator</td>
<td>var</td>
<td>covariant</td>
</tr>
<tr>
<td>Function</td>
<td>part</td>
<td>void</td>
<td>default</td>
<td>get</td>
</tr>
<tr>
<td>rethrow</td>
<td>while</td>
<td>deferred</td>
<td>hide</td>
<td>return</td>
</tr>
<tr>
<td>with</td>
<td>do</td>
<td>if</td>
<td>set</td>
<td>yield</td>
</tr>
</tbody></table>
<p>使用 Dart 时应避免使用这些单词作为标识符。</p>
<h2 id="三-入口函数"><a href="#三-入口函数" class="headerlink" title="三. 入口函数"></a>三. 入口函数</h2><p>Dart 有两种入口主函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> main()&#123;</span><br><span class="line">  print(&#x27;Hello Dart!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加 void 表示没有返回值</span><br><span class="line">void main()&#123;</span><br><span class="line">  print(&#x27;Hello Flutter!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-代码注释"><a href="#四-代码注释" class="headerlink" title="四. 代码注释"></a>四. 代码注释</h2><p>Dart 支持单行注释、多行注释和文档注释：</p>
<ol>
<li>单行注释：单行注释以 <code>//</code> 开始。 所有在 <code>//</code> 和改行结尾之间的内容被编译器忽略。</li>
<li>多行注释：多行注释以 <code>/*</code> 开始， 以 <code>*/</code> 结尾。 所有在 <code>/*</code> 和 <code>*/</code> 之间的内容被编译器忽略 （不会忽略文档注释）。 多行注释可以嵌套。</li>
<li>文档注释：文档注释可以是多行注释，也可以是单行注释，文档注释以  <code>///</code> 或者 <code>/**</code> 开始。 在连续行上使用 <code>///</code> 与多行文档注释具有相同的效果。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 单行注释</span><br><span class="line">/* </span><br><span class="line"> * 多行注释</span><br><span class="line"> */ </span><br><span class="line"></span><br><span class="line">/// 文档注释</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 文档注释</span><br><span class="line"> */三、变量</span><br></pre></td></tr></table></figure>

<h2 id="五-变量"><a href="#五-变量" class="headerlink" title="五. 变量"></a>五. 变量</h2><p><strong>1. 定义变量</strong></p>
<p>Dart 中定义变量有两种方式，一种是静态类型语言常用的方式，即指定变量类型；另一种则是动态语言的常用方式，即不指定类型，由 Dart 自动类型判断，一般最好指定类型。</p>
<p> <code>// 指定变量类型：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = &#x27;ImportV&#x27;;</span><br><span class="line"></span><br><span class="line">// 使用关键字 var ，不指定变量类型：</span><br><span class="line">var name = &#x27;ImportV&#x27;;</span><br></pre></td></tr></table></figure>

<p>未初始化的变量默认值是 <code>null</code>。即使变量是数字类型默认值也是 <code>null</code>，因为在 Dart 中一切都是对象，数字类型也不例外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">print(a);  // 输出值为 null</span><br></pre></td></tr></table></figure>

<p>\2. 动态改变变量类型</p>
<p>如想动态改变变量的数据类型，应当使用 <code>dynamic</code> 或 <code>Object</code> 来定义变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dynamic a = &#x27;Dart&#x27;;  // 也可使用 Object a = &#x27;Dart&#x27;;</span><br><span class="line">a = 2021;</span><br><span class="line">print(a);  // 输出结果为 2021</span><br></pre></td></tr></table></figure>

<p>\3. 定义常量</p>
<p>Dart 中定义常量也有两种方式，一种使用 <code>final</code> 关键字，另一种是使用 <code>const</code> 关键字。需要注意的是， <code>final</code> 定义的常量是运行时常量，而 <code>const</code> 常量则是编译时常量，也就是说 <code>final</code> 定义常量时，其值可以是一个变量，而 <code>const</code> 定义的常量，其值必须是一个字面常量值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final a = DateTime.now();</span><br><span class="line">print(a);  // 输出现在的时间</span><br><span class="line"></span><br><span class="line">const a = DateTime.now();</span><br><span class="line">print(a);  // 报错</span><br><span class="line"></span><br><span class="line">六. 内建类型</span><br></pre></td></tr></table></figure>

<p>Dart 语言支持以下内建类型：</p>
<p><img src="http://space.babytree-inc.com/download/attachments/30609176/640.png?version=2&modificationDate=1645091354000&api=v2" alt="img"><br>\1. Number</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// int 必须是整型：</span><br><span class="line">int a = 123;</span><br><span class="line"></span><br><span class="line">// 从 Dart 2.0 开始，double 既可以是浮点数也可以是整型：</span><br><span class="line">double b = 12.34;</span><br><span class="line">double c = 6;    // 相当于 double c = 6.0</span><br></pre></td></tr></table></figure>

<p>\2. String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 用单引号或者双引号定义字符串：</span><br><span class="line">String s1 = &#x27;Hello Dart!&#x27;</span><br><span class="line">String s2 = &quot;Hello Flutter!&quot;</span><br><span class="line"></span><br><span class="line">// 当字符串有引号时：</span><br><span class="line">String s3 = &#x27;I\&#x27;m ImportV!&#x27;</span><br><span class="line">string s4 = &quot;I&#x27;m ImportV!&quot;</span><br><span class="line"></span><br><span class="line">// 使用连续三个单引号或者三个双引号实现多行字符串对象的创建：</span><br><span class="line">String s5 = &#x27;&#x27;&#x27;</span><br><span class="line">Hello Dart! </span><br><span class="line">Hello Flutter! </span><br><span class="line">Hello ImportV!</span><br><span class="line">&#x27;&#x27;&#x27;;</span><br><span class="line">// 使用 r 前缀，可以创建 “原始 raw” 字符串：</span><br><span class="line">String s6 = r&#x27;Hello Dart \n Hello Flutter!&#x27;</span><br><span class="line"></span><br><span class="line">// String -&gt; int：</span><br><span class="line">int a = int.parse(&#x27;123&#x27;);</span><br><span class="line"></span><br><span class="line">// String -&gt; double：</span><br><span class="line">double b = double.parse(&#x27;12.34&#x27;);</span><br><span class="line"></span><br><span class="line">// int -&gt; String：</span><br><span class="line">String str1 = 123.toString();</span><br><span class="line"></span><br><span class="line">// double -&gt; String：</span><br><span class="line">String str2 = 12.3456.toStringAsFixed(2);  // 括号内为要保留的小数位数</span><br><span class="line"></span><br><span class="line">// 字符串拼接，用“+”拼接，字面量字符串也可以直接写在一起：</span><br><span class="line">String s1 = &#x27;Hello Dart! &#x27; &#x27;Hello Flutter! &#x27; &#x27;Hello ImportV! &#x27;;</span><br><span class="line">String s2 = &#x27;Hello Dart! &#x27; + &#x27;Hello Flutter! &#x27; + &#x27;Hello ImportV! &#x27;;</span><br><span class="line"></span><br><span class="line">// 字符串可以通过 $&#123;expression&#125; 的方式内嵌表达式。 如果表达式是一个标识符，则 &#123;&#125; 可以省略:</span><br><span class="line">String s1 = &#x27;Hello Flutter!&#x27;;</span><br><span class="line">String s2 = &#x27;Hello Dart! $s1 Hello ImportV!&#x27;;</span><br></pre></td></tr></table></figure>

<p>\3. Boolean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 布尔类型默认值为null，字面量只有 true 和 false ，这两个对象都是编译时常量：</span><br><span class="line">bool b = true;</span><br></pre></td></tr></table></figure>

<p>\4. List</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 定义列表方法一：</span><br><span class="line">List lt1 = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// 定义列表方法二：</span><br><span class="line">List a = [];</span><br><span class="line">a.add(1);</span><br><span class="line">a.add(2);</span><br><span class="line">a.add(3);</span><br><span class="line"></span><br><span class="line">// 获取列表属性：</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;ImportV&#x27;];</span><br><span class="line">print(a.length);  // 获取列表长度</span><br><span class="line">print(a.isEmpty);  // 判断列表是否为空，如果是，输出 true</span><br><span class="line">print(a.isNotEmpty);  // 判断列表是否为空，如果不是，输出 true</span><br><span class="line">print(a.reversed);  // 将列表逆序输出（翻转列表）</span><br><span class="line"></span><br><span class="line">// 列表的下标索引是从0开始的：</span><br><span class="line">List a = [1, 2, 3, 4];</span><br><span class="line">print(a[0]);</span><br><span class="line"></span><br><span class="line">// 拼接与插入：</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;];</span><br><span class="line">a.add(&#x27;Android&#x27;);  // 拼接一个元素</span><br><span class="line">a.addAll([&#x27;Android&#x27;, &#x27;iOS&#x27;]);  // 拼接多个元素</span><br><span class="line">a.insert(2, &#x27;Android&#x27;);  // 插入一个元素，2 为插入位置的索引值</span><br><span class="line">a.insertAll(2, [&#x27;Android&#x27;, &#x27;iOS&#x27;]);  // 插入多个元素</span><br><span class="line"></span><br><span class="line">// 列表转字符串：</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;];</span><br><span class="line">String b = a.join(&#x27;-&gt;&#x27;);  // 此处 b 的字面量为 Dart-&gt;Flutter-&gt;Android</span><br><span class="line"></span><br><span class="line">// 字符串转列表：</span><br><span class="line">String a = &#x27;Dart-&gt;Flutter-&gt;Android&#x27;;</span><br><span class="line">List b = a.split(&#x27;-&gt;&#x27;);  // 此处 b 的字面量为 [Dart, Flutter, Android]</span><br><span class="line"></span><br><span class="line">// 指定列表类型：</span><br><span class="line">List a = &lt;String&gt;[];</span><br><span class="line">a.add(&#x27;Flutter&#x27;);</span><br><span class="line">a.add(1);  //报错</span><br><span class="line"></span><br><span class="line">// 在列表字面量前添加 const 关键字，定义一个不可改变的列表（编译时常量）：</span><br><span class="line">List a = const [1, 2, 3, 4];</span><br><span class="line">a[0] = 2;  // 报错</span><br></pre></td></tr></table></figure>

<p>\5. Set</p>
<p>Set 是没有顺序且元素不能重复的集合，因此不能通过索引去获取值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 定义集合方法一：</span><br><span class="line">Set a = &#123;&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;ImportV&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">// 定义集合方法二</span><br><span class="line">Set a = &#123;&#125;;</span><br><span class="line">a.add(&#x27;Dart&#x27;);</span><br><span class="line">a.add(&#x27;Flutter&#x27;);</span><br><span class="line">a.add(&#x27;ImportV&#x27;);</span><br><span class="line"></span><br><span class="line">// 创建空集合：</span><br><span class="line">Set a = &#123;&#125;;  //  方法一</span><br><span class="line">var a = &lt;String&gt;&#123;&#125;;  // 方法二</span><br><span class="line">var a = &#123;&#125;;  // 这样会创建一个空的 Map，而不是 Set</span><br><span class="line"></span><br><span class="line">// 获取集合中元素的个数：</span><br><span class="line">Set a = &#123;&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;ImportV&#x27;&#125;;</span><br><span class="line">print(a.length);  // 输出为 3</span><br><span class="line"></span><br><span class="line">// 创建一个不可改变的集合（编译时常量）：</span><br><span class="line">Set a = const &#123;&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;ImportV&#x27;&#125;;</span><br><span class="line">a.add(&#x27;Android&#x27;);  // 报错</span><br><span class="line"></span><br><span class="line">// 列表转集合：</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;];</span><br><span class="line">print(a.toSet());</span><br><span class="line"></span><br><span class="line">// 集合转列表：</span><br><span class="line">Set a = &#123;&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;&#125;;</span><br><span class="line">print(a.toList());</span><br></pre></td></tr></table></figure>

<p>\6. Map</p>
<p>Map（映射）是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 定义映射方法一：</span><br><span class="line">Map a = &#123;</span><br><span class="line">// key     value</span><br><span class="line">  &#x27;first&#x27;: &#x27;Dart&#x27;,</span><br><span class="line">  &#x27;second&#x27;: &#x27;Flutter&#x27;,</span><br><span class="line">  &#x27;third&#x27;: &#x27;Android&#x27;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">// 定义映射方法二：</span><br><span class="line">Map a = &#123;&#125;;</span><br><span class="line">a[&#x27;first&#x27;] = &#x27;Dart&#x27;;</span><br><span class="line">a[&#x27;second&#x27;] = &#x27;Flutter&#x27;;</span><br><span class="line">a[&#x27;third&#x27;] = &#x27;Android&#x27;;</span><br><span class="line"></span><br><span class="line">// 获取映射长度：</span><br><span class="line">print(a.length);</span><br><span class="line"></span><br><span class="line">// 获取指定 value 值：</span><br><span class="line">print(a[&#x27;first&#x27;]);</span><br><span class="line"></span><br><span class="line">// 在映射字面量前添加 const 关键字，定义一个不可改变的映射（编译时常量）：</span><br><span class="line">Map a = const &#123;&#x27;first&#x27;: &#x27;Dart&#x27;, &#x27;second&#x27;: &#x27;Flutter&#x27;, &#x27;third&#x27;: &#x27;Android&#x27;&#125;;</span><br><span class="line">a[&#x27;third&#x27;] = &#x27;iOS&#x27;  //报错五、运算符</span><br></pre></td></tr></table></figure>

<h2 id="七-运算符"><a href="#七-运算符" class="headerlink" title="七. 运算符"></a>七. 运算符</h2><p>下面是 Dart 定义的运算符：</p>
<p><strong>1. 算数运算符</strong></p>
<p>除了基本的算术运算外，Dart 还支持前缀和后缀、自增和自减运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a, b;</span><br><span class="line">a = 0;</span><br><span class="line"></span><br><span class="line">b = ++a;  // a自加1后赋值给b</span><br><span class="line">b = a++;  // a赋值给b后自加1</span><br><span class="line">b = --a;  // a自减1后赋值给b</span><br><span class="line">b = a--;  // a赋值给b后自减1</span><br></pre></td></tr></table></figure>

<h3 id="2-类型判断运算符"><a href="#2-类型判断运算符" class="headerlink" title="2. 类型判断运算符"></a>2. 类型判断运算符</h3><p>使用 <code>as</code> 运算符将对象强制转换为特定类型时，通常可以认为是 <code>is</code> 类型判定后，被判定对象调用函数的一种缩写形式。 请考虑以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (emp is Person) &#123;</span><br><span class="line">  emp.firstName = &#x27;Bob&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 as 运算符进行缩写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp as Person).firstName = &#x27;Bob&#x27;;</span><br></pre></td></tr></table></figure>

<p>【注意】以上代码并不是等价的。 如果 <code>emp</code> 为 <code>null</code> 或者不是 <code>Person</code> 对象， 那么第一个 <code>is</code> 的示例，后面将不执行； 第二个 <code>as</code> 的示例会抛出异常。</p>
<h3 id="3-赋值运算符"><a href="#3-赋值运算符" class="headerlink" title="3. 赋值运算符"></a>3. 赋值运算符</h3><p>下面示例使用几个赋值和复合赋值运算符，其他使用方法类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 123;  // 使用 = 直接为变量赋值。</span><br><span class="line"></span><br><span class="line">b ??= 456;  // 使用 ??= 运算符时，只有当 b 值为 null 时才会被赋值</span><br><span class="line"></span><br><span class="line">a *= 3;  // 赋值并做乘法运算，相当于 a = a * 3</span><br></pre></td></tr></table></figure>

<h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h3><p>下面是关于逻辑表达式的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!done &amp;&amp; (col == 0 || col == 3)) &#123;</span><br><span class="line">  // ...Do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5. 位运算符"></a>5. 位运算符</h3><p>位运算符把数字转为二进制来运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 按位与，参与运算的两个值，如果两个相应二进位都为 1，则该位结果为 1，否则为 0</span><br><span class="line">print(a &amp; b);  // 结果为 4</span><br><span class="line"></span><br><span class="line">// 按位或，只要对应的两个二进位有一个为 1，结果位就为 1</span><br><span class="line">print(a | b);  // 结果为 14</span><br><span class="line"></span><br><span class="line">// 按位异或，当两个对应的二进位相异时，结果位为 1，否则为 0</span><br><span class="line">print(a ^ b);  // 结果为 10</span><br><span class="line"></span><br><span class="line">// 按位取反，对数据的每一个二进位，把 1 变为 0，把 0 变为 1</span><br><span class="line">print(~a);  // 结果我为 -13</span><br><span class="line"></span><br><span class="line">// 左移，把 &lt;&lt; 左边的数的各二进位左移若干位，由 &lt;&lt; 右边的数指定移动位数，高位丢弃，低位补 0</span><br><span class="line">print(a &lt;&lt; 2);  // 结果为 48，相当于乘以 2 的 2 次方</span><br><span class="line"></span><br><span class="line">// 右移，把 &lt;&lt; 左边的数的各二进位右移若干位，由 &lt;&lt; 右边的数指定移动位数</span><br><span class="line">print(a &gt;&gt; 2);  // 结果为 3，相当于除以 2 的 2 次方</span><br></pre></td></tr></table></figure>

<h3 id="6-条件表达式"><a href="#6-条件表达式" class="headerlink" title="6. 条件表达式"></a>6. 条件表达式</h3><p>Dart有两个运算符，有时可以替换 if-else 表达式， 让表达式更简洁，称为条件表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expr1 : expr2</span><br></pre></td></tr></table></figure>

<p>如果条件为 <code>true</code>, 执行 <code>expr1</code> (并返回它的值)： 否则, 执行并返回 <code>expr2</code> 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr1 ?? expr2</span><br></pre></td></tr></table></figure>

<p>如果 <code>expr1</code> 不是 <code>null</code>， 返回 <code>expr1</code> 的值； 否则, 执行并返回 <code>expr2</code> 的值。</p>
<p>如果条件判断是根据布尔值， 考虑使用第一种，如果是根据是否为 <code>null</code>，考虑使用第二种。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &#x27;Dart&#x27;;</span><br><span class="line">var b = &#x27;Flutter&#x27;;</span><br><span class="line">var c = a ?? b.toUpperCase();  // 此处 c 的字面量为 Dart</span><br></pre></td></tr></table></figure>

<h3 id="7-级联运算符"><a href="#7-级联运算符" class="headerlink" title="7. 级联运算符"></a>7. 级联运算符</h3><p>级联运算符 <code>..</code> 可以实现对同一个对像进行一系列的操作。 除了调用函数外， 还可以访问同一对象上的字段属性。 这通常可以节省创建临时变量的步骤， 同时编写出更流畅的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">querySelector(&#x27;#confirm&#x27;)   // 获取对象。</span><br><span class="line">  ..text = &#x27;Confirm&#x27;    // 调用成员变量。</span><br><span class="line">  ..classes.add(&#x27;important&#x27;)</span><br><span class="line">  ..onClick.listen((e) =&gt; window.alert(&#x27;Confirmed!&#x27;));</span><br></pre></td></tr></table></figure>

<p>第一句调用函数 <code>querySelector()</code> ，返回获取到的对象。 获取的对象依次执行级联运算符后面的代码， 代码执行后的返回值会被忽略。</p>
<p>上面的代码等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var button = querySelector(&#x27;#confirm&#x27;);</span><br><span class="line">button.text = &#x27;Confirm&#x27;;</span><br><span class="line">button.classes.add(&#x27;important&#x27;);</span><br><span class="line">button.onClick.listen((e) =&gt; window.alert(&#x27;Confirmed!&#x27;));</span><br></pre></td></tr></table></figure>

<p>级联运算符是可以嵌套的。但要注意，在返回对象的函数中谨慎使用级联操作符。 例如，下面的代码是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sb = StringBuffer();</span><br><span class="line">sb.write(&#x27;foo&#x27;)</span><br><span class="line">  ..write(&#x27;bar&#x27;);   // sb.write() 函数调用返回 void， 不能在 void 对象上创建级联操作。六、流程控制语句</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="八-流程控制语句"><a href="#八-流程控制语句" class="headerlink" title="八. 流程控制语句"></a>八. 流程控制语句</h2><p>Dart 中的流程控制语句与 Java 相似。</p>
<p><strong>1. if - else 分支</strong></p>
<p>和 JavaScript 不同， Dart 的判断条件必须是布尔值，不能是其他类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">if (a &lt; 0) &#123;</span><br><span class="line">  a++;</span><br><span class="line">&#125; else if (a &gt; 0) &#123;</span><br><span class="line">  a--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-switch-case-语句"><a href="#2-switch-case-语句" class="headerlink" title="2. switch - case 语句"></a>2. switch - case 语句</h3><p>在 Dart 中 <code>switch</code> 语句使用 <code>==</code> 比较整数、字符串、编译时常量或者枚举类型。 比较的对象必须都是同一个类的实例（并且不可以是子类）， 类必须没有对 <code>==</code> 重写。</p>
<p>在 <code>case</code> 语句中，每个非空的 <code>case</code> 语句结尾需要跟一个 <code>break</code> 语句。 除  <code>break</code>以外，还有可以使用 <code>continue</code>， <code>throw</code> 或者 <code>return</code>。当没有 <code>case</code> 语句匹配时，执行 <code>default</code> 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = &#x27;yes&#x27;;</span><br><span class="line">switch (a) &#123;</span><br><span class="line">  case &#x27;yes&#x27;:</span><br><span class="line">    print(&#x27;yes&#x27;);</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;no&#x27;:</span><br><span class="line">    print(&#x27;no&#x27;);</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    print(&#x27;fault&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h3><p>进行迭代操作，可以使用标准 for 语句。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 计算 5 的阶乘</span><br><span class="line">int result = 1;</span><br><span class="line">for (int i = 1; i &lt; 6; i++) &#123;</span><br><span class="line">  result = result * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包在 Dart 的 for 循环中会捕获循环的初始索引值， 来避免 JavaScript 中常见的陷阱。下面的代码输出的是 0 和 1，但是在 JavaScript 中会连续输出两个 2 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = [];</span><br><span class="line">for (var i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">  callbacks.add(() =&gt; print(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) =&gt; c());</span><br></pre></td></tr></table></figure>

<h3 id="4-while-和-do-while-循环"><a href="#4-while-和-do-while-循环" class="headerlink" title="4. while 和 do while 循环"></a>4. while 和 do while 循环</h3><p><code>while</code> 循环是在执行前判断执行条件，<code>do-while</code> 循环是在执行后判断执行条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 计算 5 的阶乘</span><br><span class="line">int i = 1;</span><br><span class="line">int result = 1;</span><br><span class="line">// 使用 while 循环</span><br><span class="line">while (i &lt; 6) &#123;</span><br><span class="line">  result = result * i;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line">// 使用 do - while 循环</span><br><span class="line">do &#123;</span><br><span class="line">  result = result * i;</span><br><span class="line">  i++;</span><br><span class="line">&#125; while (i &lt; 6);</span><br></pre></td></tr></table></figure>

<h3 id="5-break-和-continue"><a href="#5-break-和-continue" class="headerlink" title="5. break 和 continue"></a>5. break 和 continue</h3><p>使用 <code>break</code> 停止程序循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">  if (i == 3) &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  print(i);  // 输出结果为 1 2（i = 3 时循环结束）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>continue</code> 跳转到下一次循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">  if (i == 3) &#123;</span><br><span class="line">    continue;</span><br><span class="line">  &#125;</span><br><span class="line">  print(i);  // 输出结果为 1 2 4（i = 3 时跳到下一次循环）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-其他循环"><a href="#6-其他循环" class="headerlink" title="6. 其他循环"></a>6. 其他循环</h3><p>使用 <code>for...in...</code> 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 遍历数组</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;];</span><br><span class="line">for (var item in a) &#123;</span><br><span class="line">  print(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>forEach</code> 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 遍历数组</span><br><span class="line">List a = [&#x27;Dart&#x27;, &#x27;Flutter&#x27;, &#x27;Android&#x27;];</span><br><span class="line">a.forEach((var item) &#123;</span><br><span class="line">  print(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="7-assert-语句"><a href="#7-assert-语句" class="headerlink" title="7. assert 语句"></a>7. assert 语句</h3><p>使用 <code>assert</code> 语句进行判断，如果 <code>assert</code> 语句中的布尔条件为 <code>false</code> ， 那么正常的程序执行流程会被中断:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 确认变量值不为空。</span><br><span class="line">assert(text != null);</span><br><span class="line"></span><br><span class="line">// 确认变量值小于100。</span><br><span class="line">assert(number &lt; 100);</span><br></pre></td></tr></table></figure>

<p>【注意】<code>assert</code> 语句只在开发环境中有效， 在生产环境是无效的； Flutter 中的 <code>assert</code> 只在 debug 模式中有效。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="九-异常处理"><a href="#九-异常处理" class="headerlink" title="九. 异常处理"></a>九. 异常处理</h2><p>Dart 代码可以抛出和捕获异常。和 Java 有所不同， Dart 中的所有异常是非检查异常。方法不会声明它们抛出的异常，也不要求捕获任何异常。</p>
<p>Dart 提供了 <code>Exception</code> 和 <code>Error</code> 类型， 以及一些子类型，也可以定义自己的异常类型。Dart 程序可以抛出任何非 <code>null</code> 对象， 不仅限 <code>Exception</code> 和 <code>Error</code> 对象。</p>
<h3 id="1-throw-抛出异常"><a href="#1-throw-抛出异常" class="headerlink" title="1. throw 抛出异常"></a>1. throw 抛出异常</h3><p>下面是关于抛出或者引发异常的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw FormatException(&#x27;Expected at least 1 section&#x27;);</span><br></pre></td></tr></table></figure>

<p>也可以抛出任意的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw &#x27;Out of llamas!&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="2-try…catch…finally-捕获异常"><a href="#2-try…catch…finally-捕获异常" class="headerlink" title="2. try…catch…finally 捕获异常"></a>2. try…catch…finally 捕获异常</h3><p>Dart 语言中通过指定多个 <code>catch</code> 语句，可以处理可能抛出多种类型异常的代码，并由与抛出异常类型匹配的第一个 <code>catch</code> 语句处理异常。 如果 <code>catch</code> 语句未指定类型， 则该语句可以处理任何类型的抛出对象。</p>
<p>此外，<code>catch()</code> 函数可以指定1到2个参数， 第一个参数为抛出的异常对象， 第二个为堆栈信息。</p>
<p>使用 <code>finally</code> 语句时，无论是否抛出异常，<code>finally</code> 中的代码都会被执行。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  print(10 ~/ 0);</span><br><span class="line">&#125; on IntegerDivisionByZeroException catch (e, s) &#123;</span><br><span class="line">  print(e);</span><br><span class="line">  print(s);</span><br><span class="line">&#125; on Exception catch (e, s) &#123;</span><br><span class="line">  print(e);</span><br><span class="line">  print(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 捕获的异常</span><br><span class="line">IntegerDivisionByZeroException  </span><br><span class="line">// 堆栈信息</span><br><span class="line">#0      int.~/ (dart:core-patch/integers.dart:22:7)  </span><br><span class="line">#1      main (file:///c:/Users/27884/Desktop/test.dart:3:14)</span><br><span class="line">#2      _startIsolate.&lt;anonymous closure&gt; (dart:isolate-patch/isolate_patch.dart:301:19)</span><br><span class="line">#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:168:12)</span><br><span class="line">// finally 语句后的代码执行结果</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/12/27/flutter/flutter-1%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/27/flutter/flutter-1%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">flutter-1学习相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-27 11:12:42 / 修改时间：11:52:30" itemprop="dateCreated datePublished" datetime="2022-12-27T11:12:42+08:00">2022-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、环境及基础"><a href="#1、环境及基础" class="headerlink" title="1、环境及基础"></a>1、环境及基础</h1><ul>
<li>官网<br><a target="_blank" rel="noopener" href="https://flutter.cn/docs/get-started/install">https://flutter.cn/docs/get-started/install</a></li>
<li>中文网<br><a target="_blank" rel="noopener" href="https://flutterchina.club/get-started/install/">https://flutterchina.club/get-started/install/</a></li>
<li>公开库<br><a target="_blank" rel="noopener" href="https://pub.dev/">https://pub.dev</a></li>
<li>电子书<br><a target="_blank" rel="noopener" href="https://book.flutterchina.club/">https://book.flutterchina.club</a></li>
<li>cookbook<br><a target="_blank" rel="noopener" href="https://docs.flutter.dev/cookbook">https://docs.flutter.dev/cookbook</a></li>
</ul>
<h1 id="2、优秀开源"><a href="#2、优秀开源" class="headerlink" title="2、优秀开源"></a>2、优秀开源</h1><table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://github.com/toly1994328/FlutterUnit">https://github.com/toly1994328/FlutterUnit</a></th>
<th>项目架构设计，UI及动画学习</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://laomengit.com/">http://laomengit.com</a></td>
<td>UI、动画学习</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/fluttercandies/">https://github.com/fluttercandies/</a></td>
<td>flutter 一桶天下</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://help.syncfusion.com/flutter/introduction/overview">https://help.syncfusion.com/flutter/introduction/overview</a></td>
<td>pdf，图表，日历，地图，表格等硬核插件</td>
</tr>
</tbody></table>
<h1 id="3、较活跃的论坛"><a href="#3、较活跃的论坛" class="headerlink" title="3、较活跃的论坛"></a>3、较活跃的论坛</h1><ul>
<li>掘金<br><a target="_blank" rel="noopener" href="https://juejin.cn/ios/Flutter">https://juejin.cn/ios/Flutter</a></li>
</ul>
<h1 id="4、公众号"><a href="#4、公众号" class="headerlink" title="4、公众号"></a>4、公众号</h1><ul>
<li>Flutter社区</li>
<li>Flutter编程指南</li>
<li>谷歌开发者</li>
<li>老孟Flutter</li>
<li>flutter开发精选</li>
</ul>
<h1 id="5、关于cocoapods"><a href="#5、关于cocoapods" class="headerlink" title="5、关于cocoapods"></a>5、关于cocoapods</h1><ul>
<li><p>不推荐使用bundle管理多个cocoapods版本。</p>
</li>
<li><p>备注：如果cocoapods安装指定版本不成功试下:</p>
<p>MacOS 10.11以后用此命令安装或卸载cocoapods（为了运行Flutter）<br>sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods -v 1.11.3<br>sudo gem uninstall -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods -v 1.11.3</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2022/04/18/OC%E5%85%B6%E5%AE%83/iOS%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/OC%E5%85%B6%E5%AE%83/iOS%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">iOS包大小优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-18 18:18:49" itemprop="dateCreated datePublished" datetime="2022-04-18T18:18:49+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/12/28/swift/1-Class-Struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/28/swift/1-Class-Struct/" class="post-title-link" itemprop="url">Class & Struct</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-28 17:08:10" itemprop="dateCreated datePublished" datetime="2021-12-28T17:08:10+08:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><ol>
<li>定义存储值的属性</li>
<li>定义方法</li>
<li>定义下标以及使用下标语法提供对其值的访问</li>
<li>定义初始化器</li>
<li>使用extension来拓展功能</li>
<li>遵循协议来提供功能</li>
</ol>
<h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><ol>
<li>类有继承特性，结构体没有</li>
<li>类型转换，在运行时检查和解释类实例的类型</li>
<li>类有析构函数用来释放器分配的资源</li>
<li>引用计数允许对一个类实例有多个引用</li>
<li>类是引用类型，存储在堆上，也就意味着一个类类型的变量并不是直接存储具体的的实例对象，是对当前存储具体实例内存地址的引用。</li>
<li>Struct结构体是值类型，存储在栈上。如果值类型中有引用类型的属性，则该属性的地址在栈上，但是引用的值存储在堆上。</li>
<li>尽可能多的使用值类型，是内存安全的，运行效率也会比值类型高。</li>
</ol>
<h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><ol>
<li>类中添加属性，不会自动提供成员初始化器，必须提供对应的的指定初始化器（或者提供便捷初始化器）。</li>
<li>结构体会提供默认的成员初始化器。</li>
</ol>
<h3 id="便捷初始化器"><a href="#便捷初始化器" class="headerlink" title="便捷初始化器"></a>便捷初始化器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init(name: String, age: Int) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convenience init()&#123;</span><br><span class="line">// 这里需要调用初始化</span><br><span class="line">    self.init(name: &quot;name&quot;, age: 18)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>便捷初始化器必须从相同的类里调用另一个初始化器，否则会报错。</p>
<h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><ol>
<li>指定初始化器必须在调用父类初始化器之前，对其所有属性完成初始化。（确保成员变量使用安全）</li>
<li>指定初始化器必须在调用父类初始化器之后，才能为继承的属性设置新值，否则指定初始化器中赋的新值会被父类的初始化所覆盖。</li>
<li>便捷初始化器必须先调用同类中的初始化器之后，再为任意属性赋值，否则会报错，（属性的值也会被指定初始化覆盖）。</li>
<li>初始化器在初始化完成之前，不能调用任何实例方法，不能读取任何实例属性的值，也不能引用self作为值。必须保证内存是安全的</li>
</ol>
<h4 id="可失败初始化：init"><a href="#可失败初始化：init" class="headerlink" title="可失败初始化：init?"></a>可失败初始化：init?</h4><p>当参数不合法或者条件不满足时存在失败的情况，return nil。</p>
<h4 id="必要初始化：require"><a href="#必要初始化：require" class="headerlink" title="必要初始化：require"></a>必要初始化：require</h4><p>在类的初始化之前添加required关键字来修饰。表明该类的子类都必须实现该初始化器。</p>
<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>refCount ：64位的位域信息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/12/27/flutter/flutter-%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/27/flutter/flutter-%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">flutter-规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-27 10:04:25" itemprop="dateCreated datePublished" datetime="2021-12-27T10:04:25+08:00">2021-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h2><p>代码应该简洁易懂，逻辑清晰；<br>代码应优先保证正确性、可用性；<br>在保证程序可用的情况下，代码应该具备可扩展性，易修改，而不是需求有一点改动代码就需要大动干戈；</p>
<h2 id="禁止使用print直接提交到发版分支，使用debugPrint替换。"><a href="#禁止使用print直接提交到发版分支，使用debugPrint替换。" class="headerlink" title="禁止使用print直接提交到发版分支，使用debugPrint替换。"></a>禁止使用print直接提交到发版分支，使用debugPrint替换。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void tryCatch(Function f) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    f?.call();</span><br><span class="line">  &#125; catch (e, stack) &#123;</span><br><span class="line">    debugPrint(&#x27;$e&#x27;);</span><br><span class="line">    debugPrint(&#x27;$stack&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用-来连接它们。"><a href="#两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用-来连接它们。" class="headerlink" title="两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用 + 来连接它们。"></a>两个常量字符串（不是变量，是放在引号中的字符串），你不需要使用 + 来连接它们。</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(</span><br><span class="line">    &#x27;ERROR: Parts of the spaceship are on fire. Other &#x27;</span><br><span class="line">    &#x27;parts are overrun by martians. Unclear which are which.&#x27;);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;ERROR: Parts of the spaceship are on fire. Other &#x27; +</span><br><span class="line">    &#x27;parts are overrun by martians. Unclear which are which.&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="优先使用插值来组合字符串和值。"><a href="#优先使用插值来组合字符串和值。" class="headerlink" title="优先使用插值来组合字符串和值。"></a>优先使用插值来组合字符串和值。</h3><p>如果您之前是用其他语言做开发的，那么您习惯使用+的长链来构建文字和其他值的字符串。 这在Dart中有效，但使用插值总是更清晰，更简短：</p>
<p>推荐写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Hello, $name! You are $&#123;year - birth&#125; years old.&#x27;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Hello, &#x27; + name + &#x27;! You are &#x27; + (year - birth).toString() + &#x27; y...&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="不要在字符串中使用不必要的大括号"><a href="#不要在字符串中使用不必要的大括号" class="headerlink" title="不要在字符串中使用不必要的大括号"></a>不要在字符串中使用不必要的大括号</h3><p>当表达式的值可以为真、假或null，并且您需要将结果传递给不接受null的对象时，此规则适用。一个常见的情况是一个判断空值的方法调用被用作条件:</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Hi, $name!&#x27;</span><br><span class="line">&quot;Wear your wildest $decade&#x27;s outfit.&quot;</span><br><span class="line">//标识符后面有紧跟着的字母了 加上大括号用以区分</span><br><span class="line">&#x27;Wear your wildest $&#123;decade&#125;s outfit.&#x27;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Hi, $&#123;name&#125;!&#x27;</span><br><span class="line">&quot;Wear your wildest $&#123;decade&#125;&#x27;s outfit.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="使用-将空值转换为布尔值。"><a href="#使用-将空值转换为布尔值。" class="headerlink" title="使用? ?将空值转换为布尔值。"></a>使用? ?将空值转换为布尔值。</h3><p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (optionalThing?.isEnabled) &#123;</span><br><span class="line">  print(&quot;Have enabled thing.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果optionalThing为空，此代码将抛出异常。（if只支持判断bool值，不支持null）要解决这个问题，您需要将null值“转换”为true或false。虽然您可以使用&#x3D;&#x3D;来完成此操作，但我们建议使用?? :</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果你想要optionalThing是空值时返回false</span><br><span class="line">optionalThing?.isEnabled ?? false;</span><br><span class="line">//如果你想要optionalThing是空值时返回true</span><br><span class="line">optionalThing?.isEnabled ?? true;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果你想要optionalThing是空值时返回false</span><br><span class="line">optionalThing?.isEnabled == true;</span><br><span class="line">// 如果你想要optionalThing是空值时返回true</span><br><span class="line">optionalThing?.isEnabled != false;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="尽可能的使用集合字面量。"><a href="#尽可能的使用集合字面量。" class="headerlink" title="尽可能的使用集合字面量。"></a>尽可能的使用集合字面量。</h3><p>两种方式来构造一个空的可变 list ： [] 和 List() 。 同样，有三种方式来构造一个空的Map map：{}， Map()， 和 LinkedHashMap() 。 如果想创建一个固定不变的 list 或者其他自定义集合类型，这种情况下你需要使用构造函数。 否则，使用字面量语法更加优雅。 核心库中暴露这些构造函数易于扩展，但是通常在 Dart 代码中并不使用构造函数。</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points = [];</span><br><span class="line">var addresses = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points = List();</span><br><span class="line">var addresses = Map();</span><br></pre></td></tr></table></figure>

<h3 id="如果需要的话，你可以提供一个泛型"><a href="#如果需要的话，你可以提供一个泛型" class="headerlink" title="如果需要的话，你可以提供一个泛型"></a>如果需要的话，你可以提供一个泛型</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points = &lt;Point&gt;[];</span><br><span class="line">var addresses = &lt;String, Address&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var points = List&lt;Point&gt;();</span><br><span class="line">var addresses = Map&lt;String, Address&gt;();</span><br></pre></td></tr></table></figure>

<p>注意，对于集合类的 命名 构造函数则不适用上面的规则。 List.from()、 Map.fromIterable() 都有其使用场景。 如果需要一个固定长度的结合，使用 List() 来创建一个固定长度的 list 也是合理的。</p>
<h3 id="不要使用-length-来判断一个集合是否为空。"><a href="#不要使用-length-来判断一个集合是否为空。" class="headerlink" title="不要使用 .length 来判断一个集合是否为空。"></a>不要使用 .length 来判断一个集合是否为空。</h3><p>通过调用 .length 来判断集合是否包含内容是非常低效的。相反，Dart 提供了更加高效率和易用的 getter 函数：.isEmpty 和.isNotEmpty。 使用这些函数并不需要对结果再次取非(list.length ! &#x3D;0)</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lunchBox.isEmpty) return &#x27;so hungry...&#x27;;</span><br><span class="line">if (words.isNotEmpty) return words.join(&#x27; &#x27;);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (lunchBox.length == 0) return &#x27;so hungry...&#x27;;</span><br><span class="line">if (!words.isEmpty) return words.join(&#x27; &#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="不要使用-List-from-除非想修改结果的类型。"><a href="#不要使用-List-from-除非想修改结果的类型。" class="headerlink" title="不要使用 List.from() 除非想修改结果的类型。"></a>不要使用 List.from() 除非想修改结果的类型。</h3><p>给定一个可迭代的对象，有两种常见方式来生成一个包含相同元素的 list：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var copy1 = iterable.toList();</span><br><span class="line">var copy2 = List.from(iterable);</span><br></pre></td></tr></table></figure>
<p>推荐的写法<br>明显的区别是前一个更短。 更重要的区别在于第一个保留了原始对象的类型参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 List&lt;int&gt;:</span><br><span class="line">var iterable = [1, 2, 3];</span><br><span class="line"> </span><br><span class="line">// 输出 &quot;List&lt;int&gt;&quot;:</span><br><span class="line">print(iterable.toList().runtimeType);</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 List&lt;int&gt;:</span><br><span class="line">var iterable = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">// 输出 &quot;List&lt;dynamic&gt;&quot;:</span><br><span class="line">print(List.from(iterable).runtimeType);</span><br></pre></td></tr></table></figure>

<h3 id="如果你想要改变原始对象的类型参数，那么可以调用-List-from-："><a href="#如果你想要改变原始对象的类型参数，那么可以调用-List-from-：" class="headerlink" title="如果你想要改变原始对象的类型参数，那么可以调用 List.from() ："></a>如果你想要改变原始对象的类型参数，那么可以调用 List.from() ：</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2.3, 4]; // List&lt;num&gt;.</span><br><span class="line">numbers.removeAt(1); // 现在集合里只包含int型</span><br><span class="line">var ints = List&lt;int&gt;.from(numbers);</span><br></pre></td></tr></table></figure>
<p>但是如果你的目的只是复制可迭代对象并且保留元素原始类型， 或者并不在乎类型，那么请使用 toList() 。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="使用-x3D-来分隔参数名和参数默认值。"><a href="#使用-x3D-来分隔参数名和参数默认值。" class="headerlink" title="使用 &#x3D; 来分隔参数名和参数默认值。"></a>使用 &#x3D; 来分隔参数名和参数默认值。</h3><p>由于遗留原因，Dart 同时支持 : 和 &#x3D; 作为参数名和默认值的分隔符。 为了与可选的位置参数保持一致，请使用 &#x3D; 。</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert(Object item, &#123;int at = 0&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert(Object item, &#123;int at: 0&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="不要-为字段创建不必要的-getter-和-setter-方法"><a href="#不要-为字段创建不必要的-getter-和-setter-方法" class="headerlink" title="不要 为字段创建不必要的 getter 和 setter 方法"></a>不要 为字段创建不必要的 getter 和 setter 方法</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var _contents;</span><br><span class="line">  get contents =&gt; _contents;</span><br><span class="line">  set contents(value) &#123;</span><br><span class="line">    _contents = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要使用this-在重定向命名函数和避免冲突的情况下除外"><a href="#不要使用this-在重定向命名函数和避免冲突的情况下除外" class="headerlink" title="不要使用this. 在重定向命名函数和避免冲突的情况下除外"></a>不要使用this. 在重定向命名函数和避免冲突的情况下除外</h3><p>只有当局部变量和成员变量名字一样的时候，你才需要使用 this. 来访问成员变量。 只有两种情况需要使用 this. 。其中一种情况是要访问的局部变量和成员变量命名一样的时候：</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var value;</span><br><span class="line"></span><br><span class="line">  void clear() &#123;</span><br><span class="line">    update(null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void update(value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Box &#123;</span><br><span class="line">  var value;</span><br><span class="line"></span><br><span class="line">  void clear() &#123;</span><br><span class="line">    this.update(null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void update(value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要尽可能的在定义变量的时候初始化变量值。"><a href="#要尽可能的在定义变量的时候初始化变量值。" class="headerlink" title="要尽可能的在定义变量的时候初始化变量值。"></a>要尽可能的在定义变量的时候初始化变量值。</h3><p>如果一个字段不依赖于构造函数中的参数， 则应该在定义的时候就初始化字段值。 这样可以减少需要的代码并可以确保在有多个构造函数的时候你不会忘记初始化该字段。</p>
<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Folder &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final List&lt;Document&gt; contents;</span><br><span class="line"> </span><br><span class="line">  Folder(this.name) : contents = [];</span><br><span class="line">  Folder.temp() : name = &#x27;temporary&#x27;; // Oops! Forgot contents.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Folder &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final List&lt;Document&gt; contents = [];</span><br><span class="line"> </span><br><span class="line">  Folder(this.name);</span><br><span class="line">  Folder.temp() : name = &#x27;temporary&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，对于变量取值依赖构造函数参数的情况以及不同的构造函数取值也不一样的情况， 则不适合本条规则。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="不要-使用-new"><a href="#不要-使用-new" class="headerlink" title="不要 使用 new"></a>不要 使用 new</h3><p>创建对象不要使用new</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Row(</span><br><span class="line">    children: [</span><br><span class="line">      RaisedButton(</span><br><span class="line">        child: Text(&#x27;Increment&#x27;),</span><br><span class="line">      ),</span><br><span class="line">      Text(&#x27;Click!&#x27;),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return new Row(</span><br><span class="line">    children: [</span><br><span class="line">      new RaisedButton(</span><br><span class="line">        child: new Text(&#x27;Increment&#x27;),</span><br><span class="line">      ),</span><br><span class="line">      new Text(&#x27;Click!&#x27;),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要用-来替代空的构造函数体-。"><a href="#要用-来替代空的构造函数体-。" class="headerlink" title="要用 ; 来替代空的构造函数体 {}。"></a>要用 ; 来替代空的构造函数体 {}。</h3><p>在 Dart 中，没有具体函数体的构造函数可以使用分号结尾。 （事实上，这是不可变构造函数的要求。）</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  Point(this.x, this.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  Point(this.x, this.y) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要尽可能的使用初始化形式。"><a href="#要尽可能的使用初始化形式。" class="headerlink" title="要尽可能的使用初始化形式。"></a>要尽可能的使用初始化形式。</h3><p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y;</span><br><span class="line">  Point(num x, num y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x, y,z;</span><br><span class="line">  Point(this.x, this.y,&#123;this.z&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的位于构造函数参数之前的 this. 语法被称之为初始化形式（initializing formal）。 有些情况下这无法使用这种形式。特别是，这种形式下在初始化列表中无法看到变量。 但是如果能使用该方式，就应该尽量使用。（如果使用命名参数）</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。"><a href="#dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。" class="headerlink" title="dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。"></a>dart允许方法不写返回值类型，但是在编码过程中建议将返回值类型写清楚。</h3><p>不推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>推荐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="推荐-使用-async-x2F-await-而不是直接使用底层的特性。"><a href="#推荐-使用-async-x2F-await-而不是直接使用底层的特性。" class="headerlink" title="推荐 使用 async&#x2F;await 而不是直接使用底层的特性。"></a>推荐 使用 async&#x2F;await 而不是直接使用底层的特性。</h3><p>显式的异步代码是非常难以阅读和调试的， 即使使用很好的抽象（比如 future）也是如此。 这就是为何 Dart 提供了 async&#x2F;await。 这样可以显著的提高代码的可读性并且让你可以在异步代码中使用语言提供的所有流程控制语句。</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;int&gt; countActivePlayers(String teamName) async &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var team = await downloadTeam(teamName);</span><br><span class="line">    if (team == null) return 0;</span><br><span class="line"></span><br><span class="line">    var players = await team.roster;</span><br><span class="line">    return players.where((player) =&gt; player.isActive).length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;int&gt; countActivePlayers(String teamName) &#123;</span><br><span class="line">  return downloadTeam(teamName).then((team) &#123;</span><br><span class="line">    if (team == null) return Future.value(0);</span><br><span class="line"></span><br><span class="line">    return team.roster.then((players) &#123;</span><br><span class="line">      return players.where((player) =&gt; player.isActive).length;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).catchError((e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在 Dart 中标识符有三种类型。 • UpperCamelCase 每个单词的首字母都大写，包含第一个单词。 • lowerCamelCase 每个单词的首字母都大写，除了第一个单词， 第一个单词首字母小写，即使是缩略词。 • lowercase_with_underscores 只是用小写字母单词，即使是缩略词， 并且单词之间使用 _ 连接。</p>
<h3 id="使用-UpperCamelCase-风格命名类型。"><a href="#使用-UpperCamelCase-风格命名类型。" class="headerlink" title="使用 UpperCamelCase 风格命名类型。"></a>使用 UpperCamelCase 风格命名类型。</h3><p>Classes（类名）、 enums（枚举类型）、 typedefs（类型定义）、 以及 type parameters（类型参数）应该把每个单词的首字母都大写（包含第一个单词）， 不使用分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SliderMenu &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">class HttpRequest &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">typedef Predicate = bool Function&lt;T&gt;(T value);</span><br></pre></td></tr></table></figure>

<h3 id="要在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名要用-lowercase-with-underscores-风格命名库和源文件名。"><a href="#要在库，包，文件夹，源文件中使用-lowercase-with-underscores-方式命名要用-lowercase-with-underscores-风格命名库和源文件名。" class="headerlink" title="要在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名要用 lowercase_with_underscores 风格命名库和源文件名。"></a>要在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名要用 lowercase_with_underscores 风格命名库和源文件名。</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library peg_parser.source_scanner;</span><br><span class="line"></span><br><span class="line">import &#x27;file_system.dart&#x27;;</span><br><span class="line">import &#x27;slider_menu.dart&#x27;;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library pegparser.SourceScanner;</span><br><span class="line">import &#x27;file-system.dart&#x27;;</span><br><span class="line">import &#x27;SliderMenu.dart&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="要使用-lowercase-with-underscores-风格命名导入的前缀"><a href="#要使用-lowercase-with-underscores-风格命名导入的前缀" class="headerlink" title="要使用 lowercase_with_underscores 风格命名导入的前缀"></a>要使用 lowercase_with_underscores 风格命名导入的前缀</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27; as math;</span><br><span class="line">import &#x27;package:angular_components/angular_components&#x27;</span><br><span class="line">    as angular_components;</span><br><span class="line">import &#x27;package:js/js.dart&#x27; as js;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27; as Math;</span><br><span class="line">import &#x27;package:angular_components/angular_components&#x27;</span><br><span class="line">    as angularComponents;</span><br><span class="line">import &#x27;package:js/js.dart&#x27; as JS;</span><br></pre></td></tr></table></figure>

<h3 id="要-使用-lowerCamelCase-风格来命名其他的标识符。"><a href="#要-使用-lowerCamelCase-风格来命名其他的标识符。" class="headerlink" title="要 使用 lowerCamelCase 风格来命名其他的标识符。"></a>要 使用 lowerCamelCase 风格来命名其他的标识符。</h3><p>类成员、顶级定义、变量、参数以及命名参数等 除了第一个单词，每个单词首字母都应大写，并且不使用分隔符。</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var item;</span><br><span class="line"></span><br><span class="line">HttpRequest httpRequest;</span><br><span class="line"></span><br><span class="line">void align(bool clearItems) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。"><a href="#要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。" class="headerlink" title="要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。"></a>要把超过两个字母的首字母大写缩略词和缩写词当做普通单词。</h3><p>首字母大写缩略词比较难阅读， 特别是多个缩略词连载一起的时候会引起歧义。 例如，一个以 HTTPSFTP 开头的名字， 没有办法判断它是指 HTTPS FTP 还是 HTTP SFTP 。 为了避免上面的情况，缩略词和缩写词要像普通单词一样首字母大写， 两个字母的单词除外。 （像 ID 和 Mr. 这样的双字母缩写词仍然像一般单词一样首字母大写。）</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpConnectionInfo</span><br><span class="line">uiHandler</span><br><span class="line">IOStream</span><br><span class="line">HttpRequest</span><br><span class="line">Id</span><br><span class="line">DB</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPConnection</span><br><span class="line">UiHandler</span><br><span class="line">IoStream</span><br><span class="line">HTTPRequest</span><br><span class="line">ID</span><br><span class="line">Db</span><br></pre></td></tr></table></figure>

<p>• acronyms ：首字母缩略词，指取若干单词首字母组成一个新单词，如：HTTP &#x3D; HyperText Transfer Protocol • abbreviations : 缩写词，指取某一单词的部分字母（或其他缩短单词的方式）代表整个单词，如：ID &#x3D; identification</p>
<h3 id="不要-使用前缀字母"><a href="#不要-使用前缀字母" class="headerlink" title="不要 使用前缀字母"></a>不要 使用前缀字母</h3><p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultTimeout</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kDefaultTimeout</span><br></pre></td></tr></table></figure>

<h3 id="要-使用-googlestyle-格式化你的代码"><a href="#要-使用-googlestyle-格式化你的代码" class="headerlink" title="要 使用 googlestyle 格式化你的代码"></a>要 使用 googlestyle 格式化你的代码</h3><p>格式化是一项繁琐的工作，尤其在重构过程中特别耗时。 庆幸的是，你不必担心。 使用Android studio默认的googlestyle。</p>
<h3 id="要对所有流控制结构使用花括号。"><a href="#要对所有流控制结构使用花括号。" class="headerlink" title="要对所有流控制结构使用花括号。"></a>要对所有流控制结构使用花括号。</h3><p>这样可以避免 dangling else （else悬挂）的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (isWeekDay) &#123;</span><br><span class="line">  print(&#x27;Bike to work!&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print(&#x27;Go dancing or read a book!&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个例外：一个没有 else 的 if 语句， 并且这个 if 语句以及它的执行体适合在一行中实现。 在这种情况下，如果您愿意，可以不用括号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (arg == null) return defaultValue;</span><br></pre></td></tr></table></figure>

<p>但是，如果执行体包含下一行，请使用大括号：</p>
<p>推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (overflowChars != other.overflowChars) &#123;</span><br><span class="line">  return overflowChars &lt; other.overflowChars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (overflowChars != other.overflowChars)</span><br><span class="line">  return overflowChars &lt; other.overflowChars;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/15/SoftWare/coderunner/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/SoftWare/coderunner/" class="post-title-link" itemprop="url">coderunner使用问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-15 19:01:29" itemprop="dateCreated datePublished" datetime="2021-09-15T19:01:29+08:00">2021-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CodeRunner本身是一个收费软件，功能强大，好处就不说了。在一些破解网站上可以找到破解版的，断网输入对应的激活码就能破解成功。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>每次重新打开，都需要重新破解。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>猜想的是每次打开CodeRunner时都会向其主站发送消息，查看是否激活，这里就是通过直接断开链接的方式来处理。</p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>Mac系统下打开<code>/private/etc/</code>文件，hosts是文本。</p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>在hosts文件中，增加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># CodeRunner App</span><br><span class="line">127.0.0.1 coderunnerapp.com</span><br></pre></td></tr></table></figure>

<p>这样就可以验证成功了，不需要每次都重新激活。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-logos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-8-logos/" class="post-title-link" itemprop="url">nx-8-logos</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 16:27:26" itemprop="dateCreated datePublished" datetime="2021-09-13T16:27:26+08:00">2021-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/09/13/%E9%80%86%E5%90%91/nx-8-lldb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E9%80%86%E5%90%91/nx-8-lldb/" class="post-title-link" itemprop="url">nx-8-lldb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 16:11:20" itemprop="dateCreated datePublished" datetime="2021-09-13T16:11:20+08:00">2021-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
