<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="7YX7D_5ZgZrLulaEJCyP7hdImKU5ZRaBQZq4_08P9bM">
  <meta name="baidu-site-verification" content="code-VKw4oO6kcH">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liujiaboy.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="不会飞的小白">
<meta property="og:url" content="http://liujiaboy.github.io/page/5/index.html">
<meta property="og:site_name" content="不会飞的小白">
<meta property="og:description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不会飞的小白">
<meta property="article:tag" content="iOS, Swift, GitHub, CocoaPods">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://liujiaboy.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>不会飞的小白</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=253081122"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '253081122');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不会飞的小白</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/OC%E5%8E%9F%E7%90%86/oc-4-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">4.类的本质</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 13:39:47" itemprop="dateCreated datePublished" datetime="2021-04-18T13:39:47+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-对象、类对象、元类"><a href="#1-对象、类对象、元类" class="headerlink" title="1. 对象、类对象、元类"></a>1. 对象、类对象、元类</h1><h2 id="1-1-isa指向、superClass指向"><a href="#1-1-isa指向、superClass指向" class="headerlink" title="1.1 isa指向、superClass指向"></a>1.1 isa指向、superClass指向</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/** //先把这里的协议注释掉，用到的时候再打开</span><br><span class="line">@protocol PersonProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *p_address;</span><br><span class="line"></span><br><span class="line">- (void)p_func1;</span><br><span class="line">+ (void)p_func1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *_hobby;</span><br><span class="line">    CGFloat _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic) int age;</span><br><span class="line"></span><br><span class="line">- (void)func1;</span><br><span class="line">- (void)func2;</span><br><span class="line">+ (void)func3;</span><br><span class="line">+ (void)func4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Teacher : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 然后执行，直接打断点。</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">Teacher *t = [[Teacher alloc] init];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们根据述代码进行分析，isa指针的指向。</p>
<blockquote>
<p>注意，这里是用的是模拟器</p>
</blockquote>
<h2 id="1-2-实例对象的isa"><a href="#1-2-实例对象的isa" class="headerlink" title="1.2 实例对象的isa"></a>1.2 实例对象的isa</h2><p>首先我们先看Person的实例p的isa指向情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 首先打印一下p的内存情况</span><br><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x1006460b0&gt;</span><br><span class="line">// 输出p指针的情况</span><br><span class="line">(lldb) x/4gx p</span><br><span class="line">0x1006460b0: 0x011d8001000083f9 0x0000000000000000</span><br><span class="line">0x1006460c0: 0x0000000000000000 0x0000000000000000</span><br><span class="line"></span><br><span class="line">(lldb) p p 0x011d8001000083f9</span><br><span class="line">(long) $6 = 1791002988741</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里拿到p指针指向的内存情况，我们知道第一块内存区域存放的是isa指针，直接打印的话，发现就是一串数字，啥也看不出来。还记得上一章中object_getClass反向验证isa指向最后的”&amp;”运算吗？<code>0x011d8001000083f9</code>这个值就是isa-&gt;bits，我们用它与<code>ISA_MASK</code>进行&amp;运算。因为这里是用的真机，所以<code>ISA_MASK = 0x00007ffffffffff8</code>，如果是用Mac或者模拟器，根据芯片类型判断是否是ARM64架构还是x86，然后使用对应的值进行换算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// p/x输出内存的16进制</span><br><span class="line">(lldb) p/x 0x011d8001000083f9 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $2 = 0x00000001000083f8</span><br><span class="line"></span><br><span class="line">// 这里po就是Person类</span><br><span class="line">(lldb) po 0x00000001000083f8</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>

<p>打印出来是Person。所以isa指向的就是Person类。那我们做一下验证，直接通过<code>object_getClass</code>方法来找一下Person这个类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x object_getClass(p)</span><br><span class="line">(Class) $12 = 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure>

<p>是不是发现，Person类的内存地址是一样的。如果再实例化一个p1，看p1-&gt;isa指向的和p-&gt;isa指向的是否是同一个Person类的内存地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 直接使用object_getClass获取类对象。</span><br><span class="line">lldb) p/x object_getClass([Person alloc])</span><br><span class="line">(Class) $26 = 0x00000001000083f8 Person</span><br></pre></td></tr></table></figure>
<p>答案是肯定的，Person类在内存中只有一份，也就是说所有的类对象在内存中都只有一份。</p>
<h2 id="1-3-类对象的isa"><a href="#1-3-类对象的isa" class="headerlink" title="1.3 类对象的isa"></a>1.3 类对象的isa</h2><p>接下来，我们继续寻找Person类对象的isa指向情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p 0x000001a10018d0c5</span><br><span class="line">(long) $6 = 1791002988741</span><br><span class="line"></span><br><span class="line">(lldb) x/4gx 0x00000001000083f8</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x0000000100645d60 0x0001803000000003</span><br><span class="line"></span><br><span class="line">(lldb) p/x 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $4 = 0x00000001000083d0</span><br><span class="line">(lldb) po 0x00000001000083d0</span><br><span class="line">Person</span><br></pre></td></tr></table></figure>
<p>发现Person类对象的isa指向的还是Person，但是这个Person所在的内存地址与Person类对象不一样。</p>
<p>这里就出现了元类的概念（Meta Class）。</p>
<h2 id="1-4-元类的isa"><a href="#1-4-元类的isa" class="headerlink" title="1.4 元类的isa"></a>1.4 元类的isa</h2><p>我们继续寻找元类的isa</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 0x00000001000083d0是Person元类所在的内存</span><br><span class="line">(lldb) x/4gx 0x00000001000083d0</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x0000000100714d10 0x0002e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p/x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $9 = 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">// 拿到NSObject的地址继续x/4gx</span><br><span class="line">(lldb) x/4gx 0x000000010036a0f0</span><br><span class="line">0x10036a0f0: 0x000000010036a0f0 0x000000010036a140</span><br><span class="line">0x10036a100: 0x00000001007877b0 0x0003e03100000007</span><br></pre></td></tr></table></figure>

<p>使用相同的方法找到元类的<code>isa</code>指向的是<code>NSObject</code>，这个<code>NSObject</code>是类对象吗？</p>
<p>对<code>NSObject</code>继续<code>x/4gx</code>发现<code>isa</code>锁指向的内存地址是一样的。</p>
<p>我们通过<code>object_getClass([[NSObject alloc] init])</code>来看看<code>NSObject</code>类对象的内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 获取NSObject类的地址，与p/x NSObject.class效果一致</span><br><span class="line">(lldb) p/x object_getClass([NSObject alloc])</span><br><span class="line">(Class) $13 = 0x000000010036a140 NSObject</span><br><span class="line"></span><br><span class="line">(lldb) x/4gx 0x000000010036a140</span><br><span class="line">0x10036a140: 0x000000010036a0f0 0x0000000000000000</span><br><span class="line">0x10036a150: 0x0000000100786740 0x0002801000000003</span><br><span class="line"></span><br><span class="line">// 从这里开始，就已经跟上面的内存地址重复了</span><br><span class="line">(lldb) p/x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $14 = 0x000000010036a0f0</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>到这里，是不是看明白了点啥？<code>NSObject</code>类对象也有指向<code>NSObject</code>的元类，<code>Person</code>的元类的<code>isa</code>指向的是<code>NSObject</code>的元类。</p>
<h3 id="1-5-使用相同的办法查看Teacher的isa"><a href="#1-5-使用相同的办法查看Teacher的isa" class="headerlink" title="1.5 使用相同的办法查看Teacher的isa"></a>1.5 使用相同的办法查看Teacher的isa</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 这里使用简单的方式，直接使用Teacher类</span><br><span class="line">(lldb) x/4gx Teacher.class</span><br><span class="line">0x100008380: 0x00000001000083a8 0x00000001000083f8</span><br><span class="line">0x100008390: 0x0000000100362370 0x0000803000000000</span><br><span class="line"></span><br><span class="line">(lldb) p/x 0x00000001000083a8 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $18 = 0x00000001000083a8</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000001000083a8</span><br><span class="line">Teacher</span><br><span class="line"></span><br><span class="line">(lldb) x/4gx 0x00000001000083a8</span><br><span class="line">0x1000083a8: 0x000000010036a0f0 0x00000001000083d0</span><br><span class="line">0x1000083b8: 0x0000000101138140 0x0001e03100000003</span><br><span class="line"></span><br><span class="line">(lldb) p/x 0x000000010036a0f0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $20 = 0x000000010036a0f0</span><br><span class="line">// 这里又指向了NSObject</span><br><span class="line">(lldb) po 0x000000010036a0f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>看到这里应该发现了点东西吧。实例对象的isa-&gt;类对象的isa-&gt;NSObject的isa，中间类对象与继承没有一丢丢关系。</p>
<h3 id="1-6-类的继承链"><a href="#1-6-类的继承链" class="headerlink" title="1.6 类的继承链"></a>1.6 类的继承链</h3><p>上面我们查看了isa的走向，接下来看一下继承链。首先看一下类的继承关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void testSuperClass(void)&#123;</span><br><span class="line">    Teacher *t = [Teacher alloc];</span><br><span class="line">    Person  *p = [Person alloc];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Teacher.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(Person.class));</span><br><span class="line">    NSLog(@&quot;%@&quot;,class_getSuperclass(NSObject.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里输出一下对应类的<code>superclass</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br><span class="line">NSObject</span><br><span class="line">(null)</span><br></pre></td></tr></table></figure>

<p>从打印出来的信息可以看到:</p>
<ul>
<li>Teacher   -&gt; superclass &#x3D; Person</li>
<li>Person    -&gt; superClass &#x3D; NSObject</li>
<li>NSObject  -&gt; superClass &#x3D; null</li>
</ul>
<h3 id="1-7-元类的继承链"><a href="#1-7-元类的继承链" class="headerlink" title="1.7 元类的继承链"></a>1.7 元类的继承链</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void testNSObject(void) &#123;</span><br><span class="line">    // NSObject实例对象</span><br><span class="line">    NSObject *object1 = [NSObject alloc];</span><br><span class="line">    // NSObject类</span><br><span class="line">    Class cls = object_getClass(object1);</span><br><span class="line">    // NSObject元类</span><br><span class="line">    Class metaClass = object_getClass(cls);</span><br><span class="line">    // NSObject根元类</span><br><span class="line">    Class rootMetaClass = object_getClass(metaClass);</span><br><span class="line">    // NSObject根根元类</span><br><span class="line">    Class rootRootMetaClass = object_getClass(rootMetaClass);</span><br><span class="line">    NSLog(@&quot;\n%p 实例对象\n%p 类\n%p 元类\n%p 根元类\n%p 根根元类&quot;,object1,cls,metaClass,rootMetaClass,rootRootMetaClass);</span><br><span class="line">    </span><br><span class="line">    // Person元类</span><br><span class="line">    Class pMetaClass = object_getClass(Person.class);</span><br><span class="line">    Class psuperClass = class_getSuperclass(pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,pMetaClass,pMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,psuperClass,psuperClass);</span><br><span class="line">    </span><br><span class="line">    // Teacher -&gt; Person -&gt; NSObject</span><br><span class="line">    // 元类也有一条继承链</span><br><span class="line">    Class tMetaClass = object_getClass(Teacher.class);</span><br><span class="line">    Class tsuperClass = class_getSuperclass(tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tMetaClass,tMetaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,tsuperClass,tsuperClass);</span><br><span class="line">    </span><br><span class="line">    // NSObject 根类特殊情况</span><br><span class="line">    Class nsuperClass = class_getSuperclass(NSObject.class);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,nsuperClass,nsuperClass);</span><br><span class="line">    // 根元类 -&gt; NSObject</span><br><span class="line">    Class rnsuperClass = class_getSuperclass(metaClass);</span><br><span class="line">    NSLog(@&quot;%@ - %p&quot;,rnsuperClass,rnsuperClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下输出结果：</p>
<ol>
<li><p>首先输出的NSObject的isa走位。NSObject实例对象 -&gt; 类 -&gt; 元类</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x10124ba40 实例对象</span><br><span class="line">0x10036a140 类</span><br><span class="line">0x10036a0f0 元类</span><br><span class="line">0x10036a0f0 根元类</span><br><span class="line">0x10036a0f0 根根元类</span><br></pre></td></tr></table></figure>
<p> 从这里的输出结果可以进一步判断出NSObject类对象的元类指向它自己。</p>
</li>
<li><p>Person类对象的元类 -&gt; super</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Person类对象的元类</span><br><span class="line">Person - 0x100008498</span><br><span class="line">// Person类对象的元类 -&gt; super</span><br><span class="line">NSObject - 0x10036a0f0</span><br></pre></td></tr></table></figure>
<p> 从地址的打印信息可以看出来，person类的元类的super指向的是NSObject类的元类。</p>
</li>
<li><p>Teacher元类</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Teacher类对象的元类</span><br><span class="line">Teacher - 0x100008470</span><br><span class="line">// Teacher类对象的元类 -&gt; super</span><br><span class="line">Person - 0x100008498</span><br></pre></td></tr></table></figure>
<p> 从这里可以看出来，Teacher元类的super指向的Person的元类，地址信息都是相同的。</p>
</li>
</ol>
<p>从上面的流程可以看到，类的继承关系和对应元类的继承关系是相对应的。可以用一张图完美的诠释isa的走向和super的指向。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="isa_metaclass.png"></p>
<ul>
<li>每个实例对象的isa指针指向与之对应的类对象(Class)。</li>
<li>每个类对象(Class)都有一个isa指针指向一个唯一的元类(Meta Class)。</li>
<li>每一个元类(Meta Class)的isa指针都指向最上层的元类(Meta Class)（图中的NSObject的Meta Class）。最上层的元类(Meta Class)的isa指针指向自己，形成一个回路。</li>
<li>每一个元类(Meta Class)的Super Class指向它原本Class的Super Class的Meta Class。最上层的Meta Class的Super Class指向NSObject Class本身。</li>
<li>最上层的NSObject Class的Super Class指向nil。</li>
<li>只有Class才有继承关系，实例对象与实例对象不存在继承关系。</li>
<li>每一个类对象(Class)在内存中都只有一份。</li>
</ul>
<h1 id="2-通过源码分析"><a href="#2-通过源码分析" class="headerlink" title="2. 通过源码分析"></a>2. 通过源码分析</h1><p>接下来我们从objc的源码上分析这些都是什么东西。</p>
<h2 id="2-1-实例对象-id（Instance）"><a href="#2-1-实例对象-id（Instance）" class="headerlink" title="2.1 实例对象 id（Instance）"></a>2.1 实例对象 id（Instance）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>id 这个struct的定义本身就带了 个 ＊, 所以我们在使用其他NSObject类型的实例时需要在前加上 ＊, 使 id 时却不用 。</p>
<p>什么是objc_object?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class. </span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>这个时候我们知道Objective-C中的object在最后会被转换成C的结构体, 在这个struct中有 个 isa 指针,指向它的类别 Class。 </p>
<h2 id="2-2-类对象-Class"><a href="#2-2-类对象-Class" class="headerlink" title="2.2 类对象 Class"></a>2.2 类对象 Class</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>Class的本质就是一个<code>objc_class</code>的结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 注意，这个源码是被简化之后的。</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">  </span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line"></span><br><span class="line">    Class getSuperclass() const &#123;</span><br><span class="line">        return superclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setSuperclass(Class newSuperclass) &#123;</span><br><span class="line">        superclass = newSuperclass;</span><br><span class="line">    &#125;</span><br><span class="line">    // 用这个是无法获取rw_t，只能通过内存偏移获取bits，然后再获取rw_t</span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isRootClass() &#123;</span><br><span class="line">        return getSuperclass() == nil;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isRootMetaclass() &#123;</span><br><span class="line">        return ISA() == (Class)this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个结构体，大家可能会觉得不对，这个源码是错的，不是我们经常看到的，里头没有那些我们常说的变量，methodLists、ivars等等。<br>大家看仔细了哦，下面这个实现基本都是大家常看到的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;  </span><br><span class="line">    ...</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>里头确实有ivars、methodLists等，但是这个是<code>OBJC2_UNAVAILABLE</code>（我们目前使用的Objective-C的版本是2.0版本）。其内部确实有这些东西的，我们一步步去探究。</p>
<p>继续回到上面的结构体，发现ISA变量被注释掉了，其实也没有影响的，因为<code>objc_class</code> 继承自 <code>objc_object</code>（内部有isa变量）。那我们的属性、方法是存放在哪了呢？</p>
<p>通过查看源码，我们看到有这么一个属性<code>class_data_bits_t bits;</code>，这个东西里可能存放着我们需要的东西。稍后我们做验证。</p>
<h2 id="2-3-元类-Meta-Class"><a href="#2-3-元类-Meta-Class" class="headerlink" title="2.3 元类 Meta Class"></a>2.3 元类 Meta Class</h2><p>OC中一切皆为对象<br>Class在设计中本身也是一个对象,也有superclass。而这个Class对应的类我们叫“元类”（Meta Class）。也就是说Class中有一个isa指向的是Meta Class。</p>
<h1 id="3-验证属性、方法、协议存在的位置"><a href="#3-验证属性、方法、协议存在的位置" class="headerlink" title="3 验证属性、方法、协议存在的位置"></a>3 验证属性、方法、协议存在的位置</h1><h2 id="3-1-验证之前的准备-源码"><a href="#3-1-验证之前的准备-源码" class="headerlink" title="3.1 验证之前的准备 - 源码"></a>3.1 验证之前的准备 - 源码</h2><p>在2.2小结我们说了属性、方法、等可能存在于<code>class_data_bits_t</code>这个结构体内部，我们查看它的源码：</p>
<h3 id="3-1-1-class-data-bits-t"><a href="#3-1-1-class-data-bits-t" class="headerlink" title="3.1.1 class_data_bits_t"></a>3.1.1 class_data_bits_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line"></span><br><span class="line">    // Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">        class_rw_t *maybe_rw = data();</span><br><span class="line">        if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">            // maybe_rw is rw</span><br><span class="line">            return maybe_rw-&gt;ro();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // maybe_rw is actually ro</span><br><span class="line">            return (class_ro_t *)maybe_rw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在public的方法中有<code>class_rw_t* data()</code>这个方法，我们进一步探索：</p>
<h3 id="3-1-2-class-rw-t"><a href="#3-1-2-class-rw-t" class="headerlink" title="3.1.2 class_rw_t"></a>3.1.2 class_rw_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint16_t witness;</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint16_t index;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    const method_array_t methods() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const property_array_t properties() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const protocol_array_t protocols() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实如我们所说的，这里确实存在着我们想要的东西：methods()、properties()、protocols()等。</p>
<p>那我们该怎么获取到这些数据，来证明这些就是我们想要的东西呢？</p>
<h3 id="3-1-3-内存偏移"><a href="#3-1-3-内存偏移" class="headerlink" title="3.1.3 内存偏移"></a>3.1.3 内存偏移</h3><p>我们知道在c语言中，一个数组，获取数组中的某个元素的值有多种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;1,2,3&#125;;</span><br><span class="line">printf(&quot;index 1 = %d - %d&quot;, a[1], *(a+1));</span><br></pre></td></tr></table></figure>

<p>比如上面的代码，我们可以直接输出某个元素的下标，也可以通过内存地址来偏移进行读取，同样，我们也可以采取地址偏移来获取<code>objc_class-&gt;bits</code>的值。</p>
<p>需要偏移多少呢？</p>
<p>第一个变量是Class，这是一个结构体，内部有一个isa指针，所以这是8个字节。<br>第二个变量是cache_t，我们进源码看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">private:</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;    // 8</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask;      // 4</span><br><span class="line">#if __LP64__</span><br><span class="line">            uint16_t                   _flags;          // 2</span><br><span class="line">#endif</span><br><span class="line">            uint16_t                   _occupied;       // 2</span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache; // 8</span><br><span class="line">    &#125;;</span><br><span class="line">...   </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实这些就能算出来我们需要多少字节，我已经标好了。静态变量和方法是没有算在结构体内部的哈，而且cache_t内部有一个共用体，所以其所占用的空间一共是8，再加上<code>_bucketsAndMaybeMask</code>变量一共是16个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class ISA;              // 8</span><br><span class="line">Class superclass;       // 8</span><br><span class="line">cache_t cache;          // 16</span><br><span class="line">class_data_bits_t bits;</span><br></pre></td></tr></table></figure>
<p>所以8+8+16 &#x3D; 32个字节。</p>
<p>也就是我们获取到的<code>objc_class</code>的isa指针，然后偏移32个字节，也就是<code>0x20</code>。当然也可以直接通过lldb输出<code>sizeOf(cache_t)</code>来获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p sizeof(cache_t)</span><br><span class="line">(unsigned long) $4 = 16</span><br></pre></td></tr></table></figure>

<p>我们做一下验证，看看属性在哪。其实需要注意的一点是，我们要获取的是类对象，从类对象中查看我们的变量、方法和协议等，而不是从实例对象中获取，因为实例对象是已经在内存中了，比如属性已经有了具体的值了。</p>
<h3 id="3-1-4-method-array-t"><a href="#3-1-4-method-array-t" class="headerlink" title="3.1.4 method_array_t"></a>3.1.4 method_array_t</h3><p>我们继续跟踪源码，查看<code>method_array_t</code>是个啥。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class method_array_t : </span><br><span class="line">    public list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    method_array_t() : Super() &#123; &#125;</span><br><span class="line">    method_array_t(method_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *beginCategoryMethodLists() const &#123;</span><br><span class="line">        return beginLists();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const method_list_t_authed_ptr&lt;method_list_t&gt; *endCategoryMethodLists(Class cls) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们猜测我们想要的数据是在<code>method_list_t</code>中，而<code>method</code>就是我们的每一个的方法等结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    struct big &#123;</span><br><span class="line">        SEL name;</span><br><span class="line">        const char *types;</span><br><span class="line">        MethodListIMP imp;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 中间代码有删减</span><br><span class="line">public:</span><br><span class="line">    big &amp;big() const &#123;</span><br><span class="line">        ASSERT(!isSmall());</span><br><span class="line">        return *(struct big *)this;</span><br><span class="line">    &#125;</span><br><span class="line">    // 中间代码有删减</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="3-1-5-property-array-t"><a href="#3-1-5-property-array-t" class="headerlink" title="3.1.5 property_array_t"></a>3.1.5 property_array_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class property_array_t : </span><br><span class="line">    public list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;property_t, property_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    property_array_t() : Super() &#123; &#125;</span><br><span class="line">    property_array_t(property_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 同methods方法，我们看一下property_t</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-6-protocol-array-t"><a href="#3-1-6-protocol-array-t" class="headerlink" title="3.1.6 protocol_array_t"></a>3.1.6 protocol_array_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class protocol_array_t : </span><br><span class="line">    public list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    typedef list_array_tt&lt;protocol_ref_t, protocol_list_t, RawPtr&gt; Super;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    protocol_array_t() : Super() &#123; &#125;</span><br><span class="line">    protocol_array_t(protocol_list_t *l) : Super(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef uintptr_t protocol_ref_t;  // protocol_t *, but unremapped</span><br></pre></td></tr></table></figure>

<p>这三个分别对应<code>methods()、properties()、protocols()</code>方法，里头也一个共同点就是<code>protocol_array_t</code>。那我们重点看一下list_array_tt的结构。</p>
<h3 id="3-1-7-list-array-tt"><a href="#3-1-7-list-array-tt" class="headerlink" title="3.1.7 list_array_tt"></a>3.1.7 list_array_tt</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class list_array_tt &#123;</span><br><span class="line">    struct array_t &#123;</span><br><span class="line">        uint32_t count;</span><br><span class="line">        Ptr&lt;List&gt; lists[0];</span><br><span class="line"></span><br><span class="line">        static size_t byteSize(uint32_t count) &#123;</span><br><span class="line">            return sizeof(array_t) + count*sizeof(lists[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        size_t byteSize() &#123;</span><br><span class="line">            return byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">    // 这是一个迭代器</span><br><span class="line">    class iterator &#123;</span><br><span class="line">        const Ptr&lt;List&gt; *lists;</span><br><span class="line">        const Ptr&lt;List&gt; *listsEnd;</span><br><span class="line">        typename List::iterator m, mEnd;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        // 迭代器相关的方法</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    union &#123;</span><br><span class="line">        Ptr&lt;List&gt; list;</span><br><span class="line">        uintptr_t arrayAndFlag;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>list_array_tt</code>结构体大概的可以看出来，<code>list_array_tt</code>只是一个list的封装。以<code>property_array_t</code>为例：</p>
<p><code>list_array_tt&lt;property_t, property_list_t, RawPtr&gt;</code>就是一个存放了<code>property_t</code>类型的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    Ptr&lt;List&gt; list;</span><br><span class="line">    uintptr_t arrayAndFlag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个<code>union</code>共用体才是一个list_array_tt对外暴露的真是结构，一会我们通过lldb进行验证。</p>
<h1 id="4-lldb-验证属性存放的位置"><a href="#4-lldb-验证属性存放的位置" class="headerlink" title="4 lldb 验证属性存放的位置"></a>4 lldb 验证属性存放的位置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/6gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line">0x100008418: 0x00000001012042e4 0x00000001000b9970</span><br><span class="line"></span><br><span class="line">// 通过指针偏移0x20，也就是0x1000083f8+0x20，加上强制转换</span><br><span class="line">(lldb) p (class_data_bits_t *)0x100008418</span><br><span class="line">(class_data_bits_t *) $1 = 0x0000000100008418</span><br><span class="line"></span><br><span class="line">// 拿到变量bits之后，通过class_data_bits_t -&gt; data()函数获取rw_t</span><br><span class="line">(lldb) p $1-&gt;data()</span><br><span class="line">(class_rw_t *) $2 = 0x00000001012042e0</span><br><span class="line"></span><br><span class="line">// 看一下class_rw_t都有哪些值</span><br><span class="line">(lldb) p *$2</span><br><span class="line">(class_rw_t) $4 = &#123;</span><br><span class="line">  flags = 2156396544</span><br><span class="line">  witness = 1</span><br><span class="line">  ro_or_rw_ext = &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; = &#123;</span><br><span class="line">      Value = 4295000480</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = Teacher</span><br><span class="line">  nextSiblingClass = NSBinder</span><br><span class="line">&#125;</span><br><span class="line">// 如果有Subclass，则会有firstSubclass=Teacher，如果没有子类则是nil</span><br><span class="line"></span><br><span class="line">// 我们在class_rw_t中已经查看过源码，可以通过properties()获取属性列表</span><br><span class="line">(lldb) p $2-&gt;properties()</span><br><span class="line">(const property_array_t) $5 = &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = &#123;</span><br><span class="line">        ptr = 0x0000000100008320</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag = 4295000864</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合我们上面分析的结果，<code>property_array_t</code>输出的数据与上方<code>list_array_tt</code>内部的<code>union</code>共用体的结构是一直的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取属性列表</span><br><span class="line">(lldb) p $5.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $6 = &#123;</span><br><span class="line">  ptr = 0x0000000100008320</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">(lldb) p $6.ptr</span><br><span class="line">(property_list_t *const) $7 = 0x0000000100008320</span><br><span class="line">(lldb) p *$7</span><br><span class="line">(property_list_t) $8 = &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; = (entsizeAndFlags = 16, count = 2)</span><br><span class="line">&#125;</span><br><span class="line">// $8也就是我们的ptr内存储的列表</span><br></pre></td></tr></table></figure>

<p>但是<code>entsize_list_tt</code>又是什么类型？我们又该通过那种方式来获取我们最后想要的property呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    // </span><br><span class="line">    Element&amp; getOrEnd(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt;= count);</span><br><span class="line">        return *PointerModifier::modify(*this, (Element *)((uint8_t *)this + sizeof(*this) + i*entsize()));</span><br><span class="line">    &#125;</span><br><span class="line">    // 注意。这里有一个 【&amp;】符号，调用getOrEnd，返回的是一个指针，进行转换</span><br><span class="line">    Element&amp; get(uint32_t i) const &#123; </span><br><span class="line">        ASSERT(i &lt; count);</span><br><span class="line">        return getOrEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>entsize_list_tt</code>内部有get方法，来获取其中的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $8.get(0)</span><br><span class="line">(property_t) $9 = (name = &quot;name&quot;, attributes = &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $8.get(1)</span><br><span class="line">(property_t) $10 = (name = &quot;age&quot;, attributes = &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) </span><br><span class="line">(lldb) p $8.get(2)</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2/runtime/objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br></pre></td></tr></table></figure>

<p>到这里，我们就输出了我们定义的2个属性，但是变量却没有在这里提现出来。我们继续看ivar存放在哪。</p>
<h1 id="5-lldb-成员变量"><a href="#5-lldb-成员变量" class="headerlink" title="5. lldb 成员变量"></a>5. lldb 成员变量</h1><p>从上面我们知道属性都存放在<code>class_rw_t</code>中，在查看<code>class_data_bits_t</code>源码的时候，也有看到<code>class_ro_t</code>。那ivar会不会就在这里呢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// class_data_bits_t 内部</span><br><span class="line"></span><br><span class="line">const class_ro_t *safe_ro() const &#123;</span><br><span class="line">    class_rw_t *maybe_rw = data();</span><br><span class="line">    if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">        // maybe_rw is rw</span><br><span class="line">        return maybe_rw-&gt;ro();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // maybe_rw is actually ro</span><br><span class="line">        return (class_ro_t *)maybe_rw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    union &#123;</span><br><span class="line">        const uint8_t * ivarLayout;</span><br><span class="line">        Class nonMetaclass;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;const char *&gt; name;</span><br><span class="line">    // With ptrauth, this is signed if it points to a small list, but</span><br><span class="line">    // may be unsigned if it points to a big list.</span><br><span class="line">    void *baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    // 这里存放的是ivars</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>有了获取property的经验，这里就方便多了，我们按照相同的方式来获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// $1 (class_data_bits_t *) </span><br><span class="line">(lldb) p $1-&gt;safe_ro()</span><br><span class="line">(const class_ro_t *) $11 = 0x00000001000081a0</span><br><span class="line">(lldb) p *$11</span><br><span class="line">(const class_ro_t) $12 = &#123;</span><br><span class="line">  flags = 0</span><br><span class="line">  instanceStart = 8</span><br><span class="line">  instanceSize = 40</span><br><span class="line">  reserved = 0</span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = 0x0000000000000000</span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    std::__1::atomic&lt;const char *&gt; = &quot;Person&quot; &#123;</span><br><span class="line">      Value = 0x0000000100003edc &quot;Person&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = 0x00000001000081e8</span><br><span class="line">  baseProtocols = 0x0000000000000000</span><br><span class="line">  ivars = 0x0000000100008298</span><br><span class="line">  weakIvarLayout = 0x0000000000000000</span><br><span class="line">  baseProperties = 0x0000000100008320</span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从打印中的内容可以大致的猜测ivar应该存放在ivars。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $11.ivars</span><br><span class="line">(const ivar_list_t *const) $13 = 0x0000000100008298</span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    $11-&gt;ivars</span><br><span class="line">(lldb) p $11-&gt;ivars</span><br><span class="line">(const ivar_list_t *const) $14 = 0x0000000100008298</span><br><span class="line">(lldb) p *$14</span><br><span class="line">(const ivar_list_t) $15 = &#123;</span><br><span class="line">  entsize_list_tt&lt;ivar_t, ivar_list_t, 0, PointerModifierNop&gt; = (entsizeAndFlags = 32, count = 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 与property list是相同的结构</span><br><span class="line">(lldb) p $15.get(0)</span><br><span class="line">(ivar_t) $16 = &#123;</span><br><span class="line">  offset = 0x0000000100008360</span><br><span class="line">  name = 0x0000000100003f06 &quot;_hobby&quot;</span><br><span class="line">  type = 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw = 3</span><br><span class="line">  size = 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(1)</span><br><span class="line">(ivar_t) $17 = &#123;</span><br><span class="line">  offset = 0x0000000100008368</span><br><span class="line">  name = 0x0000000100003f0d &quot;_height&quot;</span><br><span class="line">  type = 0x0000000100003f6f &quot;d&quot;</span><br><span class="line">  alignment_raw = 3</span><br><span class="line">  size = 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(2)</span><br><span class="line">(ivar_t) $18 = &#123;</span><br><span class="line">  offset = 0x0000000100008370</span><br><span class="line">  name = 0x0000000100003f15 &quot;_age&quot;</span><br><span class="line">  type = 0x0000000100003f71 &quot;i&quot;</span><br><span class="line">  alignment_raw = 2</span><br><span class="line">  size = 4</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.get(3)</span><br><span class="line">(ivar_t) $19 = &#123;</span><br><span class="line">  offset = 0x0000000100008378</span><br><span class="line">  name = 0x0000000100003f1a &quot;_name&quot;</span><br><span class="line">  type = 0x0000000100003f63 &quot;@\&quot;NSString\&quot;&quot;</span><br><span class="line">  alignment_raw = 3</span><br><span class="line">  size = 8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p>到这里，我们也获取到了变量的位置，也说明了定义的属性会默认生成带下划线的同名变量。</p>
<p>接下来就是方法了。</p>
<h1 id="6-实例方法"><a href="#6-实例方法" class="headerlink" title="6. 实例方法"></a>6. 实例方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $20 = &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = &#123;</span><br><span class="line">        ptr = 0x00000001000081e8</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag = 4295000552</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 与属性一致</span><br><span class="line">(lldb) p $20.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $21 = &#123;</span><br><span class="line">  ptr = 0x00000001000081e8</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $21.ptr</span><br><span class="line">(method_list_t *const) $22 = 0x00000001000081e8</span><br><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; = (entsizeAndFlags = 27, count = 7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p $23.get(0)</span><br><span class="line">(method_t) $24 = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照属性的方式继续输出，结果<code>$23.get(0)</code>输出的确实空内容。</p>
<p>在说method_t时，结构体内部有<code>big()</code>的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $23.get(0).big()</span><br><span class="line">(method_t::big) $26 = &#123;</span><br><span class="line">  name = &quot;func1&quot;</span><br><span class="line">  types = 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000100003c90 (AL-Objc`-[Person func1])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(1).big()</span><br><span class="line">(method_t::big) $27 = &#123;</span><br><span class="line">  name = &quot;func2&quot;</span><br><span class="line">  types = 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000100003cc0 (AL-Objc`-[Person func2])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(2).big()</span><br><span class="line">(method_t::big) $28 = &#123;</span><br><span class="line">  name = &quot;name&quot;</span><br><span class="line">  types = 0x0000000100003f53 &quot;@16@0:8&quot;</span><br><span class="line">  imp = 0x0000000100003cf0 (AL-Objc`-[Person name])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(3).big()</span><br><span class="line">(method_t::big) $29 = &#123;</span><br><span class="line">  name = &quot;setName:&quot;</span><br><span class="line">  types = 0x0000000100003f73 &quot;v24@0:8@16&quot;</span><br><span class="line">  imp = 0x0000000100003d20 (AL-Objc`-[Person setName:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(4).big()</span><br><span class="line">(method_t::big) $30 = &#123;</span><br><span class="line">  name = &quot;age&quot;</span><br><span class="line">  types = 0x0000000100003f7e &quot;i16@0:8&quot;</span><br><span class="line">  imp = 0x0000000100003d50 (AL-Objc`-[Person age])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(5).big()</span><br><span class="line">(method_t::big) $31 = &#123;</span><br><span class="line">  name = &quot;setAge:&quot;</span><br><span class="line">  types = 0x0000000100003f86 &quot;v20@0:8i16&quot;</span><br><span class="line">  imp = 0x0000000100003d70 (AL-Objc`-[Person setAge:])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $23.get(6).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2/runtime/objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p>我们在类中声明的方法都在<code>method_list_t</code>中，这里有我们自己声明的方法，还有属性自动生成的set和get方法。</p>
<p>发现这里并没有我们的类方法。因为类方法在元类里。</p>
<h1 id="7-类方法"><a href="#7-类方法" class="headerlink" title="7. 类方法"></a>7. 类方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/4gx Person.class</span><br><span class="line">0x1000083f8: 0x00000001000083d0 0x000000010036a140</span><br><span class="line">0x100008408: 0x00000001006176b0 0x0001803000000003</span><br><span class="line"></span><br><span class="line">// 获取元类</span><br><span class="line">(lldb) p 0x00000001000083d0 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $33 = 4295001040</span><br><span class="line">(lldb) po $33</span><br><span class="line">Person</span><br><span class="line"></span><br><span class="line">(lldb) x/6gx $33</span><br><span class="line">0x1000083d0: 0x000000010036a0f0 0x000000010036a0f0</span><br><span class="line">0x1000083e0: 0x00000001006959d0 0x0002e03100000003</span><br><span class="line">0x1000083f0: 0x0000000101204304 0x00000001000083d0</span><br><span class="line">// 获取元类的bits</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000083f0</span><br><span class="line">(class_data_bits_t *) $34 = 0x00000001000083f0</span><br><span class="line">(lldb) p $34-&gt;data()</span><br><span class="line">(class_rw_t *) $35 = 0x0000000101204300</span><br><span class="line">(lldb) p *$35</span><br><span class="line">(class_rw_t) $36 = &#123;</span><br><span class="line">  flags = 2684878849</span><br><span class="line">  witness = 1</span><br><span class="line">  ro_or_rw_ext = &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; = &#123;</span><br><span class="line">      Value = 4302330705</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = 0x00000001000083a8</span><br><span class="line">  nextSiblingClass = 0x00007fff883ac410</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $35-&gt;methods()</span><br><span class="line">(const method_array_t) $37 = &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = &#123;</span><br><span class="line">        ptr = 0x0000000100008168</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag = 4295000424</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $37.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $38 = &#123;</span><br><span class="line">  ptr = 0x0000000100008168</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $38.ptr</span><br><span class="line">(method_list_t *const) $39 = 0x0000000100008168</span><br><span class="line">(lldb) p *$39</span><br><span class="line">(method_list_t) $40 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; = (entsizeAndFlags = 27, count = 2)</span><br><span class="line">&#125;</span><br><span class="line">// count = 2告诉我们有2个</span><br><span class="line"></span><br><span class="line">(lldb) p $40.get(0).big()</span><br><span class="line">(method_t::big) $41 = &#123;</span><br><span class="line">  name = &quot;func3&quot;</span><br><span class="line">  types = 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000100003c00 (AL-Objc`+[Person func3])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(1).big()</span><br><span class="line">(method_t::big) $42 = &#123;</span><br><span class="line">  name = &quot;func4&quot;</span><br><span class="line">  types = 0x0000000100003f5b &quot;v16@0:8&quot;</span><br><span class="line">  imp = 0x0000000100003c30 (AL-Objc`+[Person func4])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $40.get(2).big()</span><br><span class="line">Assertion failed: (i &lt; count), function get, file objc4-818.2/runtime/objc-runtime-new.h, line 624.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p>这里是获取类方法所在的位置。</p>
<h1 id="8-协议"><a href="#8-协议" class="headerlink" title="8 协议"></a>8 协议</h1><p>属性、变量、方法都已经有所了解，接下来看一下协议。把我们一开始注释的协议打开，重新运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/6gx Person.class</span><br><span class="line">0x1000088d0: 0x00000001000088a8 0x000000010036a140</span><br><span class="line">0x1000088e0: 0x0000000100362370 0x0000803400000000</span><br><span class="line">0x1000088f0: 0x0000000100604204 0x00000001000b9970</span><br><span class="line">(lldb) p (class_data_bits_t *)0x1000088f0</span><br><span class="line">(class_data_bits_t *) $4 = 0x00000001000088f0</span><br><span class="line">(lldb) p $4-&gt;data()</span><br><span class="line">(class_rw_t *) $5 = 0x0000000100604200</span><br><span class="line">(lldb) p $5-&gt;protocols()</span><br><span class="line">(const protocol_array_t) $6 = &#123;</span><br><span class="line">  list_array_tt&lt;unsigned long, protocol_list_t, RawPtr&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = &#123;</span><br><span class="line">        ptr = 0x0000000100008560</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag = 4295001440</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $6.list</span><br><span class="line">(const RawPtr&lt;protocol_list_t&gt;) $7 = &#123;</span><br><span class="line">  ptr = 0x0000000100008560</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $7.ptr</span><br><span class="line">(protocol_list_t *const) $8 = 0x0000000100008560</span><br><span class="line">(lldb) p *$8</span><br><span class="line">(protocol_list_t) $9 = (count = 1, list = protocol_ref_t [] @ 0x00007ff5f7e1e9f8)</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p>到此时，就不知道怎么处理，我们看一下<code>protocol_list_t</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct protocol_list_t &#123;</span><br><span class="line">    // count is pointer-sized by accident.</span><br><span class="line">    uintptr_t count;</span><br><span class="line">    protocol_ref_t list[0]; // variable-size</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是其内部的主要结构。我们用<code>list[0]</code>打印一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $9.list[0]</span><br><span class="line">(protocol_ref_t) $11 = 4295002464</span><br></pre></td></tr></table></figure>

<p>上面我们已经说过<code>protocol_ref_t</code>只是一个定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef uintptr_t protocol_ref_t;  // protocol_t *, but unremapped</span><br></pre></td></tr></table></figure>
<p>接下来强转一下，看是否可以转成<code>protocol_t *</code>类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (protocol_t *)$11</span><br><span class="line">(protocol_t *) $12 = 0x0000000100008960</span><br><span class="line"></span><br><span class="line">// 我们查看protocol_t内部的结构有demangledName()方法.</span><br><span class="line">(lldb) p $12-&gt;demangledName()</span><br><span class="line">(const char *) $13 = 0x0000000100003b51 &quot;PersonProtocol&quot;</span><br></pre></td></tr></table></figure>

<p>到这里呢，协议存放的位置也找到了。</p>
<h1 id="9-补充添加协议之后"><a href="#9-补充添加协议之后" class="headerlink" title="9. 补充添加协议之后"></a>9. 补充添加协议之后</h1><h2 id="9-1-多了4个属性"><a href="#9-1-多了4个属性" class="headerlink" title="9.1 多了4个属性"></a>9.1 多了4个属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $5-&gt;properties()</span><br><span class="line">(const property_array_t) $15 = &#123;</span><br><span class="line">  list_array_tt&lt;property_t, property_list_t, RawPtr&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = &#123;</span><br><span class="line">        ptr = 0x0000000100008710</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag = 4295001872</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $15.list</span><br><span class="line">(const RawPtr&lt;property_list_t&gt;) $16 = &#123;</span><br><span class="line">  ptr = 0x0000000100008710</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $16.ptr</span><br><span class="line">(property_list_t *const) $17 = 0x0000000100008710</span><br><span class="line">(lldb) p *$17</span><br><span class="line">(property_list_t) $18 = &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; = (entsizeAndFlags = 16, count = 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加协议之后，又返回去重新打印了一下属性列表，发现这里变成了7个。明明之前只有2个属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 之前打印的数据</span><br><span class="line">(property_list_t) $8 = &#123;</span><br><span class="line">  entsize_list_tt&lt;property_t, property_list_t, 0, PointerModifierNop&gt; = (entsizeAndFlags = 16, count = 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再加上协议中定义的一个，加起来也才3个，为什么会变成7个？这7个又是哪个属性？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $18.get(0)</span><br><span class="line">(property_t) $19 = (name = &quot;name&quot;, attributes = &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;)</span><br><span class="line">(lldb) p $18.get(1)</span><br><span class="line">(property_t) $20 = (name = &quot;age&quot;, attributes = &quot;Ti,N,V_age&quot;)</span><br><span class="line">(lldb) p $18.get(2)</span><br><span class="line">(property_t) $21 = (name = &quot;p_address&quot;, attributes = &quot;T@\&quot;NSString\&quot;,C,N&quot;)</span><br><span class="line">(lldb) p $18.get(3)</span><br><span class="line">(property_t) $22 = (name = &quot;hash&quot;, attributes = &quot;TQ,R&quot;)</span><br><span class="line">(lldb) p $18.get(4)</span><br><span class="line">(property_t) $23 = (name = &quot;superclass&quot;, attributes = &quot;T#,R&quot;)</span><br><span class="line">(lldb) p $18.get(5)</span><br><span class="line">(property_t) $24 = (name = &quot;description&quot;, attributes = &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br><span class="line">(lldb) p $18.get(6)</span><br><span class="line">(property_t) $25 = (name = &quot;debugDescription&quot;, attributes = &quot;T@\&quot;NSString\&quot;,R,C&quot;)</span><br></pre></td></tr></table></figure>

<p>发现，添加了协议之后，会增加<code>hash、superclass、description、debugDescription</code>4个属性。是因为我们定义的协议都遵循<code>&lt;NSObject&gt;</code>协议，在<code>&lt;NSObject&gt;</code>协议内部有这4个属性的声明。</p>
<h2 id="9-2-方法找不到了"><a href="#9-2-方法找不到了" class="headerlink" title="9.2 方法找不到了"></a>9.2 方法找不到了</h2><p>我们按照上面获取方法等顺序，结果在最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">p $2-&gt;methods()</span><br><span class="line">(const method_array_t) $3 = &#123;</span><br><span class="line">  list_array_tt&lt;method_t, method_list_t, method_list_t_authed_ptr&gt; = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      list = &#123;</span><br><span class="line">        ptr = 0x0000000100722d01</span><br><span class="line">      &#125;</span><br><span class="line">      arrayAndFlag = 4302449921</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $3.list</span><br><span class="line">(const method_list_t_authed_ptr&lt;method_list_t&gt;) $4 = &#123;</span><br><span class="line">  ptr = 0x0000000100722d01</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $4.ptr</span><br><span class="line">(method_list_t *const) $5 = 0x0000000100722d01</span><br><span class="line">(lldb) p *$6</span><br><span class="line">(method_list_t) $7 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; = (entsizeAndFlags = 0, count = 2281701376)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在第6节的时候，输出过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *$22</span><br><span class="line">(method_list_t) $23 = &#123;</span><br><span class="line">  entsize_list_tt&lt;method_t, method_list_t, 4294901763, method_t::pointer_modifier&gt; = (entsizeAndFlags = 27, count = 7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共有7个，但是这里怎么变成了这么大的一个值？？？<br>有知道的大佬，欢迎指导，谢谢。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>添加协议之后<ul>
<li>多了4个属性</li>
<li>方法找不到了，待补充</li>
</ul>
</li>
</ul>
<p>这里我们以name的get方法为例子，说明一下这都是什么意思：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName;</span><br><span class="line">&#123;(struct objc_selector *)&quot;name&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_name&#125;</span><br></pre></td></tr></table></figure>

<p><img src="function_table.png"></p>
<blockquote>
<p>@16@0:8</p>
</blockquote>
<ul>
<li>‘@’：第一个@表示返回值，对象</li>
<li>‘16’：16个字节</li>
<li>‘@’：第二个@表示对象类型(id)</li>
<li>‘0’：我们知道@表示对象，0表示从0开始，占8个字节</li>
<li>‘:’：SEL，方法明</li>
<li>‘8’：表示从8开始，占8个字节，满足一共16个字节</li>
</ul>
<p>sel 和 imp<br>sel：方法名<br>imp：方法实现。函数指针地址</p>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><ul>
<li>实例对象、类对象、元类。一切皆为对象，主要因为objc_object这个结构体。</li>
<li>isa的走位图，superClass的指向</li>
<li>属性、变量，实例方法、类方法的存放<ul>
<li>属性、变量的区别，存放的位置</li>
<li>实例方法放在类对象的列表；类方法的存放在元类的方法列表</li>
</ul>
</li>
<li>sel、imp的区别</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-2-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-2-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">oc-2-内存对齐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 18:34:07" itemprop="dateCreated datePublished" datetime="2021-04-17T18:34:07+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h1><p>在上一节中，我们知道开辟空间会用到<code>calloc</code>这个函数，那我们就追一下这个函数的内部逻辑。</p>
<p>但是发现<code>calloc</code>这个方法没有办法继续下一步追踪了，如图：</p>
<p><img src="calloc-1.jpg"></p>
<p>我们发现<code>calloc</code>定义在<code>malloc/_malloc.h</code>文件下，我们也找到了对应的<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libmalloc/">源码</a>。我这里用的是一份可运行的源码。</p>
<p>接下来，直接上代码，在main函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 开辟40个字节的空间</span><br><span class="line">void *p = calloc(1, 40);</span><br><span class="line">NSLog(@&quot;%lu&quot;,malloc_size(p));</span><br></pre></td></tr></table></figure>

<p>直接运行，查看<code>malloc.c -&gt; calloc</code>的内部实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">calloc(size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	return _malloc_zone_calloc(default_zone, num_items, size, MZ_POSIX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>calloc</code>只是调用了<code>_malloc_zone_calloc</code>方法，其它啥也没做，这里需要注意的是，<code>default_zone</code>参数，它是一个虚拟的默认zone，通过它可以做一些事情，如下：</p>
<h2 id="malloc-zone-calloc"><a href="#malloc-zone-calloc" class="headerlink" title="_malloc_zone_calloc"></a>_malloc_zone_calloc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size,</span><br><span class="line">		malloc_zone_options_t mzo)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	if (malloc_check_start) &#123;</span><br><span class="line">		internal_check();</span><br><span class="line">	&#125;</span><br><span class="line">	ptr = zone-&gt;calloc(zone, num_items, size);</span><br><span class="line"></span><br><span class="line">	if (os_unlikely(malloc_logger)) &#123;</span><br><span class="line">		malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (uintptr_t)zone,</span><br><span class="line">				(uintptr_t)(num_items * size), 0, (uintptr_t)ptr, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (uintptr_t)zone, num_items, size, (uintptr_t)ptr);</span><br><span class="line">	if (os_unlikely(ptr == NULL)) &#123;</span><br><span class="line">		malloc_set_errno_fast(mzo, ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>calloc</code>直接调用的是<code>_malloc_zone_calloc</code>。我们看一下这个函数的实现。通过返回值，我们确定重点代码应该与<code>ptr</code>有关。所以<code>_malloc_zone_calloc</code>精简如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size,</span><br><span class="line">		malloc_zone_options_t mzo)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (uintptr_t)zone, num_items, size, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	// ptr初始化，这里打一个断点</span><br><span class="line">	ptr = zone-&gt;calloc(zone, num_items, size);</span><br><span class="line"></span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行到这里，发现<code>zone-&gt;calloc</code>进去是一个函数的声明，有没有下文了。这是，我们用lldb调试，打印一下数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p zone-&gt;calloc</span><br><span class="line">(void *(*)(_malloc_zone_t *, size_t, size_t)) $0 = 0x00000001002f4b93 (.dylib`default_zone_calloc at malloc.c:385)</span><br></pre></td></tr></table></figure>

<p>感觉发现了新大陆：<code>default_zone_calloc</code>在<code>malloc.c</code>文件的第385行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">default_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	zone = runtime_default_zone();</span><br><span class="line">	</span><br><span class="line">	return zone-&gt;calloc(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，又有一个<code>zone</code>。这个才是创建的runtime时的default zone。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_NOEXPORT malloc_zone_t* lite_zone = NULL;</span><br><span class="line"></span><br><span class="line">MALLOC_ALWAYS_INLINE</span><br><span class="line">static inline malloc_zone_t *</span><br><span class="line">runtime_default_zone() &#123;</span><br><span class="line">  // lite_zone = null，所以会执行创建</span><br><span class="line">	return (lite_zone) ? lite_zone : inline_malloc_default_zone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">⬇️</span><br><span class="line"></span><br><span class="line">static inline malloc_zone_t *</span><br><span class="line">inline_malloc_default_zone(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 只创建一次，内部是一个os_once</span><br><span class="line">    _malloc_initialize_once();</span><br><span class="line">    // malloc_report(ASL_LEVEL_INFO, &quot;In inline_malloc_default_zone with %d %d\n&quot;, malloc_num_zones, malloc_has_debug_zone);</span><br><span class="line">    // 可以看到malloc_zones是一个(malloc_zone_t **)类型的数据</span><br><span class="line">    // malloc_zone_t **malloc_zones = (malloc_zone_t **)0xdeaddeaddeaddead;</span><br><span class="line">    return malloc_zones[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看一下<code>malloc_zones</code>的内容：</p>
<p><img src="malloc_zones.png"></p>
<h2 id="malloc-zone-t"><a href="#malloc-zone-t" class="headerlink" title="_malloc_zone_t"></a>_malloc_zone_t</h2><p>上面的大部分内容都是围绕着<code>_malloc_zone_t</code>展开的。</p>
<p>这里可以看到<code>malloc_zones[0]</code>的元素就是一个<code>malloc_zone_t *</code>类型的数据，根据lldb打印出来的数据和查看到的内容可以看到<code>malloc_zone_t</code>中存放的就是一些我们在开辟空间时需要调用的方法。</p>
<p>看一下<code>_malloc_zone_t</code>结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define MALLOC_ZONE_FN_PTR(fn) fn</span><br><span class="line"></span><br><span class="line">typedef struct _malloc_zone_t &#123;</span><br><span class="line">    /* Only zone implementors should depend on the layout of this structure;</span><br><span class="line">    Regular callers should use the access functions below */</span><br><span class="line">    void	*reserved1;	/* RESERVED FOR CFAllocator DO NOT USE */</span><br><span class="line">    void	*reserved2;	/* RESERVED FOR CFAllocator DO NOT USE */</span><br><span class="line">    size_t 	(* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, const void *ptr); </span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size);</span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); </span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); /* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */</span><br><span class="line">    void 	(* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, void *ptr);</span><br><span class="line">    void 	*(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, void *ptr, size_t size);</span><br><span class="line">    void 	(* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone);</span><br><span class="line">    const char	*zone_name;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, void *ptr);</span><br><span class="line">&#125; malloc_zone_t;</span><br></pre></td></tr></table></figure>

<p>结构体中的数据与我们图片上的内容是一样的，定义了很多的方法。以<code>calloc</code>为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void 	*(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size);</span><br><span class="line"></span><br><span class="line">转换之后的方法为：</span><br><span class="line"></span><br><span class="line">calloc(_malloc_zone_t *zone, size_tnum_items, size_t size) &#123;</span><br><span class="line">    // 调用.dylib中的方法，nano_malloc.c : 878</span><br><span class="line">    nano_calloc(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以用同样的方式打印一下看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po zone-&gt;calloc</span><br><span class="line">(.dylib`nano_calloc at nano_malloc.c:878)</span><br></pre></td></tr></table></figure>

<p>打印出来的信息已经很全面了，同样告诉我们了<code>nano_calloc</code>方法在<code>nano_malloc.c</code>文件中。</p>
<h2 id="nano-calloc"><a href="#nano-calloc" class="headerlink" title="nano_calloc"></a>nano_calloc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	size_t total_bytes;</span><br><span class="line">   // alloc之前需要先判断申请的空间大小是否合理</span><br><span class="line">	if (calloc_get_size(num_items, size, 0, &amp;total_bytes)) &#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  // 如果获取到的大小在系统约定的最大值范围内则，直接进行malloc。</span><br><span class="line">	if (total_bytes &lt;= NANO_MAX_SIZE) &#123;</span><br><span class="line">	   // 所以一定会走这里</span><br><span class="line">		void *p = _nano_malloc_check_clear(nanozone, total_bytes, 1);</span><br><span class="line">		if (p) &#123;</span><br><span class="line">			return p;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/* FALLTHROUGH to helper zone */</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	malloc_zone_t *zone = (malloc_zone_t *)(nanozone-&gt;helper_zone);</span><br><span class="line">	// 如果初始化失败，则继续执行。</span><br><span class="line">	return zone-&gt;calloc(zone, 1, total_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>nano_calloc</code>中，我们同样的先看返回值，最底部的是又继续调用了<code>zone-&gt;calloc</code>，感觉不太对，上面就找到了还有一个返回<code>p</code>的位置。运行也确实会走到这里。</p>
<p>接下来就是重点了哈~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_nano_malloc_check_clear(nanozone_t *nanozone, size_t size, boolean_t cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_nano_malloc, (uintptr_t)nanozone, size, cleared_requested, 0);</span><br><span class="line"></span><br><span class="line">	void *ptr;</span><br><span class="line">	size_t slot_key;   // 插槽的key</span><br><span class="line">	// 获取真正的内存大小，以及slot_key</span><br><span class="line">	size_t slot_bytes = segregated_size_to_fit(nanozone, size, &amp;slot_key); // Note slot_key is set here</span><br><span class="line">	// 拿到插槽的index</span><br><span class="line">	mag_index_t mag_index = nano_mag_index(nanozone);</span><br><span class="line">  //  </span><br><span class="line">	nano_meta_admin_t pMeta = &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);</span><br><span class="line"></span><br><span class="line">	ptr = OSAtomicDequeue(&amp;(pMeta-&gt;slot_LIFO), offsetof(struct chained_block_s, next));</span><br><span class="line">	if (ptr) &#123;</span><br><span class="line">		// 这里都是error的判断</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	   // 死循环获取内存指针，拿到返回</span><br><span class="line">		ptr = segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (cleared_requested &amp;&amp; ptr) &#123;</span><br><span class="line">		memset(ptr, 0, slot_bytes); // TODO: Needs a memory barrier after memset to ensure zeroes land first?</span><br><span class="line">	&#125;</span><br><span class="line">	return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接下来看一下开辟空间的算法：segregated_size_to_fit</p>
<h2 id="segregated-size-to-fit"><a href="#segregated-size-to-fit" class="headerlink" title="segregated_size_to_fit"></a>segregated_size_to_fit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static MALLOC_INLINE size_t</span><br><span class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)</span><br><span class="line">&#123;</span><br><span class="line">	size_t k, slot_bytes;</span><br><span class="line"></span><br><span class="line">	if (0 == size) &#123;</span><br><span class="line">		size = NANO_REGIME_QUANTA_SIZE; // Historical behavior</span><br><span class="line">	&#125;</span><br><span class="line">	k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta</span><br><span class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;							// multiply by power of two quanta size</span><br><span class="line">	*pKey = k - 1;													// Zero-based!</span><br><span class="line"></span><br><span class="line">	return slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法在上一节中计算<code>alignedInstanceSize</code>类似。这里的主要逻辑是先右移4位，再左移4位。相当于把后4位抹零。拿我们开辟空间传进来的40为例计算一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(size + NANO_REGIME_QUANTA_SIZE - 1) = 40 + 15 -1</span><br><span class="line">54 -&gt; 0011 0110</span><br><span class="line">&gt;&gt; 4  0000 0011         // 右移4位</span><br><span class="line">&lt;&lt; 4  0011 0000 = 48    // 左移4位</span><br></pre></td></tr></table></figure>

<p>这里计算出来的大小就是48。而<code>slot_key=47</code>。之后就是获取内存指针。</p>
<p><img src="calloc-2.jpg"></p>
<p>这就是<code>calloc</code>的流程，同时，再一次验证了，iOS在内存中是16字节对齐。</p>
<h1 id="结构体的内存对齐"><a href="#结构体的内存对齐" class="headerlink" title="结构体的内存对齐"></a>结构体的内存对齐</h1><p>结构体内存对齐3打原则：</p>
<blockquote>
<ol>
<li>数据成员对⻬规则：结构体(struct)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小(只要该成员有子成员，比如说是数组，结构体等)的整数倍开始(比如int为4字节,则要从4的整数倍地址开始存储。</li>
<li>结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a里存有struct b，b里有char，int, double等元素，那b应该从8的整数倍开始存储)</li>
<li>收尾工作：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍。不足的要补⻬。</li>
</ol>
</blockquote>
<p>开始代码之前，先了解一下各种数据类型所占的内存大小：</p>
<p><img src="calloc-3.jpg"></p>
<p>接下来上代码，看看结构体的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 &#123;</span><br><span class="line">    double a;   </span><br><span class="line">    char b;     </span><br><span class="line">    int c;      </span><br><span class="line">    short d;    </span><br><span class="line">&#125;str1;</span><br><span class="line"></span><br><span class="line">struct Struct2 &#123;</span><br><span class="line">    double a; </span><br><span class="line">    int b;    </span><br><span class="line">    char c;   </span><br><span class="line">    short d;  </span><br><span class="line">&#125;str2;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;str1 = %lu, str2-%lu&quot;,sizeof(str1),sizeof(str2));</span><br></pre></td></tr></table></figure>

<p>输出的结果很明白的哈。<code> str1 = 24, str2-16</code></p>
<p>我们分析一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Struct1 &#123;</span><br><span class="line">    double a;   // 8 (0-7)</span><br><span class="line">    char b;     // 1 [8 1] (8)</span><br><span class="line">    int c;      // 4 [9 10 11 12] 9不是4的整数倍(12 13 14 15)</span><br><span class="line">    short d;    // 2 [16 17]</span><br><span class="line">&#125;str1;</span><br><span class="line"></span><br><span class="line">// 内部需要的大小为: 17</span><br><span class="line">// 最大属性 : 8</span><br><span class="line">// 结构体整数倍: 24</span><br><span class="line"></span><br><span class="line">struct Struct2 &#123;</span><br><span class="line">    double a;   //8 (0-7)</span><br><span class="line">    int b;      //4 (8 9 10 11)</span><br><span class="line">    char c;     //1 (12)</span><br><span class="line">    short d;    //2 (13 14) 13不是2的整数倍，从14开始(14 15)</span><br><span class="line">&#125;str2;</span><br><span class="line"></span><br><span class="line">// 内部需要的大小为: 15</span><br><span class="line">// 最大属性 : 8</span><br><span class="line">// 结构体整数倍: 16</span><br><span class="line">NSLog(@&quot;str1 = %lu, str2-%lu&quot;,sizeof(str1),sizeof(str2));</span><br></pre></td></tr></table></figure>

<p>如果结构体内部套用结构体呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Struct3 &#123;</span><br><span class="line">    double a;   //8 (0-7)</span><br><span class="line">    int b;      //4 (8 9 10 11)</span><br><span class="line">    char c;     //1 (12)</span><br><span class="line">    struct Struct2 str_2;   // 13 14 15 (16 - 31)</span><br><span class="line">&#125;str3;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;str3 = %lu&quot;, sizeof(str3));</span><br></pre></td></tr></table></figure>

<p>按照内存对齐第二条原则，结构体成员从其内部最大成员的size的整数倍开始。c的位置是12，接下来的位置是13，不满足8的整数倍。所以按照原则，前面补齐，从16位开始。所以str3结构体的大小为32。</p>
<h1 id="对象的内存对齐"><a href="#对象的内存对齐" class="headerlink" title="对象的内存对齐"></a>对象的内存对齐</h1><p>老样子，先看代码哈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) int score;</span><br><span class="line">@property (nonatomic, assign) long height;</span><br><span class="line">@property (nonatomic) char c1;</span><br><span class="line">@property (nonatomic) char c2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line"></span><br><span class="line">Person *person = [Person alloc];</span><br><span class="line">person.name = @&quot;name&quot;;</span><br><span class="line">person.age = 18;</span><br><span class="line">person.score = 20;</span><br><span class="line">person.height = 180;</span><br><span class="line">person.c1 = &#x27;a&#x27;;</span><br><span class="line">person.c2 = &#x27;b&#x27;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,person,sizeof(person),class_getInstanceSize([Person class]),malloc_size((__bridge const void *)(person)));</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在NSLog上打个断点。有时间的话，可以把属性先注释掉，从0开始，一个属性一个属性的加起来看输出的是什么结果。</p>
<ol>
<li><p>po 这里直接输出person指向的对象的内存地址。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po person</span><br><span class="line">&lt;Person: 0x600002adbcf0&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里有一个需要介绍的点，上一章中有用到x person命令，输出的内容与<code>View Memory</code>中显示的是一致的。而<code>x/8gx</code>就是进行排序。8代表的是输出8组内存。如果是4那就是输出4组内容。每一块都是8个字节。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/8gx person</span><br><span class="line">0x600002adbcf0: 0x0000000103930808 0x0000001200006261</span><br><span class="line">0x600002adbd00: 0x0000000000000014 0x000000010392b038</span><br><span class="line">0x600002adbd10: 0x00000000000000b4 0x0000000000000000</span><br><span class="line">0x600002adbd20: 0x0000c1c5c19bbd20 0x00000000000007fb</span><br></pre></td></tr></table></figure>
<p> 0x600002adbcf0：是person指向的首地址。后面存放的都是属性的值。内存都是连续的。</p>
</li>
<li><p>我们分别输出内存里的内容。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x0000000103930808</span><br><span class="line">Person  // isa指针</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000012</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">(lldb) 0x61是十进制的97 -&gt; a</span><br><span class="line"></span><br><span class="line">(lldb) po 0x0000000000000014</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">(lldb) po 0x000000010392b038</span><br><span class="line">name</span><br><span class="line"></span><br><span class="line">(lldb) po 0x00000000000000b4</span><br><span class="line">180</span><br></pre></td></tr></table></figure>
<p> 0x0000001200006261：这一块地址上内容是被拆开的。我们知道int是4个字节，char是1个字节，所以前面的几位是int的值，后面的再进行拆分，分别是两个char类型的数据。</p>
<p> 苹果在内存上也是做了足够多的优化，虽然在内存上是16个字节对齐的，以空间换时间，提高读取效率，但是在内部实现上，还是进行了大量的优化，这样做的目的是最大限度的节约内存同时保证数据的安全性，但是一定要注意的是，属性是按8个字节对齐的。</p>
<p> 但是为啥两个int类型的数据没有放在一起呢？可能是系统内部做的优化，可以试一下，把所有的char类型注释掉，两个int类型的数据就会存放在一起。可能是会将char类型的数据优先进行填充吧。另外可以多试一下，3个char类型的会怎么样，等等…</p>
</li>
<li><p>最后输出的结果是</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x600002adbcf0&gt; - 8 - 40 - 48</span><br></pre></td></tr></table></figure>
<p> 我们分析一下输出的内容：</p>
<ul>
<li>person：当前的类对象，存放的指针，指向的内存地址。</li>
<li>sizeof(person)：person存放的就是一个指针，8个字节。</li>
<li>class_getInstanceSize([Person class])：这个类真正需要的空间。属性是8个字节对齐的。</li>
<li>malloc_size((__bridge const void *)(person))：内存中需要开辟的空间。内存空间是16个字节对齐的。</li>
</ul>
</li>
</ol>
<h2 id="float、double"><a href="#float、double" class="headerlink" title="float、double"></a>float、double</h2><p>加如改变其中的一个属性位double类型的，又会是什么情况呢？我这里把上面的height改为了double类型。看一下输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/8gx person</span><br><span class="line">0x600000045530: 0x000000010626d808 0x0000001200006261</span><br><span class="line">0x600000045540: 0x0000000000000014 0x0000000106268038</span><br><span class="line">0x600000045550: 0x4066800000000000 0x0000000000000000</span><br><span class="line">0x600000045560: 0x0000000000000000 0x0000000000000000</span><br><span class="line">(lldb) po 0x4066800000000000</span><br><span class="line">4640537203540230144</span><br></pre></td></tr></table></figure>

<p>诶~~~ 怎么没有输出180呢？是因为对于float、double类型的数据，系统会做一次特殊的转换处理。我们没有办法直接从内存中读出double类型的值。</p>
<p>但是我们可以通过转化double类型的数据来看是否位上面对应的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x (double)180.0</span><br><span class="line">(double) $4 = 0x4066800000000000</span><br></pre></td></tr></table></figure>
<p>转换后，发现正好是对应的数据。</p>
<p>这里当然有读取浮点数的方法<code>p/f [0x000000123]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/f 0x4066800000000000</span><br><span class="line">(long) $5 = 180</span><br></pre></td></tr></table></figure>
<p>这就是内存补齐的内容</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>calloc的流程。</li>
<li>结构体的对齐规则。</li>
<li>类对象的属性是8个字节对齐的，但是在内存空间是16个字节对齐。</li>
<li>x&#x2F;4gx的使用</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libmalloc/">libmalloc源码</a><br><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/">苹果更多源码</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-1-alloc-init-new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/OC%E5%8E%9F%E7%90%86/oc-1-alloc-init-new/" class="post-title-link" itemprop="url">OC-1-alloc、init、new</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 09:20:25" itemprop="dateCreated datePublished" datetime="2021-04-17T09:20:25+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OC%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">OC原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-先看一个问题"><a href="#1-先看一个问题" class="headerlink" title="1. 先看一个问题"></a>1. 先看一个问题</h1><p>我们先看一段代码，打印一下输出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *p1 = [Person alloc];</span><br><span class="line">Person *p2 = [p1 init];</span><br><span class="line">Person *p3 = [p1 init];</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p1,p1,&amp;p1);</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p2,p2,&amp;p2);</span><br><span class="line">NSLog(@&quot;%@ - %p - %p&quot;,p3,p3,&amp;p3);</span><br></pre></td></tr></table></figure>

<p>看输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114068</span><br><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114060</span><br><span class="line">&lt;Person: 0x600000c40470&gt; - 0x600000c40470 - 0x7ffee9114058</span><br></pre></td></tr></table></figure>

<p>前两个打印的都是当前对象的指针地址，而最后一个为啥会不一样？<br>首先需要明白p和&amp;p的区别：p是当前变量指向的地址。&amp;p是存放当前变量所在的地址。<br>这里第一个%p打印就是[Person alloc]生成的地址。第二个%p是存放的是指向【生成的对象】的地址。</p>
<p>也就是当前alloc生成一个对象开辟了一块内存空间。p1、p2、p3分别开辟一块地址指向alloc开辟的空间。</p>
<p><img src="oc-address.png"></p>
<p>我们可以通过汇编模式或者符号断点查看源码所在的位置。这里不细说了，比较简单。最后定位的源码位置在<code>libobjc.A.dylib-&gt;objc_init</code>。</p>
<h1 id="2-alloc的执行过程"><a href="#2-alloc的执行过程" class="headerlink" title="2. alloc的执行过程"></a>2. alloc的执行过程</h1><p>那我们接下来要看alloc是怎么执行的。需要看objc的源码。<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">objc4源码</a>是可以直接下载的。我们这里用的是最新的818.2版本的。</p>
<p>通过一系列风骚的操作，我们让源码可以运行起来。通过断点和源码我们分析一下alloc的执行过程。</p>
<h2 id="2-1-objc-rootAlloc"><a href="#2-1-objc-rootAlloc" class="headerlink" title="2.1 _objc_rootAlloc"></a>2.1 _objc_rootAlloc</h2><p>在main.m中，创建一个对象，打上断点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [Person alloc];</span><br><span class="line">Person *p1 = [p init];</span><br></pre></td></tr></table></figure>

<p>这里只是alloc的最基本的方法。没有什么代码量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-callAlloc"><a href="#2-2-callAlloc" class="headerlink" title="2.2 callAlloc"></a>2.2 callAlloc</h2><p>这里是核心代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__ // 是个宏定义</span><br><span class="line">    // slowpath表示括号内的条件可能性教小</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    // fastpath表示括号内的条件可能性教大</span><br><span class="line">    // 如果有自定义的allocWithZone（hasCustomAWZ）</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);   // 1.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // No shortcuts available. 根据传进来的参数判断</span><br><span class="line">    if (allocWithZone) &#123;                            // 2. </span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); // 3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>该处内容是现阶段alloc执行的代码</li>
<li>根据<code>callAlloc</code>调用传进来的参数判断，基本都会执行【1】。</li>
<li>通过消息发送，执行<code>alloc</code>，这里有个很有意思的点，源码跑起来就能知道。</li>
</ol>
<h2 id="2-3-objc-rootAllocWithZone"><a href="#2-3-objc-rootAllocWithZone" class="headerlink" title="2.3 _objc_rootAllocWithZone"></a>2.3 _objc_rootAllocWithZone</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    // allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-class-createInstanceFromZone"><a href="#2-4-class-createInstanceFromZone" class="headerlink" title="2.4 _class_createInstanceFromZone"></a>2.4 _class_createInstanceFromZone</h2><p>这里是重中之重。alloc的流程都在这里完美的展示出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct = true,</span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    // Read class&#x27;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast = cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    // 1. 既然要生成一个对象，首先要做的就是开辟空间，但是要开辟多少？</span><br><span class="line">    // 由对象的ivars决定。在iOS中，字节是8自己对齐，而内存是16字节对齐，所以小于16字节会补齐</span><br><span class="line">    size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 2. 算出来需要多少空间，这里进行开辟</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    // 极少数情况下，obj会创建失败</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        // 3. 空间有了，这里进行对象关联</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Use raw pointer isa on the assumption that they might be</span><br><span class="line">        // doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-cls-gt-instanceSize"><a href="#2-4-1-cls-gt-instanceSize" class="headerlink" title="2.4.1 cls-&gt;instanceSize"></a>2.4.1 cls-&gt;instanceSize</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">    // 有缓存的情况下</span><br><span class="line">    if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        return cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    // 新开辟</span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    // CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size = 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果有缓存的情况下，则会执行fastInstanceSize。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t fastInstanceSize(size_t extra) const</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(hasFastInstanceSize(extra));</span><br><span class="line"></span><br><span class="line">    if (__builtin_constant_p(extra) &amp;&amp; extra == 0) &#123;</span><br><span class="line">        return _flags &amp; FAST_CACHE_ALLOC_MASK16;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        size_t size = _flags &amp; FAST_CACHE_ALLOC_MASK;</span><br><span class="line">        // remove the FAST_CACHE_ALLOC_DELTA16 that was added</span><br><span class="line">        // by setFastInstanceSize</span><br><span class="line">        // 内存对齐是16字节</span><br><span class="line">        return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 新开辟空间时计算对象所在空间</span><br><span class="line">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">uint32_t alignedInstanceSize() const &#123;</span><br><span class="line">    return word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line">// 8字节对齐</span><br><span class="line">static inline size_t word_align(size_t x) &#123;</span><br><span class="line">    // 通过算法得到8字节的倍数</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line">// 16字节对齐 fastInstanceSize</span><br><span class="line">static inline size_t align16(size_t x) &#123;</span><br><span class="line">    // 通过算法得到16字节的倍数</span><br><span class="line">    return (x + size_t(15)) &amp; ~size_t(15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里举例说明一下算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// WORD_MASK = 7</span><br><span class="line">(x + 7) &amp; ~7;</span><br><span class="line">// x = 2, x + 7 = 9   -&gt; 0000 1001  ⬇️   x=10 17 = 0001 0001</span><br><span class="line">// 7 = 0000 0111 -&gt; !7 = 1111 1000  ⬇️        !7 = 1111 1000</span><br><span class="line">//              9 &amp; !7 = 0000 1000 = 8  (17 &amp; !7 = 0001 0000 = 16)</span><br></pre></td></tr></table></figure>

<p>所以：<code>word_align</code>计算出来的都是8的倍数。<br>     <code>align16</code>计算出来的都是16的倍数。</p>
<p>这里需要注意的是在ARM64下，内存开辟都是16个字节进行对齐的。所以计算的大小的都是16的倍数。</p>
<h3 id="2-4-2-calloc"><a href="#2-4-2-calloc" class="headerlink" title="2.4.2 calloc"></a>2.4.2 calloc</h3><p>calloc申请开辟内存，返回地址指针。</p>
<h3 id="2-4-3-obj-gt-initInstanceIsa"><a href="#2-4-3-obj-gt-initInstanceIsa" class="headerlink" title="2.4.3 obj-&gt;initInstanceIsa"></a>2.4.3 obj-&gt;initInstanceIsa</h3><p>生成的对象与class进行关联。通过isa指针。（isa之后会有说明，每一个类都有一个isa指针）。</p>
<h3 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4 总结"></a>2.4.4 总结</h3><p><img src="oc-alloc.png"></p>
<p>这个图很好的说明了alloc的流程。</p>
<h1 id="3-init"><a href="#3-init" class="headerlink" title="3. init"></a>3. init</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    // In practice, it will be hard to rely on this function.</span><br><span class="line">    // Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init其实是工厂方法，从上面的代码可以看到，只是<code>return self</code>。这里有一个重要的点，就是大部分的实现都会交给子类去重新自定义init方法。</p>
<h1 id="4-new"><a href="#4-new" class="headerlink" title="4. new"></a>4. new</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false/*checkNil*/) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到new的实现就是执行了，callAlloc()，然后执行了init操作。与实际上的<code>[[Person alloc] init]</code>并没有什么区别。</p>
<p>但是看到有一些博客上说，还是有区别，因为init被重写之后，调用new可能会造成少些东西。这里不能苟同哈，所有的方法调用，在OC中都是objc_msgSend，会去寻找方法列表的。所以不会存在什么不同。</p>
<h1 id="5-扩展知识"><a href="#5-扩展知识" class="headerlink" title="5. 扩展知识"></a>5. 扩展知识</h1><p>我们已经知道了，本身写一个Person类，需要开辟16个字节的空间，那需要申请多大内存空间是由什么因素决定的？<br>我们可以试一下分别添加一个属性，两个属性，试一下。自己动手试一下哈，看看2.4.1小结处返回的size是多少。其申请内存的大小其实是成员变量说了算。</p>
<p>我这里添加了两个NSString属性，分别赋值A和B。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po p</span><br><span class="line">&lt;Person: 0x600002f86cc0&gt;</span><br><span class="line">(lldb) x p</span><br><span class="line">0x600002f86cc0: 60 76 e3 06 01 00 00 00 40 20 e3 06 01 00 00 00  `v......@ ......</span><br><span class="line">0x600002f86cd0: 60 20 e3 06 01 00 00 00 00 00 00 00 00 00 00 00  ` ..............</span><br><span class="line"></span><br><span class="line">(lldb) x/4gx p</span><br><span class="line">0x600002f86cc0: 0x0000000106e37660 0x0000000106e32040</span><br><span class="line">0x600002f86cd0: 0x0000000106e32060 0x0000000000000000</span><br><span class="line">(lldb) po 0x0000000106e37660    // isa指针，指向class</span><br><span class="line">Person</span><br><span class="line">(lldb) po 0x0000000106e32040</span><br><span class="line">A</span><br><span class="line">(lldb) po 0x0000000106e32060</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<p>通过<code>x p</code>命令我们可以打印出<code>p</code>的内存地址。在源码的运行过程中，断点到size计算那里，打印出来size的大小是<code>32</code>个字节。也就是会空8个字节。</p>
<p>如果声明了4个bool值，则4个bool值则会依次放在内存中，例如：0x0000000001010101，这个就涉及到字节的对齐以及iOS系统对属性的重排（内存优化）。</p>
<h1 id="6-真正的alloc流程"><a href="#6-真正的alloc流程" class="headerlink" title="6. 真正的alloc流程"></a>6. 真正的alloc流程</h1><p>当我们执行<code>[Person alloc]</code>的时候，直接吧断点放在<code>callAlloc-&gt;objc_msgSend</code>，则会先执行消息转发。原因是系统内部会通过llvm的函数方法把<code>alloc</code>指向到<code>objc_alloc</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true/*checkNil*/, false/*allocWithZone*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先执行一次<code>callAlloc(cls, true, false)</code>，注意这里的参数。然后执行到calAlloc中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil); //1.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); // 2.</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); // 3.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过运行，我们发现会先执行第3个return。所执行的还是<code>alloc</code>，这时候执行的才是真正的alloc。然后就可以顺着第2节的内容继续了。</p>
<p>如图，是完整的alloc会执行两次的流程图：</p>
<p><img src="oc-alloc-2.jpg"></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>alloc的流程</li>
<li>alloc的两次执行过程</li>
<li>init</li>
<li>new</li>
</ul>
<p>有什么不对的欢迎指正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/14/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/14/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-3/" class="post-title-link" itemprop="url">ARM汇编-3 状态寄存器 if、loop、switch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-14 22:05:25" itemprop="dateCreated datePublished" datetime="2021-04-14T22:05:25+08:00">2021-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-状态寄存器"><a href="#1-状态寄存器" class="headerlink" title="1. 状态寄存器"></a>1. 状态寄存器</h1><p>CPU内部的寄存器中,有一种特殊的寄存器(对于不同的处理器,个数和结构都可能不同)。这种寄存器在ARM中，被称为状态寄存器就是CPSR(current program status register)寄存器。</p>
<p>CPSR和其他寄存器不一样,其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而CPSR寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>
<blockquote>
<p>CPSR寄存器是32位的。</p>
</blockquote>
<ul>
<li>CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!</li>
<li>N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行！</li>
</ul>
<p><img src=".jpg"></p>
<h2 id="1-1-N-（Negative）"><a href="#1-1-N-（Negative）" class="headerlink" title="1.1 N （Negative）"></a>1.1 N （Negative）</h2><p>cpsr的第31位是N，它记录相关指令执行后的结果，结果是负数，则N&#x3D;1，非负数则N&#x3D;0。</p>
<blockquote>
<p>在ARM64的指令集中，逻辑运算或者算数运算（add、sub、or等）指令的执行会影响状态寄存器的值。</p>
</blockquote>
<p>n&#x3D;1：结果是负数<br>n&#x3D;0：结果位非负数，包括0</p>
<h2 id="1-2-Z（Zero）"><a href="#1-2-Z（Zero）" class="headerlink" title="1.2 Z（Zero）"></a>1.2 Z（Zero）</h2><p>cpsr的第30位是Z，0标志位。它记录相关指令执行后其结果是否为。如果结果为0，那么Z &#x3D; 1；如果结果不为0，那么Z &#x3D; 0.</p>
<p>z&#x3D;1：结果为0<br>z&#x3D;0：结果不为0</p>
<h2 id="1-3-C（Carry）"><a href="#1-3-C（Carry）" class="headerlink" title="1.3 C（Carry）"></a>1.3 C（Carry）</h2><p>cpsr第29位是c进位标志位，一般情况进行下无符号述的运算。</p>
<p>加法运算：当运算结果产生了进位时（无符号数溢出）c&#x3D;1，没有溢出c&#x3D;0<br>减法运算：包括（CPM）当运算时产生了借位（无符号数溢出），c&#x3D;0，没有溢出c&#x3D;1</p>
<h3 id="1-3-1-进位"><a href="#1-3-1-进位" class="headerlink" title="1.3.1 进位"></a>1.3.1 进位</h3><p>两个数据相加，比如正常的十进制运算，5+5&#x3D;10，向十位数进1，个位数为0。但是超过其最大的位数时，发生溢出，导致进位的值无法保存，也就是说进位的值丢失了。但是CPU在运算的时候，并不会丢弃这个进位的值，二手放在寄存器里了，也就是cpsr的c位。</p>
<h3 id="1-3-2-借位"><a href="#1-3-2-借位" class="headerlink" title="1.3.2 借位"></a>1.3.2 借位</h3><p>两个数据做减法操作，有可能向更高位借位。比如：10-5&#x3D;5，各位不够减，需要向十位去借。这时候会用c位来标记借位。</p>
<h2 id="1-4-V（Overflow）"><a href="#1-4-V（Overflow）" class="headerlink" title="1.4 V（Overflow）"></a>1.4 V（Overflow）</h2><p>cpsr的第28位是V，溢出标志位。在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。</p>
<ul>
<li>正数 + 正数 &#x3D; 负数。溢出</li>
<li>负数 + 负数 &#x3D; 正数。溢出</li>
<li>正数 + 负数 不可能发生溢出</li>
</ul>
<h1 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h1><p>NZ：是否为0，判断正负<br>CV：无符号，有符号判断是否溢出 </p>
<h1 id="2-全局变量、常量"><a href="#2-全局变量、常量" class="headerlink" title="2. 全局变量、常量"></a>2. 全局变量、常量</h1><p>开始这一节之前，先知道我们的内存分区划分：</p>
<p>代码区：存放代码，可读，可执行<br>栈区：参数、局部变量、临时数据，可读可写<br>堆区：动态申请，可读可写</p>
<p>全局变量：可读可写<br>常量区：只读</p>
<p>接下来，我们分析代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个全局变量</span><br><span class="line">int g = 12;</span><br><span class="line"></span><br><span class="line">// 定义一个方法</span><br><span class="line">int func(int a,int b)&#123;</span><br><span class="line">    // &#x27;haha&#x27;就是一个常量，在常量区</span><br><span class="line">    printf(&quot;haha&quot;);</span><br><span class="line">    // 局部变量c</span><br><span class="line">    int c = a + g + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">   </span><br><span class="line">    func(10, 20);</span><br><span class="line">    </span><br><span class="line">    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后，走汇编流程，进行查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Demo`func:</span><br><span class="line">-&gt;  0x100bc211c &lt;+0&gt;:  sub    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x100bc2120 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100bc2124 &lt;+8&gt;:  add    x29, sp, #0x10            ; =0x10 </span><br><span class="line">    0x100bc2128 &lt;+12&gt;: stur   w0, [x29, #-0x4]</span><br><span class="line">    0x100bc212c &lt;+16&gt;: str    w1, [sp, #0x8]</span><br><span class="line">    0x100bc2130 &lt;+20&gt;: adrp   x0, 1</span><br><span class="line">    0x100bc2134 &lt;+24&gt;: add    x0, x0, #0xf9f            ; =0xf9f </span><br><span class="line">    // ① 这里执行了printf操作，大致可以判断，x0中存的就是&#x27;haha&#x27;</span><br><span class="line">    0x100bc2138 &lt;+28&gt;: bl     0x100bc25b0               ; symbol stub for: printf</span><br><span class="line">    0x100bc213c &lt;+32&gt;: ldur   w8, [x29, #-0x4]</span><br><span class="line">    // ② 这里获取的是全局变量</span><br><span class="line">    0x100bc2140 &lt;+36&gt;: adrp   x9, 3</span><br><span class="line">    0x100bc2144 &lt;+40&gt;: add    x9, x9, #0x648            ; =0x648 </span><br><span class="line">    0x100bc2148 &lt;+44&gt;: ldr    w10, [x9]</span><br><span class="line">    0x100bc214c &lt;+48&gt;: add    w8, w8, w10</span><br><span class="line">    0x100bc2150 &lt;+52&gt;: ldr    w10, [sp, #0x8]</span><br><span class="line">    0x100bc2154 &lt;+56&gt;: add    w8, w8, w10</span><br><span class="line">    0x100bc2158 &lt;+60&gt;: str    w8, [sp, #0x4]</span><br><span class="line">    0x100bc215c &lt;+64&gt;: ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bc2160 &lt;+68&gt;: mov    x0, x8</span><br><span class="line">    0x100bc2164 &lt;+72&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100bc2168 &lt;+76&gt;: add    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x100bc216c &lt;+80&gt;: ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>①这里执行了printf操作，这里看一些是否真的打印了’haha’。我们追一下x0寄存器的变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x100bc2130 &lt;+20&gt;: adrp   x0, 1</span><br></pre></td></tr></table></figure>
<p>这里有一个关键字需要注意一下：<br>adrp: 针对address page操作<br>这一行代码有三个操作：</p>
<ol>
<li>将1左移12位（即在1后加3个0变成1000）</li>
<li>将当前寄存器的地址的低12位清0，即当前行的地址的后3位清0。0x1002b2184 -&gt; 0x100bc2130</li>
<li>把0x1000+0x100bc2000赋值给x0，x0&#x3D;0x100bc3000，即当前行地址的倒数第4位与x0后面的数字相加</li>
</ol>
<p>说白了，这句代码的意思就是找到某一页地址的开始。我们走断点，打印一下x0.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read x0</span><br><span class="line">x0 = 0x0000000100bc3000</span><br></pre></td></tr></table></figure>

<p>下一句的代码是，<code>add x0, x0, #0xf9f</code>，就x0的地址+0x0xf9f<br>获取x0的值位0x100bc3f9f</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read x0</span><br><span class="line">x0 = 0x0000000100bc3f9f  &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">(lldb) x 0x0000000100bc3f9f</span><br><span class="line">0x100bc3f9f: 68 61 68 61 00 01 00 00 00 1c 00 00 00 02 00 00  haha............</span><br><span class="line">0x100bc3faf: 00 24 00 00 00 00 00 00 00 24 00 00 00 02 00 00  .$.......$......</span><br></pre></td></tr></table></figure>

<p>我们知道’h’的ASCII码是97，对应的16进制就行0x61，’a’是0x68。就是我们的常量’haha’。</p>
<p>这样也就拿到了常量的值。<br>需要注意的是，我们的常量是在编译的时候就已经确定了地址。这里通过当前寄存器的地址为参照，偏移一定的值来获取常量所在的页数。</p>
<p>那继续看一下全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x100bc2140 &lt;+36&gt;: adrp   x9, 3</span><br><span class="line">0x100bc2144 &lt;+40&gt;: add    x9, x9, #0x648            ; =0x648 </span><br></pre></td></tr></table></figure>

<p>我们使用相同的方式，打印一下x9的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// adrp的断点</span><br><span class="line">(lldb) register read x9</span><br><span class="line">x9 = 0x0000000100bc5000  </span><br><span class="line"></span><br><span class="line">// add 的断点</span><br><span class="line">lldb) register read x9</span><br><span class="line">x9 = 0x0000000100bc5648  g  // 这里拿到的是变量g，而g在内存中的值是0c</span><br><span class="line">(lldb) x 0x0000000100bc5648</span><br><span class="line">0x100bc5648: 0c 00 00 00 0c 00 00 00 38 5e 44 29 02 00 00 00  ........8^D)....</span><br><span class="line">0x100bc5658: f0 33 bc 00 01 00 00 00 d0 4f bc 00 01 00 00 00  .3.......O......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以通过相同的方式获取全局变量的值，g&#x3D;12。</p>
<p>所以局部变量和全局变量都是通过adrp以当前寄存器的地址为参照来查找address来获取值的。</p>
<h2 id="2-1-汇编还原高级语言"><a href="#2-1-汇编还原高级语言" class="headerlink" title="2.1 汇编还原高级语言"></a>2.1 汇编还原高级语言</h2><p>这里使用一个牛逼的工具Hopper，可以查看对应的方法转化成汇编之后的代码。</p>
<ol>
<li>build成功之后，在我们的工程里有一个’Products’文件，里头有对应的<code>xxx.app</code>。</li>
<li>点击show in finder，找到对应的app，右键显示包内容。</li>
<li>找到与项目同名的黑乎乎的东西（可执行文件），直接拖到Hopper里头就可以了。</li>
</ol>
<p>我们找到对应的方法func</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">_func:</span><br><span class="line">000000010000611c         sub        sp, sp, #0x20    ; CODE XREF=_main+32</span><br><span class="line">0000000100006120         stp        x29, x30, [sp, #0x10]</span><br><span class="line">0000000100006124         add        x29, sp, #0x10</span><br><span class="line">// 这里我们可以知道有两个变量，w0、w1分别存起来</span><br><span class="line">0000000100006128         stur       w0, [x29, #-0x4]</span><br><span class="line">000000010000612c         str        w1, [sp, #0x8]</span><br><span class="line">// adrp操作，获取页数</span><br><span class="line">0000000100006130         adrp       x0, #0x100007000 ; argument #1 for method imp___stubs__printf</span><br><span class="line">// 这里直接把结果给出来了。haha存放在x0</span><br><span class="line">0000000100006134         add        x0, x0, #0xf9f   ; &quot;haha&quot;</span><br><span class="line">// 执行printf</span><br><span class="line">0000000100006138         bl         imp___stubs__printf</span><br><span class="line">// 取值，这个位置的值就是w0</span><br><span class="line">000000010000613c         ldur       w8, [x29, #-0x4]</span><br><span class="line">// adrp操作，根据页数获取值</span><br><span class="line">0000000100006140         adrp       x9, #0x100009000</span><br><span class="line">// 获取变量_g。我们可以通过地址去找对应的值。可以在Hopper中找到对应的值</span><br><span class="line">0000000100006144         add        x9, x9, #0x648   ; _g</span><br><span class="line">// 赋值w10 = _g </span><br><span class="line">0000000100006148         ldr        w10, x9</span><br><span class="line">// 执行加法操作 w8 += w10</span><br><span class="line">000000010000614c         add        w8, w8, w10</span><br><span class="line">// 取值。也就是获取第二个参数的值w1</span><br><span class="line">0000000100006150         ldr        w10, [sp, #0x8]</span><br><span class="line">// 执行加法操作 w8 += w10</span><br><span class="line">0000000100006154         add        w8, w8, w10</span><br><span class="line">// 把w8的值存起来</span><br><span class="line">0000000100006158         str        w8, [sp, #0x4]</span><br><span class="line">// 取值w8</span><br><span class="line">000000010000615c         ldr        w8, [sp, #0x4]</span><br><span class="line">// 把w8的值给x0（x0存放返回值）</span><br><span class="line">0000000100006160         mov        x0, x8</span><br><span class="line">// 释放内存，return</span><br><span class="line">0000000100006164         ldp        x29, x30, [sp, #0x10]</span><br><span class="line">0000000100006168         add        sp, sp, #0x20</span><br><span class="line">000000010000616c         ret</span><br></pre></td></tr></table></figure>

<p>汇编的代码逻辑已经直接表示出来了。最终可以得出一个函数的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int func(int w1, int w2) &#123;</span><br><span class="line">    printf(&quot;haha&quot;);</span><br><span class="line">    return w1 + _g + w2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2. 条件判断"></a>2. 条件判断</h1><h2 id="2-1-cmp（Compare）比较指令"><a href="#2-1-cmp（Compare）比较指令" class="headerlink" title="2.1 cmp（Compare）比较指令"></a>2.1 cmp（Compare）比较指令</h2><p>cmp把一个寄存器的内容和另一个寄存器的内容（或立即数）进行比较。但不存储结果，只是更改标志。</p>
<p>一般cmp做完判断后会进行跳转，后面通常会跟上b指令。</p>
<p>cmp比较，其实是一个减法操作，但是不会改变两个比较的值。通过减法的结果去比较。</p>
<ul>
<li>BL 标号：跳转到标号处执行</li>
<li>B.LT 标号：比价结果是<strong>小于（less than）</strong>，执行标号，否则不跳转</li>
<li>B.LE 标号：比较结果是<strong>小于等于（less than or qeual to）</strong>，执行标号，否则不跳转</li>
<li>B.GT  标号：比较结果是<strong>大于（greater than）</strong>，执行标号，否则不跳转</li>
<li>B.GE  标号：比较结果是<strong>大于等于（greater than or equal to）</strong>，执行标号，否则不跳转</li>
<li>B.EQ  标号：比较结果是**等于(equal to)**，执行标号，否则不跳转</li>
<li>B.NE 标号：比较结果是<strong>不等于（not equal to）</strong>，执行标号，否则不跳转</li>
<li>B.LS  标号：比较结果是<strong>无符号小于等于</strong>，执行标号，否则不跳转</li>
<li>B.LO  标号：比较结果是<strong>无符号小于</strong>，执行标号，否则不跳转</li>
<li>B.HI  标号：比较结果是<strong>无符号大于</strong>，执行标号，否则不跳转</li>
<li>B.HS  标号：比较结果是<strong>无符号大于等于</strong>，执行标号，否则不跳转</li>
</ul>
<p>b.gt #0x10000f8d:这个地址是else的跳转地址</p>
<h1 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h1><blockquote>
<p>使用汇编的时候一定是在真机上运行。或者直接选中真机，直接<code>Command+B</code>buid之后，找到对应的可执行文件，直接放在Hopper里就行。</p>
</blockquote>
<h1 id="3-1-do-while"><a href="#3-1-do-while" class="headerlink" title="3.1 do-while"></a>3.1 do-while</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void loopFunc() &#123;</span><br><span class="line">    int nsum = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        nsum += 10;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125; while (i &lt; 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下汇编下是什么代码逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FunctionDemo`loopFunc:</span><br><span class="line">-&gt;  0x102c2a764 &lt;+0&gt;:  sub    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    // 这里是把0放在sp+0xc里头，w：低32位，zr==zero</span><br><span class="line">    0x102c2a768 &lt;+4&gt;:  str    wzr, [sp, #0xc]   // 假设#0xc存的是a</span><br><span class="line">    0x102c2a76c &lt;+8&gt;:  str    wzr, [sp, #0x8]   // 假设#0x8存的是b,之后用的都是w8，会比较乱</span><br><span class="line">    // ① 读取a的值</span><br><span class="line">    0x102c2a770 &lt;+12&gt;: ldr    w8, [sp, #0xc]</span><br><span class="line">    // 执行a += 10的操作。</span><br><span class="line">    0x102c2a774 &lt;+16&gt;: add    w8, w8, #0xa              ; =0x1 </span><br><span class="line">    // 然后把a的值存起来。</span><br><span class="line">    0x102c2a778 &lt;+20&gt;: str    w8, [sp, #0xc]</span><br><span class="line">    // 取值b</span><br><span class="line">    0x102c2a77c &lt;+24&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    // b += 1</span><br><span class="line">    0x102c2a780 &lt;+28&gt;: add    w8, w8, #0x1              ; =0x1 </span><br><span class="line">    // 把b存起来</span><br><span class="line">    0x102c2a784 &lt;+32&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x102c2a788 &lt;+36&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    // 比较b的值，b与100比较</span><br><span class="line">    0x102c2a78c &lt;+40&gt;: cmp    w8, #0x64                 ; =0x64 </span><br><span class="line">    // 如果 lt（小于）if b &lt; 100 跳转到0x102c2a770继续执行。执行①</span><br><span class="line">    0x102c2a790 &lt;+44&gt;: b.lt   0x102c2a770               ; &lt;+12&gt; at main.m:22:14</span><br><span class="line">    0x102c2a794 &lt;+48&gt;: add    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x102c2a798 &lt;+52&gt;: ret  </span><br></pre></td></tr></table></figure>

<p>我们直接使用Hopper工具查看汇编，其实比在Xcode中更方便。</p>
<p><img src="do-while.png"></p>
<h2 id="3-2-while"><a href="#3-2-while" class="headerlink" title="3.2 while"></a>3.2 while</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void whileFunc() &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int nsum = 0;</span><br><span class="line">    while (i &lt; 10) &#123;</span><br><span class="line">        nsum += 10;</span><br><span class="line">        i += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Hopper里查看源码：</p>
<p><img src="while.jpg"></p>
<p>①处是一个比较，判断w8的值和10的大小，如果<code>b.ge</code>则执行<code>loc_100006128</code>的代码。b.ge是大于等于。<br>②是直接跳转到<code>loc_10000610c</code>的代码。</p>
<h2 id="3-3-for"><a href="#3-3-for" class="headerlink" title="3.3 for"></a>3.3 for</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void forFunc() &#123;</span><br><span class="line">    int nsum = 0;</span><br><span class="line">    for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        nsum += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Hopper里查看源码：</p>
<p><img src="for.jpg"></p>
<p>for循环与while循环区别不大。</p>
<h1 id="4-switch"><a href="#4-switch" class="headerlink" title="4. switch"></a>4. switch</h1><h2 id="4-1-三个case的switch"><a href="#4-1-三个case的switch" class="headerlink" title="4.1 三个case的switch"></a>4.1 三个case的switch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum = 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是运行xCode，查看汇编源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Demo`switchFunc:</span><br><span class="line">-&gt;  0x100bea0e8 &lt;+0&gt;:   sub    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x100bea0ec &lt;+4&gt;:   str    w0, [sp, #0xc]</span><br><span class="line">    0x100bea0f0 &lt;+8&gt;:   str    wzr, [sp, #0x8]</span><br><span class="line">    0x100bea0f4 &lt;+12&gt;:  ldr    w8, [sp, #0xc]</span><br><span class="line">    0x100bea0f8 &lt;+16&gt;:  cmp    w8, #0x1                  ; =0x1 </span><br><span class="line">    0x100bea0fc &lt;+20&gt;:  str    w8, [sp, #0x4]</span><br><span class="line">    0x100bea100 &lt;+24&gt;:  b.eq   0x100bea128               ; &lt;+64&gt; at main.m:48:18</span><br><span class="line">    0x100bea104 &lt;+28&gt;:  b      0x100bea108               ; &lt;+32&gt; at main.m</span><br><span class="line">    0x100bea108 &lt;+32&gt;:  ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bea10c &lt;+36&gt;:  cmp    w8, #0x2                  ; =0x2 </span><br><span class="line">    0x100bea110 &lt;+40&gt;:  b.eq   0x100bea138               ; &lt;+80&gt; at main.m:51:18</span><br><span class="line">    0x100bea114 &lt;+44&gt;:  b      0x100bea118               ; &lt;+48&gt; at main.m</span><br><span class="line">    0x100bea118 &lt;+48&gt;:  ldr    w8, [sp, #0x4]</span><br><span class="line">    0x100bea11c &lt;+52&gt;:  cmp    w8, #0x3                  ; =0x3 </span><br><span class="line">    0x100bea120 &lt;+56&gt;:  b.eq   0x100bea148               ; &lt;+96&gt; at main.m:54:18</span><br><span class="line">    0x100bea124 &lt;+60&gt;:  b      0x100bea158               ; &lt;+112&gt; at main.m:60:18</span><br><span class="line">    0x100bea128 &lt;+64&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea12c &lt;+68&gt;:  add    w8, w8, #0x1              ; =0x1 </span><br><span class="line">    0x100bea130 &lt;+72&gt;:  str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea134 &lt;+76&gt;:  b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea138 &lt;+80&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea13c &lt;+84&gt;:  add    w8, w8, #0xa              ; =0xa </span><br><span class="line">    0x100bea140 &lt;+88&gt;:  str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea144 &lt;+92&gt;:  b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea148 &lt;+96&gt;:  ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea14c &lt;+100&gt;: add    w8, w8, #0x14             ; =0x14 </span><br><span class="line">    0x100bea150 &lt;+104&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea154 &lt;+108&gt;: b      0x100bea164               ; &lt;+124&gt; at main.m:63:1</span><br><span class="line">    0x100bea158 &lt;+112&gt;: ldr    w8, [sp, #0x8]</span><br><span class="line">    0x100bea15c &lt;+116&gt;: subs   w8, w8, #0x1              ; =0x1 </span><br><span class="line">    0x100bea160 &lt;+120&gt;: str    w8, [sp, #0x8]</span><br><span class="line">    0x100bea164 &lt;+124&gt;: add    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x100bea168 &lt;+128&gt;: ret    </span><br></pre></td></tr></table></figure>

<p>看汇编源码，其实就是简单的if-else比较，只不过这里换成了b.eq(等于)，然后跳转到对应的代码块。</p>
<h2 id="4-2-4个case的switch"><a href="#4-2-4个case的switch" class="headerlink" title="4.2 4个case的switch"></a>4.2 4个case的switch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum = 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            printf(&quot;4&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    switchFunc(4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们改变一下代码，再加一个case，运行一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Demo`switchFunc:</span><br><span class="line">    0x1005460ac &lt;+0&gt;:   sub    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x1005460b0 &lt;+4&gt;:   stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x1005460b4 &lt;+8&gt;:   add    x29, sp, #0x10            ; =0x10 </span><br><span class="line">    // 1. 把w0的值存起来，w0 = 4</span><br><span class="line">    0x1005460b8 &lt;+12&gt;:  stur   w0, [x29, #-0x4]</span><br><span class="line">    // 2. 把0存起来</span><br><span class="line">    0x1005460bc &lt;+16&gt;:  str    wzr, [sp, #0x8]</span><br><span class="line">    // 3. 取值w8 = 4</span><br><span class="line">    0x1005460c0 &lt;+20&gt;:  ldur   w8, [x29, #-0x4]</span><br><span class="line">    // 4. 这里是第一个case 1. w8 = w8 - 1 = 3</span><br><span class="line">    0x1005460c4 &lt;+24&gt;:  subs   w8, w8, #0x1              ; =0x1 </span><br><span class="line">    // 5. 把x8的值给x9，x9 = 0x0000000000000003</span><br><span class="line">    0x1005460c8 &lt;+28&gt;:  mov    x9, x8</span><br><span class="line">    // 6. 这个ubfx语法，往下翻有详细解释。把x9的高32位清零，x9 = 0x0000000000000003</span><br><span class="line">    0x1005460cc &lt;+32&gt;:  ubfx   x9, x9, #0, #32</span><br><span class="line">    // 7. x9的值和3进行比较</span><br><span class="line">    0x1005460d0 &lt;+36&gt;:  cmp    x9, #0x3                  ; =0x3 </span><br><span class="line">    // 8. 把x9的值放在sp对应的内存地址中</span><br><span class="line">    0x1005460d4 &lt;+40&gt;:  str    x9, [sp]</span><br><span class="line">    // 9. 如果7中比较的结果是一个【无符号大于】，则执行0x100546134，其实就是执行了default操作</span><br><span class="line">-&gt;  0x1005460d8 &lt;+44&gt;:  b.hi   0x100546134               ; &lt;+136&gt; at main.m</span><br><span class="line">    // 10. adrp:地址操作，x8=0x100546000，左边的地址标号后12位清零，然后加上0x0000</span><br><span class="line">    0x1005460dc &lt;+48&gt;:  adrp   x8, 0</span><br><span class="line">    // 11. x8 = 0x10054614c，然后通过view memory，看里头的值。</span><br><span class="line">    0x1005460e0 &lt;+52&gt;:  add    x8, x8, #0x14c            ; =0x14c </span><br><span class="line">    // 12. 取值x11 = 3</span><br><span class="line">    0x1005460e4 &lt;+56&gt;:  ldr    x11, [sp]</span><br><span class="line">    // 13. ldrsw：取值，先计算中括号内部x11, lsl #2:意思是x11左移2位，</span><br><span class="line">    //     然后加上x8获取一个地址，把地址里的值给x10</span><br><span class="line">    // 3&lt;&lt;2 = 二进制数3：11&lt;&lt;2 = 1100，也就是十进制12，</span><br><span class="line">    // x8+12 = 0x10054614c+0xc = 0x100546158</span><br><span class="line">    // 这是一个寻址操作，把0x100546158地址的值给x10，</span><br><span class="line">    // 通过view memory查看x10 = 0xffffffd8 = -40,是一个负值</span><br><span class="line">    0x1005460e8 &lt;+60&gt;:  ldrsw  x10, [x8, x11, lsl #2]</span><br><span class="line">    // x9 = 0x10054614c + (-40) = 0x100546124</span><br><span class="line">    0x1005460ec &lt;+64&gt;:  add    x9, x8, x10</span><br><span class="line">    // 执行跳转到 0x100546124</span><br><span class="line">    0x1005460f0 &lt;+68&gt;:  br     x9</span><br><span class="line">    </span><br><span class="line">    // 从这里开始就是case的位置了。</span><br><span class="line">    0x1005460f4 &lt;+72&gt;:  adrp   x0, 1</span><br><span class="line">    0x1005460f8 &lt;+76&gt;:  add    x0, x0, #0xf8c            ; =0xf8c </span><br><span class="line">    0x1005460fc &lt;+80&gt;:  bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546100 &lt;+84&gt;:  b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546104 &lt;+88&gt;:  adrp   x0, 1</span><br><span class="line">    0x100546108 &lt;+92&gt;:  add    x0, x0, #0xf8e            ; =0xf8e </span><br><span class="line">    0x10054610c &lt;+96&gt;:  bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546110 &lt;+100&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546114 &lt;+104&gt;: adrp   x0, 1</span><br><span class="line">    0x100546118 &lt;+108&gt;: add    x0, x0, #0xf90            ; =0xf90 </span><br><span class="line">    0x10054611c &lt;+112&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546120 &lt;+116&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    // 直接跳转到这里，执行adrp操作，获取x0</span><br><span class="line">    0x100546124 &lt;+120&gt;: adrp   x0, 1</span><br><span class="line">    0x100546128 &lt;+124&gt;: add    x0, x0, #0xf92            ; =0xf92 </span><br><span class="line">    // 执行printf操作。</span><br><span class="line">    0x10054612c &lt;+128&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546130 &lt;+132&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1</span><br><span class="line">    0x100546134 &lt;+136&gt;: adrp   x0, 1</span><br><span class="line">    0x100546138 &lt;+140&gt;: add    x0, x0, #0xf94            ; =0xf94 </span><br><span class="line">    0x10054613c &lt;+144&gt;: bl     0x100546598               ; symbol stub for: printf</span><br><span class="line">    0x100546140 &lt;+148&gt;: ldp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x100546144 &lt;+152&gt;: add    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x100546148 &lt;+156&gt;: ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现不一样了啊，不是if-else判断了。</p>
<p>0x10092e0e0 &lt;+24&gt;:  ubfx   x9, x9, #0, #32<br>x9寄存器是64位，w8是32位，相当于x9的低32位。<br>这里的目的就是x9从0位开始到32位清零，也就x9的高32位清零然后赋值给x9</p>
<p><code>b.hi</code> 无符号大于</p>
<p><code>br x9</code>：b是跳转，br是不影响lr寄存器的跳转。直接跳到x9（x9是一个地址标号）</p>
<p><code>ldrsw  x10, [x8, x11, lsl #2]</code>： 这里先计算中括号内部。而在中括号内部先计算x11。</p>
<ol>
<li>lsl表示左移，<code>x11, lsl #2</code>表示x11左移2位。</li>
<li>加上x8的值。生成一个新的地址。</li>
<li>[]表示寻址，也就是说把生成的地址中的值给x10。</li>
</ol>
<p>看一下我们获取参数是否正确。看一下view memory</p>
<p><img src="switch-viewmemory.jpg"></p>
<p>偏移表中为什么存储的是地址的偏移量？为什么不直接存对应的地址？</p>
<blockquote>
<p>是因为地址只有在运行的时候才会开辟的，每次运行的值都不一样，所以直接存偏移量，然后通过偏移表的起始位置进行计算就可以直接定位了。</p>
</blockquote>
<h3 id="4-2-1-switch-case-偏移表"><a href="#4-2-1-switch-case-偏移表" class="headerlink" title="4.2.1 switch case 偏移表"></a>4.2.1 switch case 偏移表</h3><p>我们看第11. x8 &#x3D; 0x10054614c，这个地址正好是当前汇编函数的末尾0x100546148+0x4。所以，这个函数栈空间后有一堆数据，存放一些值，这一堆数据就是case创建的偏移表。而这些值就是我们要偏移的值。</p>
<p>偏移表中的个数是由 (case的最大值 - case的最小值) + 1。看一下上面的图<code>0x10054614c</code>的位置存放的4个值，分别是0xffffffa8&#x3D;-88, 0xffffffb8&#x3D;-72, 0xffffffc8&#x3D;-56, 0xffffffd8&#x3D;-40</p>
<p>偏移值是一个负数，是因为是以<code>x8 = 0x10054614c</code>寄存器中存的地址为基数，偏移一个负数得到一个地址，这个地址就是在函数开辟的栈空间内。</p>
<p>我们通过一张图重新看一下这个过程：</p>
<p><img src="switch-2.jpg"></p>
<h2 id="4-3-4个不连续case的switch"><a href="#4-3-4个不连续case的switch" class="headerlink" title="4.3 4个不连续case的switch"></a>4.3 4个不连续case的switch</h2><p>我们知道了，3个连续的case是if-else比较，4个连续的case就不是if-else了，而是会生成一个表。那么4个不连续的case呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void switchFunc(int a) &#123;</span><br><span class="line">    int nsum = 0;</span><br><span class="line">    switch (a) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;1&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 200:</span><br><span class="line">            printf(&quot;2&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 30:</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            printf(&quot;4&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;default&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就不在放汇编源码了，4个不连续的case，与3个case一样，也是通过if-else比较来执行代码块的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>假设switch语句的分支比较少的时候（例如3，少于4的时候没有意义）没有必要使用此结构，相当于if。</li>
<li>各个case分支常量的差值较大的时候，编译器会在效率还是内存进行取舍，这个时候编译器还是会编译成类似于if，else的结构。</li>
<li>在分支比较多的时候：在编译的时候会生成一个表（跳转表每个地址四个字节）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/13/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/13/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-2/" class="post-title-link" itemprop="url">ARM汇编-2 函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-13 21:52:51" itemprop="dateCreated datePublished" datetime="2021-04-13T21:52:51+08:00">2021-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-关于CPU的补充"><a href="#1-关于CPU的补充" class="headerlink" title="1. 关于CPU的补充"></a>1. 关于CPU的补充</h1><h2 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1 寄存器"></a>1.1 寄存器</h2><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>
<blockquote>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
</blockquote>
<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>
<h2 id="1-2-高速缓存"><a href="#1-2-高速缓存" class="headerlink" title="1.2 高速缓存"></a>1.2 高速缓存</h2><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>
<blockquote>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个高速缓存存储区域.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
</blockquote>
<h2 id="1-3-寄存器"><a href="#1-3-寄存器" class="headerlink" title="1.3 寄存器"></a>1.3 寄存器</h2><h3 id="1-3-1-数据地址寄存器"><a href="#1-3-1-数据地址寄存器" class="headerlink" title="1.3.1 数据地址寄存器"></a>1.3.1 数据地址寄存器</h3><p>数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。<br>ARM64中：</p>
<ul>
<li>64位 x0-x30，XZR（零寄存器）</li>
<li>32位 w0-w30，WZR（零寄存器）</li>
</ul>
<h3 id="1-3-2-浮点和向量寄存器"><a href="#1-3-2-浮点和向量寄存器" class="headerlink" title="1.3.2. 浮点和向量寄存器"></a>1.3.2. 浮点和向量寄存器</h3><p>因为浮点数的存储以及其运算的特殊性，CPU中专门提供浮点数寄存器来处理浮点数。</p>
<ul>
<li>64位: d0-d31 </li>
<li>32位: d0-d31</li>
</ul>
<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>
<p>向量寄存器 128位:V0-V31</p>
<h3 id="1-3-3-SP、FP寄存器"><a href="#1-3-3-SP、FP寄存器" class="headerlink" title="1.3.3 SP、FP寄存器"></a>1.3.3 SP、FP寄存器</h3><p>说这两个，需要先说一下栈。</p>
<p><img src="stack.jpg"></p>
<p>栈是一种具有特殊的访问方式的存储空间，先进后处，后进先出。（Last In Out First）</p>
<ul>
<li>sp寄存器在任意时刻会保存栈顶的地址。</li>
<li>fp寄存器也成为x29寄存器。属于通用寄存器，在默写时刻我们利用它保存栈底的地址。</li>
</ul>
<blockquote>
<p>需要注意的是，ARM64里面对栈的操作是16个字节对齐的。</p>
</blockquote>
<p><img src="stack_1.jpg"></p>
<p>这个图很好的说明了栈是从高地址往低地址开始读写操作的，堆是从低地址向高地址开始的，当栈不断的开辟空间，堆也不断的开辟空间，导致两个区域重叠，就会导致崩溃。也就是常说的堆栈溢出。（堆、栈上的空间是不固定的）</p>
<p>这里我们说个题外话，是不是所有的死循环都会导致崩溃？答案是否定的，只有不断的开辟空间的死循环才会导致崩溃，上一章我们最后的例子就是很好的说明，因为没有开辟空间。</p>
<h1 id="2-函数调用栈"><a href="#2-函数调用栈" class="headerlink" title="2. 函数调用栈"></a>2. 函数调用栈</h1><p>以下代码是常见的函数调用开辟和恢复栈空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub    sp, sp, #0x40             ; 拉伸0x40（64字节）空间</span><br><span class="line">stp    x29, x30, [sp, #0x30]     ; x29, x30 寄存器入栈保护</span><br><span class="line">add    x29, sp, #0x30            ; x29指向栈帧的底部</span><br><span class="line">... </span><br><span class="line">ldp    x29, x30, [sp, #0x30]     ; 恢复x29/x30 寄存器的值</span><br><span class="line">add    sp, sp, #0x40             ; 栈平衡</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是： 读、写数据都是往高地址读、写。</p>
</blockquote>
<h2 id="2-1-内存读写指令"><a href="#2-1-内存读写指令" class="headerlink" title="2.1 内存读写指令"></a>2.1 内存读写指令</h2><ul>
<li>str指令：store register，将数据从寄存器中读出来，存在内存中。每次操作8个字节</li>
<li>ldr指令：load register，将数据从内存中读出来，存在寄存器中。每次操作8个字节</li>
<li>stp指令：str指令的变种，每次操作16个字节。</li>
<li>ldp指令：ldr指令的变种，每次操作16个字节。</li>
</ul>
<h2 id="2-2-堆栈操作"><a href="#2-2-堆栈操作" class="headerlink" title="2.2 堆栈操作"></a>2.2 堆栈操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_ABTest:</span><br><span class="line">    sub sp, sp, #0x20       ; 开辟栈空间，在当前sp所在的位置减去32个字节。</span><br><span class="line">    stp x0, x1, [sp, #0x10] ; 之所以用[],是因为sp存的是一个地址,这里的操作是寻址，把x0，x1的值放在对应的位置，但是栈的读写都是在高位，所以这里还需要加上一个值，写在高位</span><br><span class="line">    ldp x1, x0, [sp, #0x10] ; 这里是交换x0，x1的值。注意，当前的操作不会改变sp的值，寄存器中的值进行交换</span><br><span class="line">    add sp, sp, #0x20       ; 这里恢复栈空间。</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li>我们将上面的代码放在“.s”文件中，在ViewControler中声明<code>int ABTest();</code>方法.</li>
<li>在viewDidLoad中调用<code>ABTest();</code>，并在这一行打上断点。运行触发断点之后，按住ctrl键的同时点击小箭头，进入汇编，（按住ctrl是为了不让程序执行下一步）</li>
<li>在右下命令行中输入<code>register read sp</code>查看当前sp所在的位置，是<code>sp = 0x000000016fbf1290</code></li>
<li>点击下一步，开辟栈空间，重复第3步的操作，查看<code>sp = 0x000000016fbf1270</code></li>
<li>进入View Memory，定位到sp所在的位置，查看在<code>0x000000016fbf1280</code>位置的值是什么。</li>
<li>这个时候，分别执行<code>register write x0 0x0a</code>， <code>register write x1 0x0b</code>，修改x0，x1的值，执行下一步。</li>
<li>发现在左边通用寄存器中x0，x1的值已经发生变化。这时候重复第5步操作。查看是否已经发生变化。（需要切换页）</li>
<li>执行下一步，交换x0，x1的值。我们发现左边，通用寄存器中x0，x1的值已经发生了变化，这时候重复第5步，查看内存中的值是否有变化？是没有发生变化的哈~</li>
<li>销毁当前栈空间。重复第3步，查看当前sp的地址。是<code>sp = 0x000000016fbf1290</code></li>
</ol>
<p>如图：</p>
<p><img src="ABTest.jpg"></p>
<h1 id="3-bl和ret指令"><a href="#3-bl和ret指令" class="headerlink" title="3. bl和ret指令"></a>3. bl和ret指令</h1><h2 id="3-1-bl"><a href="#3-1-bl" class="headerlink" title="3.1 bl"></a>3.1 bl</h2><p>bl其实存在两个操作：</p>
<ol>
<li>将下一条指令的地址放入lr（x30）寄存器。也就是保存回家的路。</li>
<li>转到对应的跳转中执行指令，当指令执行完成后，会根据lr中的地址，返回继续执行。</li>
</ol>
<p>通俗的讲就是离家出走了，执行ret的时候，根据lr中的地址，找到回家的路。</p>
<h2 id="3-2-ret"><a href="#3-2-ret" class="headerlink" title="3.2 ret"></a>3.2 ret</h2><p>默认使用lr（x30）寄存器的值，通过底层指令提示CPU此处作为下条指令地址。这是ARM64平台的特色指令，它面向硬件方面做了优化处理。</p>
<h2 id="3-3-x30寄存器（lr寄存器）"><a href="#3-3-x30寄存器（lr寄存器）" class="headerlink" title="3.3 x30寄存器（lr寄存器）"></a>3.3 x30寄存器（lr寄存器）</h2><p>x30寄存器存放的是函数的返回地址，当ret指令执行时，会寻找x30寄存器保存的地址值。</p>
<p>这也就是，为啥上一章，最后的代码会造成循环引用的原因，因为x30寄存器的地址指向的就是当前bl的下一行代码。</p>
<h2 id="3-4-操作"><a href="#3-4-操作" class="headerlink" title="3.4 操作"></a>3.4 操作</h2><p>我们简写一下上一章的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbb</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在ViewDidLoad中执行A()，并打断点。执行上面的代码。按住ctrl键点击小剪头，进入A的汇编。查看当前lr寄存器中存放的地址是谁。然后按照下图所示进行操作，进入ViewDidLoad的汇编。</p>
<p> <img src="viewdidload.jpg"></p>
</li>
<li><p>我们看到了19行执行了 bl A的操作，也就是在ViewDidLoad中执行A()操作。而lr寄存器所存储的地址就是第20行所在的位置，也就是存储了执行A之后返回ViewDidLoad的地址。0x1003ce56c</p>
</li>
<li><p>点击继续执行，修改x0寄存器的值，继续下一步。执行bl B</p>
</li>
<li><p>这时候我们发现lr寄存器中存储的值已经被修改了，变成了A汇编代码中bl B下一行的地址。<code>lr = 0x1003ce904</code>，这里修改了x0的值。</p>
</li>
<li><p>下一步。继续执行B中的ret操作，发现回到了A，回到了<code>0x1003ce904</code>，继续执行发现修改了x0的值。</p>
</li>
<li><p>下一步，执行ret，发现又回到了A中的<code>0x1003ce904</code>，不断的执行，发现压根回不去ViewDidLoad了。</p>
</li>
</ol>
<p>这就是上一章中说的问题，lr寄存器的值被修改了，导致回不去了。那我们应该怎么处理呢？</p>
<p>最合理的方案是在执行bl操作之前，将bl的下一行地址存放在栈中。如果将值存放在其他寄存器中是绝对不安全的，因为你不知道什么时候就会被系统覆盖。</p>
<h3 id="3-4-1-解决死循环"><a href="#3-4-1-解决死循环" class="headerlink" title="3.4.1 解决死循环"></a>3.4.1 解决死循环</h3><p>我们为了解决上面的问题，我们查看系统是怎么处理这个问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void c() &#123;</span><br><span class="line">    d();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void d() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，在ViewDidLoad中执行<code>c()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Demo`c:</span><br><span class="line">-&gt;  0x1005464e0 &lt;+0&gt;:  stp    x29, x30, [sp, #-0x10]!</span><br><span class="line">    0x1005464e4 &lt;+4&gt;:  mov    x29, sp</span><br><span class="line">    0x1005464e8 &lt;+8&gt;:  bl     0x1005464f4               ; d at ViewController.m:38:1</span><br><span class="line">    0x1005464ec &lt;+12&gt;: ldp    x29, x30, [sp], #0x10</span><br><span class="line">    0x1005464f0 &lt;+16&gt;: ret   </span><br></pre></td></tr></table></figure>
<p>在c的汇编里头，我们仔细看下系统是什么处理lr寄存器的。<br>我们看到了x29和x30两个寄存器。x29是fp寄存器，指向栈底；x30寄存器就是lr寄存器。</p>
<ol>
<li><code>stp x29, x30, [sp, #-0x10]!</code> 这是汇编代码简写的形式的。这句话的意思是sp -&#x3D; 0x10开辟空间，把x29和x30寄存器的值存放在开辟的空间里。“!”的操作是针对sp的，“[]”的操作是针对x29，x30寻址的。需要注意的是，先存值，在改变sp。</li>
<li><code>mov x29, sp</code> 将sp的值赋给x29寄存器。啥意思，fp跟sp指向相同的位置。栈顶栈底指向同一位置，啥情况？之后说哈~</li>
<li>bl操作，执行d()</li>
<li><code>ldp x29, x30, [sp], #0x10</code> 跟第一句差不多，“[]”就是寻址，将sp对应的两个地址的值赋值给x29，x30。第一步是存，这一步是取。然后执行 sp +&#x3D; 0x10的操作，释放栈空间。</li>
<li>执行ret操作，我们就能轻松的回到ViewDidLoad了。因为lr寄存器中的地址正是我们一开始存的值。</li>
</ol>
<p>在执行的过程中，我们一步步查看lr寄存器的值看是怎么变化的。就能清晰明了了。</p>
<p>这个时候，我们就可以修改上面的代码了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    str x30, [sp, #-0x10]!  ;仿造系统方法，因为x29寄存器暂时没有用处，所以只使用x30。</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, 0xaa</span><br><span class="line">    ldr x30, [sp], #0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbb</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>执行该代码，我们按照栈操作3.4的流程，查看整体流程，看x30寄存器存放读取的过程，配合View Memory使用会更爽哈~</p>
<p>这里把代码做一下修改，在A中<code>str x30, [sp, #-0x8]!</code>将16个字节改成8个字节会怎样？跑一遍试试看</p>
<p>会发生crash对不对。<b>因为在ARM64里面，对栈的操作是16个字节对齐的。所以开辟空间操作一定是16字节的倍数来进行的。</b></p>
<h1 id="4-函数的参数和返回值"><a href="#4-函数的参数和返回值" class="headerlink" title="4. 函数的参数和返回值"></a>4. 函数的参数和返回值</h1><p>ARM64下，函数的参数是存放在x0-x7(32位w0-w7)这个8个寄存器里面的。如果超过8个参数，就会入栈。<br>函数的返回值是放在x0(32位是w0)寄存器里的。</p>
<p>这里有一个点，在OC中，一般情况下，定义函数最多可以有几个参数？这里有一个小坑哈~<br>在runtime里，我们知道，函数调用都是通过objc_msgsend来处理的，而这里个里头已经存在了两个默认参数，一个是self，一个obj</p>
<p>当我们不知道怎么处理带参数的函数时，就看系统是怎么实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// 我们定义一个函数，在viewDidLoad中执行。</span><br><span class="line">int sumA(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后，按住control点击进汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">首先我们来到viewDidLoad中，</span><br><span class="line">`-[ViewController viewDidLoad]:</span><br><span class="line">    ; 这里我们有看到赋值，sumA(10+20)，我们看到w0=10，w1=20</span><br><span class="line">    0x104d125d4 &lt;+68&gt;: mov    w0, #0xa          </span><br><span class="line">    0x104d125d8 &lt;+72&gt;: mov    w1, #0x14</span><br><span class="line">-&gt;  0x104d125dc &lt;+76&gt;: bl     0x104d12570               ; sumA at ViewController.m:16  ; 这里有bl指令，继续执行跳转到sumA操作。</span><br><span class="line">    0x104d125e0 &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x104d125e4 &lt;+84&gt;: add    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x104d125e8 &lt;+88&gt;: ret    </span><br><span class="line">    </span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">FunctionDemo`sumA:</span><br><span class="line">-&gt;  0x100d3a4dc &lt;+0&gt;:  sub    sp, sp, #0x10     ; 开辟16个字节的空间</span><br><span class="line">    0x100d3a4e0 &lt;+4&gt;:  str    w0, [sp, #0xc]    ; 寻址把w0存放在sp+0xC的位置</span><br><span class="line">    0x100d3a4e4 &lt;+8&gt;:  str    w1, [sp, #0x8]    ; 寻址把w1存放在sp+0x8的位置</span><br><span class="line">    0x100d3a4e8 &lt;+12&gt;: ldr    w8, [sp, #0xc]    ; 把sp+0xC位置的值给w8</span><br><span class="line">    0x100d3a4ec &lt;+16&gt;: ldr    w9, [sp, #0x8]    ; 把sp+0x8位置的值给w9</span><br><span class="line">    0x100d3a4f0 &lt;+20&gt;: add    w0, w8, w9        ; 执行加法操作，并赋值给w0</span><br><span class="line">    0x100d3a4f4 &lt;+24&gt;: add    sp, sp, #0x10     ; 释放栈空间</span><br><span class="line">    0x100d3a4f8 &lt;+28&gt;: ret                      ; ret</span><br></pre></td></tr></table></figure>

<p>通过上面汇编之后的代码，我们可以看到整个的流程，相当于生成了两个临时量变去存储传进来的值，然后把返回值存储在w0寄存器里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// 我们定义一个函数，在viewDidLoad中执行。</span><br><span class="line">int sumA(int a, int b) &#123;</span><br><span class="line">    int a1 = 1;     // 生成局部变量a1，b1</span><br><span class="line">    int b1 = b;</span><br><span class="line">    return a1 + b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面系统的实现方案，我们就可以自己写一个带有参数，返回值的方法。在“.s”文件中实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global _sumB</span><br><span class="line"></span><br><span class="line">_sumB:</span><br><span class="line">    add x0, x0, x1</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h2 id="4-2-验证超过8个参数的情况"><a href="#4-2-验证超过8个参数的情况" class="headerlink" title="4.2 验证超过8个参数的情况"></a>4.2 验证超过8个参数的情况</h2><p>多余的参数会存放在调用方法所在的栈空间里，然后在调用的方法里去取别人的栈中存放的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i) &#123;</span><br><span class="line">    return a+b+c+d+e+f+g+h+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    test(1,2,3,4,5,6,7,8,9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，我们看汇编之后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">`-[ViewController viewDidLoad]:</span><br><span class="line">...</span><br><span class="line">... 这中间省略了一大部分代码，我们直接从这里看</span><br><span class="line">    ; 这里打印 sp = 0x000000016f4c53c0</span><br><span class="line">    0x10093e594 &lt;+64&gt;:  bl     0x10093e9b4               ; symbol stub for: objc_msgSendSuper2  </span><br><span class="line">    ; 这个是调用super viewDidLoad</span><br><span class="line">    0x10093e598 &lt;+68&gt;:  mov    w0, #0x1     ; 将1存到w0寄存器中</span><br><span class="line">    0x10093e59c &lt;+72&gt;:  mov    w1, #0x2</span><br><span class="line">    0x10093e5a0 &lt;+76&gt;:  mov    w2, #0x3</span><br><span class="line">    0x10093e5a4 &lt;+80&gt;:  mov    w3, #0x4</span><br><span class="line">    0x10093e5a8 &lt;+84&gt;:  mov    w4, #0x5</span><br><span class="line">    0x10093e5ac &lt;+88&gt;:  mov    w5, #0x6</span><br><span class="line">    0x10093e5b0 &lt;+92&gt;:  mov    w6, #0x7     ; 这些值我们是可以在通用寄存器里看到的</span><br><span class="line">    0x10093e5b4 &lt;+96&gt;:  mov    w7, #0x8     ; 将8存到w7寄存器中</span><br><span class="line">    ; x8 = 0x0000000100940ce8  &quot;viewDidLoad&quot;</span><br><span class="line">    0x10093e5b8 &lt;+100&gt;: mov    x8, sp       ; 这里是把sp栈顶的位置放在x8寄存器中。</span><br><span class="line">    ; x8 = 0x000000016f4c53c0</span><br><span class="line">    0x10093e5bc &lt;+104&gt;: mov    w10, #0x9    ; 把9放在w10寄存器</span><br><span class="line">    0x10093e5c0 &lt;+108&gt;: str    w10, [x8]    ; 把w10寄存器中的值，放在x8寄存器所在的地址里</span><br><span class="line">    ; 也就是在sp的位置，存放了9这个变量。</span><br><span class="line">-&gt;  0x10093e5c4 &lt;+112&gt;: bl     0x10093e4dc               ; sumA at ViewController.m:16      ; 这里执行 sumA</span><br><span class="line">    0x10093e5c8 &lt;+116&gt;: ldp    x29, x30, [sp, #0x30]    ; x29,x30取值，是为了函数返回</span><br><span class="line">    0x10093e5cc &lt;+120&gt;: add    sp, sp, #0x40             ; =0x40 ; 释放栈空间</span><br><span class="line">    0x10093e5d0 &lt;+124&gt;: ret    </span><br></pre></td></tr></table></figure>

<p>接下来，我们看test的汇编代码情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">`test:</span><br><span class="line">    ; 开辟空间之前 sp = 0x000000016f4c53c0</span><br><span class="line">-&gt;  0x10093e4dc &lt;+0&gt;:   sub    sp, sp, #0x30 ; =0x30</span><br><span class="line">    ; 开辟栈空间后，sp=0x000000016f4c5390</span><br><span class="line">    0x10093e4e0 &lt;+4&gt;:   ldr    w8, [sp, #0x30]  ; 这是从sp+0x30的位置取值，放在w8寄存器里。</span><br><span class="line">    ; sp+0x30就是开辟当前栈空间之前的位置，也就是viewDidLoad开辟空间的栈顶位置，这个位置是x8寄存器指向的位置，存放的是变量9</span><br><span class="line">    0x10093e4e4 &lt;+8&gt;:   str    w0, [sp, #0x2c]  ; 把w0寄存器的值存放在栈sp+0x2c里头，也就是sp偏移4个字节，正好存放一个int类型的数据。</span><br><span class="line">    0x10093e4e8 &lt;+12&gt;:  str    w1, [sp, #0x28]</span><br><span class="line">    0x10093e4ec &lt;+16&gt;:  str    w2, [sp, #0x24]</span><br><span class="line">    0x10093e4f0 &lt;+20&gt;:  str    w3, [sp, #0x20]</span><br><span class="line">    0x10093e4f4 &lt;+24&gt;:  str    w4, [sp, #0x1c]</span><br><span class="line">    0x10093e4f8 &lt;+28&gt;:  str    w5, [sp, #0x18]</span><br><span class="line">    0x10093e4fc &lt;+32&gt;:  str    w6, [sp, #0x14]</span><br><span class="line">    0x10093e500 &lt;+36&gt;:  str    w7, [sp, #0x10]</span><br><span class="line">    0x10093e504 &lt;+40&gt;:  str    w8, [sp, #0xc]   ; w8寄存器的值放在sp+0xc里，w8=9</span><br><span class="line">    0x10093e508 &lt;+44&gt;:  ldr    w8, [sp, #0x2c]  ; 赋值操作 w8=1</span><br><span class="line">    0x10093e50c &lt;+48&gt;:  ldr    w9, [sp, #0x28]  ; w9 = 2</span><br><span class="line">    0x10093e510 &lt;+52&gt;:  add    w8, w8, w9       ; w8 = w8+w9 = 1+2 = 3</span><br><span class="line">    0x10093e514 &lt;+56&gt;:  ldr    w9, [sp, #0x24]  ; w9 = 3</span><br><span class="line">    0x10093e518 &lt;+60&gt;:  add    w8, w8, w9       ; w8 += w9 = 3 + 3</span><br><span class="line">    0x10093e51c &lt;+64&gt;:  ldr    w9, [sp, #0x20]</span><br><span class="line">    0x10093e520 &lt;+68&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e524 &lt;+72&gt;:  ldr    w9, [sp, #0x1c]</span><br><span class="line">    0x10093e528 &lt;+76&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e52c &lt;+80&gt;:  ldr    w9, [sp, #0x18]</span><br><span class="line">    0x10093e530 &lt;+84&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e534 &lt;+88&gt;:  ldr    w9, [sp, #0x14]</span><br><span class="line">    0x10093e538 &lt;+92&gt;:  add    w8, w8, w9</span><br><span class="line">    0x10093e53c &lt;+96&gt;:  ldr    w9, [sp, #0x10]</span><br><span class="line">    0x10093e540 &lt;+100&gt;: add    w8, w8, w9</span><br><span class="line">    0x10093e544 &lt;+104&gt;: ldr    w9, [sp, #0xc]</span><br><span class="line">    0x10093e548 &lt;+108&gt;: add    w0, w8, w9       ; 计算完成</span><br><span class="line">    0x10093e54c &lt;+112&gt;: add    sp, sp, #0x30    ; =0x30 ，释放栈空间</span><br><span class="line">    0x10093e550 &lt;+116&gt;: ret    </span><br></pre></td></tr></table></figure>

<p>这里会把9这个参数存放在<code>viewDidLoad</code>所开辟的栈空间里。执行test后，1-8会存放在<code>test</code>函数所开辟的空间中，然后把9这个参数从<code>viewDidLoad</code>所开辟的栈空间里拿回来，是通过x8寄存器来定位地址获取9这个参数的。相当于从别人家借东西，会存在sp计算的问题，会影响效率。</p>
<p>我们一定要知道的一点是，栈的读写都是从高位往低位进行读写，栈空间的读写都是基于上述原则进行操作的。<br>以上操作，配合View Memory查看内存中的数据会更清晰。</p>
<h3 id="4-2-1-release下操作"><a href="#4-2-1-release下操作" class="headerlink" title="4.2.1 release下操作"></a>4.2.1 release下操作</h3><p>我们的这一系列操作都是在debug模式下进行的，加法的计算产生的汇编代码竟然是如此繁杂。如果我们切换到release下运行，会有什么情况发生？</p>
<p>在release下，编译器会进行优化，我们的test方法，只是做了调用，没有任何实际意义，所以在release下根本不会有bl指令。</p>
<p>如果我们执行<code>printf(&quot;%d&quot;, sumA(1,2,3,4,5,6,7,8,9));</code>呢？</p>
<p>其实差别不大，经过系统优化之后，就只剩下<code>mov    w8, #0x2d</code>这一句代码了，0x2d &#x3D; 45。就是这么简单直接。</p>
<h2 id="4-3-验证返回值"><a href="#4-3-验证返回值" class="headerlink" title="4.3 验证返回值"></a>4.3 验证返回值</h2><p>如果返回值超过8个字节，x0寄存器存不下的时候，会通过栈空间来返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct NumA getStructA(int a, int b, int c, int d, int e, int f) &#123;</span><br><span class="line">    struct NumA num;</span><br><span class="line">    num.a = a;</span><br><span class="line">    num.b = b;</span><br><span class="line">    num.c = c;</span><br><span class="line">    num.d = d;</span><br><span class="line">    num.e = e;</span><br><span class="line">    num.f = f;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    struct NumA num = getStructA(1,2,3,4,5,6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里呢，我们返回一个结构体，正常来说，结构体的大小是根据结构体中的变量决定的。这里有6个int类型的变量也就是24个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">`getStructA:</span><br><span class="line">-&gt;  0x1025424a0 &lt;+0&gt;:  sub    sp, sp, #0x20    ; =0x20 开辟栈空间</span><br><span class="line">    0x1025424a4 &lt;+4&gt;:  str    w0, [sp, #0x1c]</span><br><span class="line">    0x1025424a8 &lt;+8&gt;:  str    w1, [sp, #0x18]</span><br><span class="line">    0x1025424ac &lt;+12&gt;: str    w2, [sp, #0x14]</span><br><span class="line">    0x1025424b0 &lt;+16&gt;: str    w3, [sp, #0x10]</span><br><span class="line">    0x1025424b4 &lt;+20&gt;: str    w4, [sp, #0xc]</span><br><span class="line">    0x1025424b8 &lt;+24&gt;: str    w5, [sp, #0x8]</span><br><span class="line">    0x1025424bc &lt;+28&gt;: ldr    w9, [sp, #0x1c]</span><br><span class="line">    0x1025424c0 &lt;+32&gt;: str    w9, [x8]</span><br><span class="line">    0x1025424c4 &lt;+36&gt;: ldr    w9, [sp, #0x18]</span><br><span class="line">    0x1025424c8 &lt;+40&gt;: str    w9, [x8, #0x4]</span><br><span class="line">    0x1025424cc &lt;+44&gt;: ldr    w9, [sp, #0x14]</span><br><span class="line">    0x1025424d0 &lt;+48&gt;: str    w9, [x8, #0x8]</span><br><span class="line">    0x1025424d4 &lt;+52&gt;: ldr    w9, [sp, #0x10]</span><br><span class="line">    0x1025424d8 &lt;+56&gt;: str    w9, [x8, #0xc]</span><br><span class="line">    0x1025424dc &lt;+60&gt;: ldr    w9, [sp, #0xc]</span><br><span class="line">    0x1025424e0 &lt;+64&gt;: str    w9, [x8, #0x10]</span><br><span class="line">    0x1025424e4 &lt;+68&gt;: ldr    w9, [sp, #0x8]</span><br><span class="line">    0x1025424e8 &lt;+72&gt;: str    w9, [x8, #0x14]</span><br><span class="line">    0x1025424ec &lt;+76&gt;: add    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x1025424f0 &lt;+80&gt;: ret    </span><br></pre></td></tr></table></figure>

<p>这里我们又看到了一个熟悉的x8寄存器。然后通过w9寄存器，不断的赋值给x8寄存器对应的空间里。那这个x8寄存器是怎么个情况呢，我们返回<code>viewDidLoad</code>对应的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">`-[ViewController viewDidLoad]:</span><br><span class="line">...</span><br><span class="line">... ;这里也是截取部分代码</span><br><span class="line">0x1025425ac &lt;+64&gt;:  bl     0x1025429b4               ; symbol stub for: objc_msgSendSuper2</span><br><span class="line">    0x1025425b0 &lt;+68&gt;:  add    x8, sp, #0x8              ; =0x8 </span><br><span class="line">    0x1025425b4 &lt;+72&gt;:  mov    w0, #0x1</span><br><span class="line">    0x1025425b8 &lt;+76&gt;:  mov    w1, #0x2</span><br><span class="line">    0x1025425bc &lt;+80&gt;:  mov    w2, #0x3</span><br><span class="line">    0x1025425c0 &lt;+84&gt;:  mov    w3, #0x4</span><br><span class="line">    0x1025425c4 &lt;+88&gt;:  mov    w4, #0x5</span><br><span class="line">    0x1025425c8 &lt;+92&gt;:  mov    w5, #0x6</span><br><span class="line">    0x1025425cc &lt;+96&gt;:  bl     0x1025424a0               ; getStructB at ViewController.m:46</span><br><span class="line">-&gt;  0x1025425d0 &lt;+100&gt;: ldp    x29, x30, [sp, #0x40]</span><br><span class="line">    0x1025425d4 &lt;+104&gt;: add    sp, sp, #0x50             ; =0x50 </span><br><span class="line">    0x1025425d8 &lt;+108&gt;: ret    </span><br></pre></td></tr></table></figure>

<p>我们看到x8寄存器的位置是sp偏移8个字节。也就是返回值所在的空间是在<code>viewDidLoad</code>开辟的栈空间里。</p>
<p>这里会当前返回值存放在<code>viewDidLoad</code>所开辟的栈空间里，因为知道返回的是什么类型的数据，在<code>viewDidLoad</code>开辟空间时，就已经把返回值所需要的空间给预留出来了。通过x8寄存器来定位返回值所在的空间。</p>
<p>那么，这里为什么要偏移8个字节？</p>
<p>我们知道，ARM64对栈的操作是16个字节进行对齐的。而结构体占有24个字节，我们只能通过补齐来确保是16个字节的倍数来开辟空间。</p>
<p>执行对应的方法，对返回值的变量进行存储（根据x8寄存器来定位相应的地址存储变量的值）。</p>
<h1 id="5-函数的局部变量"><a href="#5-函数的局部变量" class="headerlink" title="5. 函数的局部变量"></a>5. 函数的局部变量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int sumC(int a, int b) &#123;</span><br><span class="line">    int c = 10;</span><br><span class="line">    return a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    sumC(1,2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行，进入汇编模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Demo`-[ViewController viewDidLoad]:</span><br><span class="line">    0x1026ae45c &lt;+68&gt;: mov    w0, #0x1</span><br><span class="line">    0x1026ae460 &lt;+72&gt;: mov    w1, #0x2</span><br><span class="line">-&gt;  0x1026ae464 &lt;+76&gt;: bl     0x1026ae3e8               ; sumC at ViewController.m:75</span><br><span class="line">    0x1026ae468 &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x1026ae46c &lt;+84&gt;: add    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x1026ae470 &lt;+88&gt;: ret  </span><br></pre></td></tr></table></figure>

<p>sumC(1, 2)：1和2分别放在了w0、w1寄存器中。然后执行bl，进入函数sumC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Demo`sumC:</span><br><span class="line">-&gt;  0x1026ae3e8 &lt;+0&gt;:  sub    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x1026ae3ec &lt;+4&gt;:  str    w0, [sp, #0xc]</span><br><span class="line">    0x1026ae3f0 &lt;+8&gt;:  str    w1, [sp, #0x8]</span><br><span class="line">    0x1026ae3f4 &lt;+12&gt;: mov    w8, #0xa</span><br><span class="line">    0x1026ae3f8 &lt;+16&gt;: str    w8, [sp, #0x4]</span><br><span class="line">    0x1026ae3fc &lt;+20&gt;: ldr    w8, [sp, #0xc]</span><br><span class="line">    0x1026ae400 &lt;+24&gt;: ldr    w9, [sp, #0x8]</span><br><span class="line">    0x1026ae404 &lt;+28&gt;: add    w8, w8, w9</span><br><span class="line">    0x1026ae408 &lt;+32&gt;: ldr    w9, [sp, #0x4]</span><br><span class="line">    0x1026ae40c &lt;+36&gt;: add    w0, w8, w9</span><br><span class="line">    0x1026ae410 &lt;+40&gt;: add    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x1026ae414 &lt;+44&gt;: ret    </span><br></pre></td></tr></table></figure>

<ol>
<li>开辟16个字节的内存空间</li>
<li>把w0放在[sp+0xc]，w1放在[sp+0x8]</li>
<li>w8赋值等于0xa，这里就是我们的局部变量c&#x3D;10</li>
<li>然后把w8放在[sp+0x4]里头</li>
<li>一堆操作，ret</li>
</ol>
<p>看到了吧，函数的参数和局部变量都是放在栈里的。</p>
<h1 id="6-函数嵌套"><a href="#6-函数嵌套" class="headerlink" title="6. 函数嵌套"></a>6. 函数嵌套</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int funcSum(int a, int b, int c) &#123;</span><br><span class="line">    int d = a + b + c;</span><br><span class="line">    printf(&quot;%d&quot;, d);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int totalSum(int a, int b) &#123;</span><br><span class="line">    int c = 10;</span><br><span class="line">    int d = funcSum(a, b, c);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    totalSum(1, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行上面的含有局部变量的嵌套函数，看是怎么在汇编下执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Demo`-[ViewController viewDidLoad]:</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    0x1002fa43c &lt;+64&gt;: bl     0x1002fa8d0               ; symbol stub for: objc_msgSendSuper2</span><br><span class="line">    // totalSum(1, 2)</span><br><span class="line">    0x1002fa440 &lt;+68&gt;: mov    w0, #0x1  // 将1存在w0寄存器里</span><br><span class="line">    0x1002fa444 &lt;+72&gt;: mov    w1, #0x2  // 2存放在w1寄存器里</span><br><span class="line">-&gt;  0x1002fa448 &lt;+76&gt;: bl     0x1002fa3bc               ; totalSum at ViewController.m:86</span><br><span class="line">    0x1002fa44c &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]     ; x29、x30寄存器取值（lr寄存器获取回家的路）</span><br><span class="line">    0x1002fa450 &lt;+84&gt;: add    sp, sp, #0x30             ; =0x30 </span><br><span class="line">    0x1002fa454 &lt;+88&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这一坨汇编代码，已经看过无数次了，这里不细说了，直接走totalSum看看是怎么处理的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Demo`totalSum:</span><br><span class="line">-&gt;  0x1002fa3bc &lt;+0&gt;:  sub    sp, sp, #0x20             ; =0x20 </span><br><span class="line">    0x1002fa3c0 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]</span><br><span class="line">    0x1002fa3c4 &lt;+8&gt;:  add    x29, sp, #0x10            ; =0x10 </span><br><span class="line">    0x1002fa3c8 &lt;+12&gt;: stur   w0, [x29, #-0x4]  ; 把totalSum的参数w0存放在栈底的位置</span><br><span class="line">    0x1002fa3cc &lt;+16&gt;: str    w1, [sp, #0x8]    ; 把w1的值放在栈顶+8个字节的位置</span><br><span class="line">    0x1002fa3d0 &lt;+20&gt;: mov    w8, #0xa          ; 获取局部变量10，放在w8寄存器</span><br><span class="line">    0x1002fa3d4 &lt;+24&gt;: str    w8, [sp, #0x4]    ; w8的值放在sp+4个字节的位置</span><br><span class="line">    0x1002fa3d8 &lt;+28&gt;: ldur   w0, [x29, #-0x4]  ; 重新对w0赋值，取值的位置就是之前w0存放的位置 w0=1</span><br><span class="line">    0x1002fa3dc &lt;+32&gt;: ldr    w1, [sp, #0x8]    ; w1取值w1=2</span><br><span class="line">    0x1002fa3e0 &lt;+36&gt;: ldr    w2, [sp, #0x4]    ; w2 = 10</span><br><span class="line">    0x1002fa3e4 &lt;+40&gt;: bl     0x1002fa35c       ; funcSum at ViewController.m:80 ;执行嵌套函数 funcSum。</span><br><span class="line">    0x1002fa3e8 &lt;+44&gt;: str    w0, [sp]          ; 把w0的值存在sp对应的位置。</span><br><span class="line">    0x1002fa3ec &lt;+48&gt;: ldr    w0, [sp]          ; 获取w0</span><br><span class="line">    0x1002fa3f0 &lt;+52&gt;: ldp    x29, x30, [sp, #0x10] ; 找到回家的路</span><br><span class="line">    0x1002fa3f4 &lt;+56&gt;: add    sp, sp, #0x20     ; =0x20 释放</span><br><span class="line">    0x1002fa3f8 &lt;+60&gt;: ret   </span><br></pre></td></tr></table></figure>

<p>这里用到了<code>stur</code>和<code>ldur</code>。这两个的本质与<code>str</code>和<code>ldr</code>没有区别，只是带<code>u</code>的偏移的是一个负值。</p>
<p>这里也有用到x29寄存器，还有印象吗？x29寄存器就是fp寄存器，指向的是栈底的位置。从栈的存储空间来看，栈底的地址比栈顶大，所以sp栈顶开辟空间都是减去一个值，而用栈底fp做关键值时，要想获取数据都必须在sp-fp之间拿值，所以基于fp的操作都是【减】。</p>
<p>这里为什么把局部变量的值存在w8里面，就是因为w0-w7是存放函数参数的参数，之前说过，w8用来获取局部变量。</p>
<p>funcSum函数的汇编就不说了，与之前的没什么区别。</p>
<p>这里需要提一句的是，为啥要把参数先存放在内存里，然后再取出来，难道就不嫌麻烦吗？其主要目的就是为了保护参数，防止被改变。</p>
<p>到最后w0&#x2F;x0寄存器还是用来存放返回值。</p>
<h1 id="7-补充内容"><a href="#7-补充内容" class="headerlink" title="7. 补充内容"></a>7. 补充内容</h1><ol>
<li><p>一个函数的参数，在函数执行完毕之后，是否能拿到这个参数的值？我们用4.2小结的代码来解释一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i) &#123;</span><br><span class="line">    return a+b+c+d+e+f+g+h+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    test(1,2,3,4,5,6,7,8,9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 这个test函数有9个参数，我们知道，x0-x7（w0-w7）这个8个寄存器是存放函数变量的，如果超过8个参数，则会存放在viewDidLoad函数开辟的栈空间内，也就是说1-8这8个参数是在test函数开辟的栈空间。这8个参数在test函数执行完毕之后，随着空间的释放就拿不到了，而9这个参数存放在<code>viewDidLoad</code>的栈空间，我们还可以拿到。</p>
</li>
<li><p>在4.3小结，我们返回的是一个结构体，而不是一个指针，假如，我们添加一个函数，来调用这个返回的结构体，这个结构体能不能用。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct NumA getStructA(int a, int b, int c, int d, int e, int f) &#123;</span><br><span class="line">    struct NumA num;</span><br><span class="line">    num.a = a;</span><br><span class="line">    num.b = b;</span><br><span class="line">    num.c = c;</span><br><span class="line">    num.d = d;</span><br><span class="line">    num.e = e;</span><br><span class="line">    num.f = f;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct NumA returnStruct() &#123;</span><br><span class="line">    struct NumA num = getStructA(1,2,3,4,5,6);</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    struct NumB num = returnStruct();</span><br><span class="line">    printf(&quot;a = %d\n&quot;, num.a);  // 这里是否能输出，还是会crash</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 肯定是可以输出的，在<code>viewDidLoad</code>函数执行时，就已经创建了<code>struct NumB</code>所需要的空间了，返回的数据都存在于<code>viewDidLoad</code>的栈空间里，所以还是可以正常执行的。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>栈：引出SP、FP寄存器。SP：保存栈顶地址，FP：保存栈底的地址。（栈顶的地址比栈底的地址小，所以获取栈顶的值都是通过sub sp, sp #0x10,是减去一个空间，在存值的时候一般都是[sp+#0x08]）</li>
<li>stp&#x2F;str 存值（16个字节&#x2F;8个字节）</li>
<li>ldp&#x2F;ldr 取值（16个字节&#x2F;8个字节）</li>
<li>stur&#x2F;ldur 本质上与str&#x2F;ldr没有区别，带【u】的操作的是一个负值。</li>
<li>bl指令：通过lr(x30)寄存器，保存回家的路，bl跳转到对应的方法</li>
<li>lr寄存器的值会通过保存在栈空间，来确保能够正确的返回。</li>
<li>函数的参数：存放在x0-x7寄存器，超过8个，则放在栈里。</li>
<li>返回值：使用x0寄存器保存，如果大于8个字节，会利用栈空间传递。</li>
<li>函数的局部变量放在栈里，嵌套函数的值也是放在栈里</li>
<li>会把变量的值放在内存里保护起来，用的时候在去取值</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/11/%E9%80%86%E5%90%91/nx-1-iPhone%E8%B6%8A%E7%8B%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/11/%E9%80%86%E5%90%91/nx-1-iPhone%E8%B6%8A%E7%8B%B1/" class="post-title-link" itemprop="url">iPhone越狱</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-11 11:30:03" itemprop="dateCreated datePublished" datetime="2021-04-11T11:30:03+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h1><ol>
<li>我们需要一台iPhone手机，根据自己的条件，要求系统是iOS11.0 - 14.3，写这篇博客时所能处理的越狱系统是这个，过期之后请自行查找资料。</li>
<li>越狱的网站：<a target="_blank" rel="noopener" href="https://unc0ver.dev/">https://unc0ver.dev/</a>，下载安装包（ipa文件），可以按照对应的步奏进行操作，本篇所说的有另外一种，使用重签名的机制，比较简单。</li>
</ol>
<h1 id="2-开始越狱"><a href="#2-开始越狱" class="headerlink" title="2. 开始越狱"></a>2. 开始越狱</h1><ol>
<li><p>打开我们的工程文件，请自行下载。</p>
</li>
<li><p>在”Signing &amp; Capabilities” 下，修改”Bundle Identifier”为自己的，修改”Team” 使用”personal team”。</p>
</li>
<li><p>在”Build Phases” - “Run Script”下，先将script运行代码注释掉。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 重签名机制的脚本文件</span><br><span class="line">#./appSign.sh</span><br></pre></td></tr></table></figure></li>
<li><p>运行当前的空工程文件到手机上。</p>
</li>
<li><p>运行完成之后，在回到”Build Phases” - “Run Script”下，将注释打开，重新运行。</p>
</li>
<li><p>“unc0ver”这个APP已经出现在手机上，点击APP，直接开始”Jailbreak”。手机重启几次之后，就可以了。</p>
</li>
<li><p>在”Setting”中，可以选择自己想使用的选项。其中 “Restore RootFS”可以回到未越狱状态。</p>
</li>
</ol>
<h1 id="3-为什么使用unc0ver"><a href="#3-为什么使用unc0ver" class="headerlink" title="3. 为什么使用unc0ver"></a>3. 为什么使用unc0ver</h1><ol>
<li>它可以在越狱之后，通过简单的操作回到当初未越狱的状态，对系统侵扰是最低的。</li>
<li>这个是一个安装在手机上的APP，可以随时删除。</li>
<li>开发者更新比较及时。写本篇时，iOS系统可更新的版本是14.4.2，而unc0ver已经支持到14.3版本了。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/10/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E9%80%86%E5%90%91/ARM%E6%B1%87%E7%BC%96-1/" class="post-title-link" itemprop="url">ARM汇编-1 初识汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 22:47:53" itemprop="dateCreated datePublished" datetime="2021-04-10T22:47:53+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-初识汇编"><a href="#1-初识汇编" class="headerlink" title="1. 初识汇编"></a>1. 初识汇编</h1><blockquote>
<p>汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。</p>
</blockquote>
<p>一个APP安装在手机上面的可执行文件本质上是二进制文件。因为iPhone手机本质上执行的指令是二进制，是由手机上的CPU执行的。所以静态分析是建立在分析二进制上面。</p>
<h1 id="2-发展历程"><a href="#2-发展历程" class="headerlink" title="2. 发展历程"></a>2. 发展历程</h1><h2 id="2-1-编程语言"><a href="#2-1-编程语言" class="headerlink" title="2.1 编程语言"></a>2.1 编程语言</h2><p>从1946年第一台电子计算机问世，人类和机器的交流方式和语言就成为了软件工程师和计算机从业者的主要研究方向。在过去的几十年，编程语言有了长足的发展。</p>
<h2 id="2-2-机器语言"><a href="#2-2-机器语言" class="headerlink" title="2.2 机器语言"></a>2.2 机器语言</h2><p>计算机的硬件作为一种电路元件，它的输出和输入只能是有电或者没电，也就是所说的高电平和低电平，所以计算机传递的数据是由“0” 和“1”组成的二进制数，所以说二进制的语言是计算机语言的本质。</p>
<h2 id="2-3-汇编语言"><a href="#2-3-汇编语言" class="headerlink" title="2.3 汇编语言"></a>2.3 汇编语言</h2><p>不难看出机器语言作为一种编程语言，灵活性较差可阅读性也很差，为了减轻机器语言带给软件工程师的不适应，人们对机器语言进行了升级和改进：用一些容易理解和记忆的字母，单词来代替一个特定的指令。这就是助记符。</p>
<h2 id="2-4-高级语言"><a href="#2-4-高级语言" class="headerlink" title="2.4 高级语言"></a>2.4 高级语言</h2><p>人们需要设计一个能够不依赖于计算机硬件，能够在不同机器上运行的程序。这样可以免去很多编程的重复过程，提高效率，同时这种语言又要接近于数学语言或人的自然语言。这就诞生了高级编程语言。比如：C、C++、Java、OC、Swift。</p>
<p>我们的代码在终端设备上的执行过程，如下图：<br><img src="1171618126145_.pic_hd.jpg" alt="1171618126145_.pic_hd"></p>
<ul>
<li>汇编语言与机器语言一一对应，每一条机器指令都有与之对应的汇编指令</li>
<li>汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言</li>
<li>高级语言可以通过编译得到汇编语言\机器语言，但汇编语言\机器语言几乎不可能还原成高级语言</li>
</ul>
<h2 id="2-5-汇编语言的特点"><a href="#2-5-汇编语言的特点" class="headerlink" title="2.5 汇编语言的特点"></a>2.5 汇编语言的特点</h2><ul>
<li>可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能</li>
<li>能够不受编译器的限制，对生成的二进制代码进行完全的控制</li>
<li>目标代码简短，占用内存少，执行速度快</li>
<li>汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</li>
<li>不区分大小写，比如mov和MOV是一样的</li>
<li>知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</li>
</ul>
<h2 id="2-6-用途"><a href="#2-6-用途" class="headerlink" title="2.6 用途"></a>2.6 用途</h2><ul>
<li>编写驱动程序、操作系统（比如Linux内核的某些关键部分）</li>
<li>对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）</li>
<li>软件安全<ul>
<li>病毒分析与防治</li>
<li>逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客</li>
</ul>
</li>
<li>理解整个计算机系统的最佳起点和最有效途径</li>
<li>为编写高效代码打下基础</li>
<li>弄清代码的本质</li>
</ul>
<p>越底层越单纯，但是使用起来越困难，同时也是程序员都需要了解的非常重要的语言。</p>
<h2 id="2-7-汇编语言的分类"><a href="#2-7-汇编语言的分类" class="headerlink" title="2.7 汇编语言的分类"></a>2.7 汇编语言的分类</h2><ul>
<li>8086汇编 （8086处理器时16bit的CPU）</li>
<li>Win32汇编</li>
<li>Win64汇编</li>
<li>ARM汇编（Mac，iOS）</li>
</ul>
<p>在iPhone里面，用的的ARM汇编，又根据CPU的架构不同而有差异。</p>
<table>
<thead>
<tr>
<th align="center">架构</th>
<th align="center">设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">armv6</td>
<td align="center">古老的iPhone3G之前，iPod Touch（第一代，第二代）</td>
</tr>
<tr>
<td align="center">armv7</td>
<td align="center">iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3, iPad Mini, iPod Touch 3G, iPod Touch4</td>
</tr>
<tr>
<td align="center">armv7s</td>
<td align="center">iPhone5, iPhone5C, iPad4</td>
</tr>
<tr>
<td align="center">armv64</td>
<td align="center">iPhone5S及以后的设备，iPad Air，iPad Mini2以后</td>
</tr>
</tbody></table>
<h1 id="3-几个必要的知识点"><a href="#3-几个必要的知识点" class="headerlink" title="3. 几个必要的知识点"></a>3. 几个必要的知识点</h1><h2 id="3-1-bit"><a href="#3-1-bit" class="headerlink" title="3.1 bit"></a>3.1 bit</h2><p>bit：表示『位』或者『比特』，是计算机运算的基础单位，是二进制数的最小单元。1 bit就是1位二进制数，只能存放0或者1。</p>
<h2 id="3-2-Byte"><a href="#3-2-Byte" class="headerlink" title="3.2 Byte"></a>3.2 Byte</h2><p>Byte：表示『字节』，是计算机文件大小的基本单位。1Byte &#x3D; 8bit，表示一个字节可以存放8位无符号数。一个汉子是2个字节，16位。一个英文字母是1个字节。</p>
<p>1个字节可以表示为：0000 0000，1111 1111。</p>
<h2 id="3-3-总线"><a href="#3-3-总线" class="headerlink" title="3.3 总线"></a>3.3 总线</h2><p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。</p>
<p>总线是一种内部结构，它是cpu、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。</p>
<p>在计算机系统中，各个部件之间传送信息的公共通路叫总线，微型计算机是以总线结构来连接各个功能部件的。</p>
<p>简单来说</p>
<ul>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件交互。</li>
<li>总线就是一根根导线的集合</li>
</ul>
<h3 id="3-3-1-总线分类"><a href="#3-3-1-总线分类" class="headerlink" title="3.3.1 总线分类"></a>3.3.1 总线分类</h3><p>一般情况下分为5大类：</p>
<ol>
<li>数据总线：在CPU与RAM之间来回传送需要处理或需要存储的数据。它的宽度决定了CPU单次数据传送量，也就是数据传送的速度。例如：8086微处理器子长16位，其数据总线宽度也是16位，所以单次最大传递2个字节的数据。</li>
<li>地址总线：用来指定在RAM之中存储的数据的地址。它的宽度决定了CPU的寻址能力。例如8086的地址总线宽度是20位，那么它的寻址能力是1M（2^20）。</li>
<li>控制总线：将微处理器控制单元的信号，传送到周边设备。它的宽度决定了CPU对其他器件的控制能力。</li>
<li>扩展总线：外部设备和计算机主机进行数据通信的总线，例如ISA，PCI总线。</li>
<li>局部总线：取代更高速数据传输的扩展总线。</li>
</ol>
<p>其中数据总线、地址总线、控制总线也统称为系统总线。</p>
<h2 id="3-4-进制"><a href="#3-4-进制" class="headerlink" title="3.4 进制"></a>3.4 进制</h2><p>常用的进制有2进制，8进制，10进制，16进制。<br>2进制：00 11 11 100 101，逢2进1<br>8进制 0 1 2 3 4 5 6 7 10， 逢8进1<br>16进制 0 1 2 3 4 5 6 7 8 9 A B C D E F 10， 逢16进1</p>
<p>还有一些可以自己定义的进制，约定几个符合来表示对应的数据：<br>比如3进制 我们用a 3 1表示，通常约定好一些符合来表示对应的数据，以此来达到加密的效果。</p>
<p>运算等一些列就不说了~~~</p>
<h2 id="3-5-数据的宽度"><a href="#3-5-数据的宽度" class="headerlink" title="3.5 数据的宽度"></a>3.5 数据的宽度</h2><p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int test() &#123;</span><br><span class="line">    int cTemp = 0x1FFFFFFFF;</span><br><span class="line">    return cTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个int类型的变量，但是赋值的是9位16进制数。但是这里打印cTemp的值发现是-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p cTemp</span><br><span class="line">(int) $0 = -1</span><br><span class="line">(lldb) p &amp;cTemp</span><br><span class="line">(int *) $1 = 0x000000016f8e926c</span><br><span class="line">(lldb) x 0x000000016f8e926c</span><br><span class="line">0x16f8e926c: ff ff ff ff b0 92 8e 6f 01 00 00 00 88 a5 51 00  .......o......Q.</span><br><span class="line">0x16f8e927c: 01 00 00 00 10 00 00 00 00 00 00 00 02 00 00 00  ................</span><br><span class="line">(lldb) p (uint)cTemp</span><br><span class="line">(uint) $0 = 4294967295</span><br></pre></td></tr></table></figure>

<p>通过上面的打印，发现cTemp所在的地址钟存放的是ff ff ff ff，而前面的1没有了，这就是发生了溢出。但是通过转换无符号数，发现是可以正常打印的。这就说明了，地址钟存放的数据是没有发生变化的，只是由于位数的限制导致的有符号和无符号的区别，导致的数据不一致。</p>
<p>在通常的二进制中，第一位表示正负，0表示正 1表示负。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// int 4个字节，表示32位。第一位为符号为。</span><br><span class="line"> F    F    F    F    F    F    F    F</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>

<p>这里提一嘴我们经常用的宽带，都是100M的，200M的，但是这个的意思是100Mbps，说的也是宽度，除以8才是对应的数据传输速度。</p>
<h1 id="4-CPU-amp-寄存器"><a href="#4-CPU-amp-寄存器" class="headerlink" title="4. CPU &amp; 寄存器"></a>4. CPU &amp; 寄存器</h1><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>
<ul>
<li>对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制。</li>
<li>不同的CPU，寄存器的个数、结构是不相同的。</li>
</ul>
<h2 id="4-1-浮点和向量寄存器"><a href="#4-1-浮点和向量寄存器" class="headerlink" title="4.1 浮点和向量寄存器"></a>4.1 浮点和向量寄存器</h2><p>因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数</p>
<ul>
<li>浮点寄存器 64位: D0 - D31 32位: S0 - S31</li>
</ul>
<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>
<ul>
<li>向量寄存器 128位:V0-V31</li>
</ul>
<h2 id="4-2-通用寄存器"><a href="#4-2-通用寄存器" class="headerlink" title="4.2 通用寄存器"></a>4.2 通用寄存器</h2><p>通用寄存器也称数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。</p>
<p>ARM64拥有有32个64位的通用寄存器 x0 到 x30，以及XZR(零寄存器),这些通用寄存器有时也有特定用途。</p>
<ul>
<li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li>
<li>比如 w0 就是 x0的低32位!</li>
</ul>
<p><img src="arm-register.jpg"></p>
<p>图片上标注了1、2、3、4分别有所对应。<br>1 - 点击进入汇编<br>2 - 进入汇编之后，选择『All Variables, register』，会显示如图所示<br>3 - 浮点和向量寄存器，存放对应的v0-v31，d0-d31，s0-s31<br>4 - 通用寄存器，存放x0-x28，fp，lr，sp，pc，w0-w28</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov x0, #0xa0           ; x0 = 0xa0</span><br><span class="line">mov x1,#0x00            ; x1 = 0x00</span><br><span class="line">add x1, x0, #0x14       ; x1 = x0 + 0x14</span><br><span class="line">mov x0,x1               ; x0 = x1</span><br></pre></td></tr></table></figure>

<h2 id="4-3-pc寄存器-program-counter"><a href="#4-3-pc寄存器-program-counter" class="headerlink" title="4.3 pc寄存器(program counter)"></a>4.3 pc寄存器(program counter)</h2><ul>
<li><p>为指令指针寄存器，它指示了CPU当前要读取指令的地址</p>
</li>
<li><p>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</p>
</li>
<li><p>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义</p>
<ul>
<li>比如 1110 0000 0000 0011 0000 1000 1010 1010</li>
<li>可以当做数据 0xE003008AA</li>
<li>也可以当做指令 mov x0, x8</li>
</ul>
</li>
<li><p>CPU根据什么将内存中的信息看做指令？</p>
<ul>
<li>CPU将pc指向的内存单元的内容看做指令</li>
<li>如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li>
</ul>
</li>
</ul>
<h2 id="4-4-高速缓存"><a href="#4-4-高速缓存" class="headerlink" title="4.4 高速缓存"></a>4.4 高速缓存</h2><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个高速缓存存储区域.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
<h2 id="4-5-bl指令"><a href="#4-5-bl指令" class="headerlink" title="4.5 bl指令"></a>4.5 bl指令</h2><p>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令。</p>
<p>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如<br>mov x0,#10、mov x1,#20。但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p>
<p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p>
<h3 id="4-5-1-bl指令-–-练习"><a href="#4-5-1-bl指令-–-练习" class="headerlink" title="4.5.1 bl指令 – 练习"></a>4.5.1 bl指令 – 练习</h3><p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _A,_B</span><br><span class="line"></span><br><span class="line">_A:</span><br><span class="line">    mov x0,#0xa0</span><br><span class="line">    mov x1,#0x00</span><br><span class="line">    add x1, x0, #0x14</span><br><span class="line">    mov x0,x1</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0,#0x0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    add x0, x0, #0x10</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<ol>
<li><p>打开Xcode，新建一个工程，在新建文件是选择 『Assembly File』，生成的是『.s』文件。然后将上面的代码复制粘贴。</p>
</li>
<li><p>在ViewController中，进行函数声明。这里需要注意的是，方法明需要一致。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//函数的声明~~</span><br><span class="line">int A();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>viewDidLoad</code>中直接调用<code>A()</code>，打断点，然后跳转到汇编。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    mov x0, #0xa0       ; x0 = a0</span><br><span class="line">    mov x1,#0x00        ; x1 = 0</span><br><span class="line">    add x1, x0, #0x14   ; x1 = x0 + 0x14</span><br><span class="line">    mov x0,x1           ; x0 = x1</span><br><span class="line">    bl _B               ; 跳转到方法 _B --&gt; 执行B</span><br><span class="line">    mov x0, #0x0        ; 从B回来之后执行 x0 = 0</span><br><span class="line">    ret                 ; return, 继续点击会发现啥？</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    add x0, x0, #0x10   ; x0 += 10</span><br><span class="line">    ret                 ; return，方法结束回到A继续执行</span><br></pre></td></tr></table></figure>

<p>这里会有一点问的哈~会导致循环了。为啥会导致循环了呢？翻下一章。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><ol>
<li>汇编基础知识，发展、用途、特点</li>
<li>几个知识点：bit，Byte，总线，数据宽度</li>
<li>CPU 寄存器。浮点寄存器（64位: D0 - D31 32位: S0 - S31）；向量寄存器（128位:V0-V31）；通用寄存器（32位w0-w28，64位x0-x28），PC寄存器。</li>
<li>bl指令</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2021/04/10/%E9%80%86%E5%90%91/mima-1-RSA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E9%80%86%E5%90%91/mima-1-RSA/" class="post-title-link" itemprop="url">密码学_RSA</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 15:25:44" itemprop="dateCreated datePublished" datetime="2021-04-10T15:25:44+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-密码学"><a href="#1-密码学" class="headerlink" title="1. 密码学"></a>1. 密码学</h1><h2 id="1-1-密码学概述"><a href="#1-1-密码学概述" class="headerlink" title="1.1 密码学概述"></a>1.1 密码学概述</h2><p>密码学是指研究信息加密，破解密码的技术科学。密码学的起源可追溯到2000年前。而当今的密码学是以数学为基础的。</p>
<h2 id="1-2-发展"><a href="#1-2-发展" class="headerlink" title="1.2 发展"></a>1.2 发展</h2><ol>
<li>在1976年以前，所有的加密方法都是同一种模式：加密、解密使用同一种算法。在交互数据的时候，彼此通信的双方就必须将规则告诉对方，否则没法解密。那么加密和解密的规则（简称密钥），它保护就显得尤其重要。传递密钥就成为了最大的隐患。这种加密方式被成为对称加密算法（symmetric encryption algorithm）</li>
<li>1976年，两位美国计算机学家 迪菲（W.Diffie）、赫尔曼（ M.Hellman ） 提出了一种崭新构思，可以在不直接传递密钥的情况下，完成密钥交换。这被称为“<B>迪菲赫尔曼密钥交换</B>”算法。开创了密码学研究的新方向。</li>
<li>1977年三位麻省理工学院的数学家 <B>罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）</B>一起设计了一种算法，可以实现<B>非对称加密</B>。这个算法用他们三个人的名字命名，叫做<B>RSA算法</B>。</li>
</ol>
<h1 id="2-RSA"><a href="#2-RSA" class="headerlink" title="2. RSA"></a>2. RSA</h1><p>RSA加密方式比较特殊，需要两个密钥：公开密钥简称公钥（publickey）和私有密钥简称私钥（privatekey）。公钥加密，私钥解密；私钥加密，公钥解密。这个加密算法就是伟大的RSA。</p>
<h2 id="2-1-欧拉函数"><a href="#2-1-欧拉函数" class="headerlink" title="2.1 欧拉函数"></a>2.1 欧拉函数</h2><p>首先考虑什么是离散对数：在整数中，离散对数（英语：Discrete logarithm）是一种基于同余运算和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E6%A0%B9">原根</a>的一种对数运算。</p>
<p>互质关系：如果两个正整数，除了1以外，没有其他公因数，我们就称这两个数是互质关系（coprime）。</p>
<p>有一个正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？<br>计算这个值的方式就是<b>欧拉函数</b>。用φ(n)来表示。φ -&gt; phi</p>
<p>例如：</p>
<blockquote>
<p>计算8的欧拉函数，和8互质的数有1、3、5、7<br>φ(8) &#x3D; 4</p>
<p>例如计算7的欧拉函数，和7互质的数有1、2、3、4、5、6<br>φ(7) &#x3D; 6</p>
<p>例如计算56的欧拉函数<br>φ(56) &#x3D; φ(8) * φ(7) &#x3D; 4 * 6 &#x3D; 24</p>
</blockquote>
<h3 id="2-2-1-欧拉函数的特性："><a href="#2-2-1-欧拉函数的特性：" class="headerlink" title="2.2.1 欧拉函数的特性："></a>2.2.1 欧拉函数的特性：</h3><ol>
<li>当n是质数的时候，φ(n)&#x3D;n-1。</li>
<li>如果n可以分解成两个互质的整数之积，如n&#x3D;A<em>B则：φ(A</em>B)&#x3D;φ(A)* φ(B)</li>
</ol>
<p>根据以上两点得到：<br>如果N是两个质数P1 和 P2的乘积则φ(N)&#x3D;φ(P1)* φ(P2)&#x3D;(P1-1)*(P2-1)</p>
<h2 id="2-2-欧拉定理"><a href="#2-2-欧拉定理" class="headerlink" title="2.2 欧拉定理"></a>2.2 欧拉定理</h2><p>如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除。</p>
<p>m^φ(n) % n &#x3D; 1</p>
<p>也就是说，m的φ(n)次方减去1，能被n整出。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// m = 3， n = 11, φ(n) = 10</span><br><span class="line">// 再Python3的环境下，快速输出结果，如下</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3**10%11</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-费马小定理"><a href="#2-2-1-费马小定理" class="headerlink" title="2.2.1 费马小定理"></a>2.2.1 费马小定理</h3><p>欧拉定理的特殊情况：如果两个正整数m和n互质，而且n为质数！那么φ(n)结果就是n-1。</p>
<p>m^(n-1) % n &#x3D; 1</p>
<p>这就是一开始所说的那种情况，如果n为质数，则φ(n)&#x3D; n-1</p>
<h2 id="2-3-模反元素"><a href="#2-3-模反元素" class="headerlink" title="2.3 模反元素"></a>2.3 模反元素</h2><p>如果两个正整数e和x互质，那么一定可以找到整数d，使得 ed-1 被x整除。那么d就是e对于x的“模反元素”。<br>e*d % x &#x3D; 1</p>
<h2 id="2-4-公式推导过程："><a href="#2-4-公式推导过程：" class="headerlink" title="2.4 公式推导过程："></a>2.4 公式推导过程：</h2><ol>
<li><p>1^k &#x3D; 1, 1的k次方等于1</p>
</li>
<li><p>1 * m &#x3D; m</p>
</li>
<li><p>根据欧拉定理：m^φ(n) % n &#x3D; 1，公式两边分别执行k次方。</p>
</li>
<li><p>(m^φ(n) % n)^k &#x3D; 1^k 公式简化后：</p>
</li>
<li><p>m^k*φ(n) % n &#x3D; 1，等式两边分别乘以m</p>
</li>
<li><p>(m^k*φ(n) % n) * m &#x3D; 1 * m 简化后：</p>
</li>
<li><p>m^k*φ(n)+1 % n &#x3D; m</p>
</li>
<li><p>根据模反元素的公式：e<em>d % x &#x3D; 1，则 e</em>d &#x3D; k*x + 1</p>
</li>
</ol>
<p>到这里，有没有发现什么？看推导的第7步和第8步的公式，k<em>φ(n)+1 和 k</em>x+1是不是很相似。则 e * d &#x3D; k*φ(n)+1</p>
<p>那最后是不是可以得出：m^ed % n &#x3D; m</p>
<p>这就是大名鼎鼎的<b>迪菲赫尔曼密钥交换</b>。<br>我们假设 m &#x3D; 3，n &#x3D; 17，<br>服务器生成随机数 e &#x3D; 15，客户端生成随机数 d &#x3D; 13</p>
<p>服务器 m^e % n，结果是 3^15 % 17 &#x3D; 6， 把明文6传给客户端。<br>客户端 m^d % n，结果是 3^13 % 17 &#x3D; 12， 把明文12传给服务器。</p>
<p>两端拿到的数据分别进行解密：<br>客户端 6^13 % 17 &#x3D; 10<br>服务器 12^15 % 17 &#x3D; 10</p>
<p><b>迪菲赫尔曼密钥交换</b>:<br>3^15<em>12 % n &#x3D; 3^13</em>15 % n<br>m^e<em>d % n &#x3D; 10 &#x3D; m^d</em>e % n</p>
<p>从这个时候开始，开创了密码学研究的新方向，也为RSA加密打下了基础。RSA对上面的公式进行了拆分：</p>
<p>m^e % n &#x3D; c<br>c^d % n &#x3D; m</p>
<p>这就是RSA诞生的原理。其中<br>m^e % n &#x3D; c 进行加密<br>c^d % n &#x3D; m 进行解密</p>
<p>n、e是公钥，n、d是私钥，m是明文，c是密文。</p>
<p>验证： m &#x3D; 4， n &#x3D; 15， φ(n) &#x3D; 8， e &#x3D; 3，<br>求出d（d是e对于φ(n)的“模反元素”） d &#x3D; 11，19</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// python3环境</span><br><span class="line">&gt;&gt;&gt; 4**33%15</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">// 加入m = 5</span><br><span class="line">&gt;&gt;&gt; 5**33%15</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">// 加入m = 15</span><br><span class="line">&gt;&gt;&gt; 15**33%15</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>到此，就看到了整个的RAS的基本过程。</p>
<h1 id="3-RSA总结"><a href="#3-RSA总结" class="headerlink" title="3. RSA总结"></a>3. RSA总结</h1><h2 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明"></a>3.1 说明</h2><ol>
<li>n会非常大，长度一般为1024个二进制位。（目前人类已经分解的最大整数，232个十进制位，768个二进制位）</li>
<li>由于需要求出φ(n)，所以根据欧函数特点，最简单的方式n 由两个质数相乘得到: 质数：p1、p2，Φ(n) &#x3D; (p1 -1) * (p2 - 1)</li>
<li>最终由φ(n)得到e 和 d。总共生成6个数字：p1、p2、n、φ(n)、e、d</li>
</ol>
<h2 id="3-2-关于RSA的安全："><a href="#3-2-关于RSA的安全：" class="headerlink" title="3.2 关于RSA的安全："></a>3.2 关于RSA的安全：</h2><p>除了公钥用到了n和e 其余的4个数字是不公开的。目前破解RSA得到d的方式如下：</p>
<ol>
<li>要想求出私钥 d。由于e*d &#x3D; φ(n)*k + 1。要知道e和φ(n);</li>
<li>e是知道的，但是要得到 φ(n)，必须知道p1 和 p2。</li>
<li>由于 n&#x3D;p1*p2。只有将n因数分解才能算出。</li>
</ol>
<h2 id="3-3-RSA特点"><a href="#3-3-RSA特点" class="headerlink" title="3.3 RSA特点"></a>3.3 RSA特点</h2><ol>
<li>相对来说比较安全（非对称加密）</li>
<li>效率低 </li>
<li>加密小数据，一般加密核心数据</li>
</ol>
<h1 id="4-终端演示"><a href="#4-终端演示" class="headerlink" title="4. 终端演示"></a>4. 终端演示</h1><p>由于Mac系统内置OpenSSL(开源加密库)，所以我们可以直接在终端上使用命令来玩RSA。OpenSSL中RSA算法常用指令主要有三个：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">genrsa</td>
<td align="left">生成并输入一个RSA密钥</td>
</tr>
<tr>
<td align="left">rsatul</td>
<td align="left">使用RSA密钥进行加密、解密、签名和验证等运算</td>
</tr>
<tr>
<td align="left">rsa</td>
<td align="left">处理RSA密钥的格式转化等问题</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 使用命令行演示</span><br><span class="line">// 1. 生成RSA密钥，密钥长度为1024bit</span><br><span class="line">&gt; openssl genrsa -out private.pem 1024</span><br><span class="line"></span><br><span class="line">// 2. 从私钥中提取公钥</span><br><span class="line">&gt; openssl rsa -in private.pem -pubout -out public.pem</span><br><span class="line"></span><br><span class="line">// 3. 将私钥转换为明文信息</span><br><span class="line">&gt; openssl rsa -in private.pem -text -out private.txt</span><br><span class="line"></span><br><span class="line">// 4. 通过公钥加密 首先创建一个message.txt文件，并输入内容</span><br><span class="line">&gt; vi message.txt </span><br><span class="line">&gt; openssl rsautl -encrypt -in message.txt -inkey public.pem -pubin -out enc.txt</span><br><span class="line"></span><br><span class="line">// 5. 通过私钥解密</span><br><span class="line">&gt; openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt</span><br><span class="line"></span><br><span class="line">// 6. 通过私钥加密数据</span><br><span class="line">&gt; openssl rsautl -sign -in message.txt -inkey private.pem -out penc.txt</span><br><span class="line">// 7. 公钥解密数据</span><br><span class="line">&gt; openssl rsautl -verify -in penc.txt -inkey public.pem -pubin -out pdec.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="5-代码演示"><a href="#5-代码演示" class="headerlink" title="5. 代码演示"></a>5. 代码演示</h1><p>由于Xcode是没有办法直接使用pem文件的，所以需要转化，首先需要生成请求的cer文件（可以理解为证书请求文件）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl req -new -key private.pem -out rsacert.csr</span><br><span class="line">-----</span><br><span class="line">&gt; Country Name (2 letter code) []:CN</span><br><span class="line">&gt; State or Province Name (full name) []:Beijing</span><br><span class="line">&gt; Locality Name (eg, city) []:Chaoyang</span><br><span class="line">&gt; Organization Name (eg, company) []:Wangjing</span><br><span class="line">&gt; Organizational Unit Name (eg, section) []:alan.com</span><br><span class="line">&gt; Common Name (eg, fully qualified host name) []:alan.com</span><br><span class="line">&gt; Email Address []:alan@163.com</span><br><span class="line"></span><br><span class="line">&gt; Please enter the following &#x27;extra&#x27; attributes</span><br><span class="line">&gt; to be sent with your certificate request</span><br><span class="line">// 这里不使用密码，其他根据要求自己填写。</span><br><span class="line">&gt; A challenge password []:</span><br></pre></td></tr></table></figure>

<p>拿到csr文件之后，需要去请求签名文件，一般用于服务器，下发证书，比如https</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt</span><br></pre></td></tr></table></figure>

<p>然后我们通过crt证书生成Xcode可用的p12证书。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt</span><br><span class="line">// 注意这里需要输入密码，123456</span><br></pre></td></tr></table></figure>

<p>在iOS系统钟，ctr文件是无法直接使用的，所以还需要把ctr文件转化为der文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; openssl x509 -outform der -in rsacert.crt -out rsacert.der</span><br></pre></td></tr></table></figure>


<p>生成的rsacert.der和p.p12文件就相当于我们要使用的公钥和私钥。</p>
<p>正常情况下，客户端不会同时存在公钥和私钥，因为这样做没有意义。客户端一般存放的是公钥，私钥在服务端。代码使用就不放了，这里有一套<a target="_blank" rel="noopener" href="https://github.com/ideawu/Objective-C-RSA">Github Objective-c-RSA</a>代码。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>RSA终端命令</li>
<li>RSA特点<ul>
<li>RSA安全系数非常高（整个业务逻辑非常安全）</li>
<li>加密效率非常低（不能做大数据加密）</li>
<li>用来加密关键数据</li>
</ul>
</li>
</ul>
<p>感谢~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2020/03/15/OC%E5%85%B6%E5%AE%83/Universal-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/OC%E5%85%B6%E5%AE%83/Universal-Link/" class="post-title-link" itemprop="url">Universal Link</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 17:33:57" itemprop="dateCreated datePublished" datetime="2020-03-15T17:33:57+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是Universal-Links？"><a href="#什么是Universal-Links？" class="headerlink" title="什么是Universal Links？"></a>什么是Universal Links？</h2><p>iOS9之后，Apple推出的一种通用链接，能够方便的通过https链接来启动APP，通过唯一的网址，不需要特别的schema就可以链接一个特定的视图到APP。<br>这也就设计到universal links的几个特性：</p>
<ol>
<li>Unique：唯一性，不像自定义Url schemes那样，因为他使用到了你网站的http或者https链接</li>
<li>Secure：安全性，当用户安装应用时，iOS会检测你上传到服务器上的文件，以确保你的网站允许其代表应用打开你的应用。</li>
<li>Flexible：灵活性，当没有安装你的app时universal links也是可以正常使用的，当点击link时会直接在safari中打开url。</li>
<li>Simple：一个url可以为app和web提供服务。</li>
<li>Private：其他app可以与你的app通信，不需要知道你的应用程序是否安装。</li>
</ol>
<h2 id="配置Universal-links"><a href="#配置Universal-links" class="headerlink" title="配置Universal links"></a>配置Universal links</h2><p>配置Universal links需要网站与app协同处理，两端都需要做一些工作。</p>
<h3 id="创建并上传关联文件"><a href="#创建并上传关联文件" class="headerlink" title="创建并上传关联文件"></a>创建并上传关联文件</h3><p>首先，你的网站必须支持https。<br><br>然后，创建apple-app-site-association文件，注意一定是没有.json后缀的，在未压缩的情况下，文件大小不能超过128KB。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;applinks&quot;: &#123;</span><br><span class="line">        &quot;apps&quot;: [],</span><br><span class="line">        &quot;details&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;/wwdc/news/&quot;, &quot;/videos/wwdc/2015/*&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;*&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>appID：</b>是由TeamID+BundleId组成，TeamID可以通过开发者账号来查看，Bundle ID可以直接在工程里查看。<br></p>
<p><b>paths：</b>是一个数组类型用来指定网站路径，并且是大小写敏感的：<br>使用* 指定整个网站，在域名下的任何地址都可以打开App。<br><br>“&#x2F;wwdc&#x2F;news&#x2F;”指定链接，以指定网站的某些部分.<br><br>还可以使用“?”匹配任何单个字符，”&#x2F;foo&#x2F;*&#x2F;bar&#x2F;201?&#x2F;mypage”</p>
<p>创建好apple-app-site-association文件后，将其上传到web服务器的跟目录下或者<code>.well-known</code>子目录下。<b>文件是通过https访问不需要有任何重定向。</b>然后你可以直接在浏览器中输入domain&#x2F;apple-app-site-association或者domain&#x2F;.well-known&#x2F;apple-app-site-association访问你所上传的文件。</p>
<p>通过Apple的测试网站可以检测你上传的文件是否正确。<a target="_blank" rel="noopener" href="https://search.developer.apple.com/appsearch-validation-tool/">传送门</a></p>
<p><b>注意：</b></p>
<blockquote>
<p>在用Nginx处理文件的MIME Type配置时，在域名下针对该文件进行处理，也就是说response的Content-Type必须设置为”application&#x2F;json“。<br>使用Nginx处理文件的MIME Type配置，在server的某个域名下针对该文件处理</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /apple-app-site-association &#123;</span><br><span class="line">    default_type application/json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><ol>
<li><p>需要支持Universal links的话，需要将开发者中心的配置APPlication Services列表中的ASSociated Domains变成Enabled。</p>
</li>
<li><p>在项目targets-&gt;Capabilities-&gt;Associated Domains中配置App link。在这里需要注意一下，有的域名为<a target="_blank" rel="noopener" href="http://www.abc.com和abc.com,这两个对于universal/">www.abc.com和abc.com，这两个对于Universal</a> links来说是不同的域名，所以，如果你的网站是这两个都需要做处理的话，需要将这两个域名都放在associate domains列表下。在添加时都要将<code>applinks:</code>放在域名前面。<br> 例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applinks:www.abc.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需要手动的添加<code>entitlements</code>，当添加domain之后，系统会自动添加相应的文件到工程，如果没有的情况下，只能通过手动添加。 </p>
</li>
<li><p>在AppDelegate中调用方法来处理Universal links的回调。</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application continueUserActivity:(<span class="built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="type">void</span> (^)(<span class="built_in">NSArray</span> * _Nullable))restorationHandler</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ([userActivity.activityType isEqualToString:<span class="built_in">NSUserActivityTypeBrowsingWeb</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *webUrl = userActivity.webpageURL;</span><br><span class="line">        <span class="keyword">if</span> ([webUrl.host isEqualToString:<span class="string">@&quot;domain&quot;</span>]) &#123;</span><br><span class="line">            <span class="comment">//打开对应页面</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不能打开，使用Safari 打开</span></span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication]openURL:webUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里回传过来一个<code>NSUserActivity</code>类型的数据，对该数据处理来跳转相应的界面。也就不再多说了。<br>到此整体的流程就已经处理完了。相关的内容介绍还是推荐看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2">官方文档</a>，写的比较细致。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>apple-app-site-association文件上传一定不要有<code>.json</code>后缀，那些隐藏后缀名的需要注意。</li>
<li>web server必须支持https</li>
<li>上传文件最好在根目录下，官方说也可以在根目录下的<code>.well-known</code>目录下。</li>
<li>Xcode中配置Associated Domians时，一定要添加<code>applinks:</code>前缀。最多添加20-30条。</li>
<li>app在<b>安装</b>的时候会访问<code>domain</code>获取<code>apple-app-site-association</code>文件,这个可以通过抓包来获取。不是在打开app时访问。</li>
<li>直接dev打包到手机上应该就可以测试，保证网络畅通。</li>
<li>最简单的方式检测Universal links是否有效，将那个链接拷贝的备忘录中（imessage、邮件），直接点击链接会跳转到App，或者长按，会在弹出的ActionSheet中第二个显示<code>在xxx中打开</code>。</li>
<li>一定是从上级页面（网页）<b>点击触发</b> 的Universal links。</li>
<li>用 Safari 打开目标域名，或者在其他 App 里用 SFSafariViewController, WKWebView, UIWebView 打开目标域名，都可以达到效果。</li>
</ol>
<h2 id="那些坑"><a href="#那些坑" class="headerlink" title="那些坑"></a>那些坑</h2><h3 id="1-跨域跳转：饿了么遇到的一个问题"><a href="#1-跨域跳转：饿了么遇到的一个问题" class="headerlink" title="1. 跨域跳转：饿了么遇到的一个问题"></a>1. 跨域跳转：<a target="_blank" rel="noopener" href="http://mobilists.eleme.io/2016/01/10/%E7%AA%81%E7%A0%B4%E5%BE%AE%E4%BF%A1%E8%B7%B3%E8%BD%AC%E9%99%90%E5%88%B6%EF%BC%8DUniversal-Links%E9%82%A3%E4%BA%9B%E5%9D%91/">饿了么遇到的一个问题</a></h3><p>这里的问题，就是我们将链接复制在备忘录里发现可以拉起App，但是放在网页里，点击却是没有任何效果，这个几乎就是跨域的锅。</p>
<p>这个应该是在iOS9.2之后出现的问题。假设当前网页是abc.com&#x2F;a，在这里有一个链接跳转到abc.com&#x2F;b,还是在同一个域名abc.com下。这时点击，系统将不会进行拉起App的操作，必须在不同的域名下比如abcd.com&#x2F;b，这样才会根据关联文件去判断是否要拉起app。这个时候就需要在Xcode中添加一个域名在碰到跨域问题不能拉起App时，链接改为其他的域名。<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32751225/ios9-universal-links-does-not-work/32751734#32751734">这里也有解释</a></p>
<h3 id="2-选择性跳转"><a href="#2-选择性跳转" class="headerlink" title="2. 选择性跳转"></a>2. 选择性跳转</h3><p>这个也是一个坑，苹果会通过Universal links记录用户的行为习惯，当你通过一个Universal links成功的拉起了App，这时你发现在status bar右上角有一个小按钮（带一个小箭头）。当你点击了之后会成功的在Safari中打开，这时，苹果就认为你不需要这个Universal links拉起App，此后在通过这个Universal links点击时，都是在safari或者网页中打开，不会再拉起App。这个是有办法补救的，通过在Safari中点击链接长按，在app中打开。此后通过Universal links就可以拉起App了。也就说，苹果会记录最后一次Universal links的跳转情况来判断是否需要拉起app。</p>
<p>这里感觉第一个的跨域跳转与第二个的选择性跳转是很类似的，第一个在当前域名下点击Universal links不能拉起app就相当于当前系统认为你这个universal links本身就在浏览器中打开的，认为不需要拉起app。</p>
<blockquote>
<p>When a user taps a universal link that you handle, iOS also examines the user’s recent choices to determine whether to open your app or your website. For example, a user who has tapped a universal link to open your app can later choose to open your website in Safari by tapping a breadcrumb button in the status bar. After the user makes this choice, iOS continues to open your website in Safari until the user chooses to open your app by tapping OPEN in the Smart App Banner on the webpage.</p>
</blockquote>
<h3 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h3><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2">官方文档</a></p>
<p>通过Apple的测试网站可以检测你上传的文件是否正确。<a target="_blank" rel="noopener" href="https://search.developer.apple.com/appsearch-validation-tool/">传送门</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://liujiaboy.github.io/2020/03/15/OC%E5%85%B6%E5%AE%83/Create-private-pods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="不会飞的小白">
      <meta itemprop="description" content="一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会飞的小白">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/OC%E5%85%B6%E5%AE%83/Create-private-pods/" class="post-title-link" itemprop="url">创建pod私有库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 17:00:47" itemprop="dateCreated datePublished" datetime="2020-03-15T17:00:47+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:13:15" itemprop="dateModified" datetime="2022-12-24T17:13:15+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看本地cocoaPod库 <code>cd ~/.cocoapods/repos</code>在repos文件夹下面，可以看到你当前存在的一些库，当你创建了自己的私有仓库时，也会在这里显示。</p>
<p>按照正常逻辑来看，私有库是一个地址，版本号管理库是一个地址，最好不要把两者放在一起，会显得很乱。<br>所以创建私有库，我们需要创建两个库：一个是私有仓库repo，用来做私有库的版本管理；另一个是私有代码库，用来做代码编写。</p>
<h2 id="创建私有仓库-repo"><a href="#创建私有仓库-repo" class="headerlink" title="创建私有仓库 repo"></a>创建私有仓库 repo</h2><p>这里的私有空间是指私有库存放的位置，repo是repository（存储库）的缩写，如果私有库的podSpec和代码存放在一起就会显得很乱，所有通常的做法就是再私有空间只存放私有库的podSpec文件（可以理解为版本号）。</p>
<h3 id="创建远程私有repo"><a href="#创建远程私有repo" class="headerlink" title="创建远程私有repo"></a>创建远程私有repo</h3><p>这里使用码云，可以免费创建多个私有工程。例如创建了一个私有存储库：<a target="_blank" rel="noopener" href="https://gitee.com/devAlan/PrivateRepo%E3%80%82%EF%BC%88%E5%B7%B2%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%89">https://gitee.com/devAlan/PrivateRepo。（已不存在）</a></p>
<h3 id="添加到本地仓库中"><a href="#添加到本地仓库中" class="headerlink" title="添加到本地仓库中"></a>添加到本地仓库中</h3><p><code>pod repo add [本地仓库repo名称] [远程repo地址]</code><br><code>pod repo add PrivateRepo https://gitee.com/devAlan/PrivateRepo</code><br>使用上面步骤就可以将远程的私有版本存储仓库添加到本地。在Finder中查看repos中就可以发现增加了一个文件夹PrivateRepo。</p>
<h2 id="创建私有代码库"><a href="#创建私有代码库" class="headerlink" title="创建私有代码库"></a>创建私有代码库</h2><p>创建代码私有库有两种方式，第一种是我们正常的使用Xcode创建项目的过程，另一种是使用pod模板来创建的过程，推荐使用模板来创建。</p>
<h3 id="创建一个私人代码库"><a href="#创建一个私人代码库" class="headerlink" title="创建一个私人代码库"></a>创建一个私人代码库</h3><p>创建一个私人代码库，在创建时添加MIT License和README。<br>使用模板创建时，创建空仓库。</p>
<h4 id="将仓库clone到本地，添加项目工程文件。"><a href="#将仓库clone到本地，添加项目工程文件。" class="headerlink" title="将仓库clone到本地，添加项目工程文件。"></a>将仓库clone到本地，添加项目工程文件。</h4><h4 id="添加-podspec文件"><a href="#添加-podspec文件" class="headerlink" title="添加.podspec文件"></a>添加.podspec文件</h4><p>“.podspec”文件是这个代码库的pod描述文件，使用pod命令创建空白模板。<br><br><code>pod spec create 项目名称</code><br><br>这里使用上面的私有代码库创建<code>pod spec create privateAdd</code>。</p>
<p>需要注意一下：生成的默认的podspec文件中，所有没有注释掉的都必须填写正确。</p>
<h3 id="使用pod模板创建"><a href="#使用pod模板创建" class="headerlink" title="使用pod模板创建"></a>使用pod模板创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pod lib creare [项目名称]（最好与远端一致）</span><br><span class="line"></span><br><span class="line">// 以下为模板创建时，会用到的一些选项问题，根据实际选择就好。</span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line"> &gt; iOS</span><br><span class="line"></span><br><span class="line">// 选择编程语言</span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; ObjC</span><br><span class="line"></span><br><span class="line">/// 是否需要添加本地库</span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; No</span><br><span class="line"></span><br><span class="line">// 是否有frameworks</span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line"> &gt; None</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line"> &gt; No</span><br><span class="line"></span><br><span class="line">// 创建的文件前缀</span><br><span class="line">What is your class prefix?</span><br><span class="line"> &gt; HM</span><br></pre></td></tr></table></figure>
<p>上述命令操作完成之后，会生成相应的模板文件。<br>代码文件都存放在<code>/[项目名称]/class/</code>下。<br>图片都存放在<code>/[项目名称]/Assets/</code>下。</p>
<h3 id="将本地-Lib-工程与远程私有-lib-Git-仓库关联"><a href="#将本地-Lib-工程与远程私有-lib-Git-仓库关联" class="headerlink" title="将本地 Lib 工程与远程私有 lib Git 仓库关联"></a>将本地 Lib 工程与远程私有 lib Git 仓库关联</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 远程仓库地址  </span><br><span class="line">    git错误处理</span><br><span class="line">    git pull --rebase origin master </span><br><span class="line">    git push -u origin master           </span><br><span class="line">    </span><br><span class="line">git push origin master   #同步操作</span><br><span class="line">    文件冲突 （保留一份 license 和 readme）</span><br><span class="line">    git pull origin master --allow-unrelated-histories</span><br><span class="line">    git mergetool</span><br></pre></td></tr></table></figure>

<h2 id="编辑“-podspec”文件"><a href="#编辑“-podspec”文件" class="headerlink" title="编辑“.podspec”文件"></a>编辑“.podspec”文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Be sure to run `pod spec lint PrivateAdd_v2.podspec&#x27; to ensure this is a</span></span><br><span class="line"><span class="comment">#  valid spec and to remove all comments including this before submitting the spec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html</span></span><br><span class="line"><span class="comment">#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明</span></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  These will help people to find your library, and whilst it</span></span><br><span class="line">  <span class="comment">#  can feel like a chore to fill in it&#x27;s definitely to your advantage. The</span></span><br><span class="line">  <span class="comment">#  summary should be tweet-length, and the description more in depth.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># 私有库名称</span></span><br><span class="line">  s.name         = <span class="string">&quot;PrivateAdd_v2&quot;</span>    </span><br><span class="line">  <span class="comment"># 版本号，跟当前版本tag有关</span></span><br><span class="line">  s.version      = <span class="string">&quot;0.0.1&quot;</span>            </span><br><span class="line">  <span class="comment"># 项目描述</span></span><br><span class="line">  s.summary      = <span class="string">&quot;A short description of PrivateAdd_v2.&quot;</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># This description is used to generate tags and improve search results.</span></span><br><span class="line">  <span class="comment">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class="line">  <span class="comment">#   * Try to keep it short, snappy and to the point.</span></span><br><span class="line">  <span class="comment">#   * Write the description between the DESC delimiters below.</span></span><br><span class="line">  <span class="comment">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span></span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 主页，自动生成的podspec文件中所有的EXAMPLE都需要改</span></span><br><span class="line">  s.homepage     = <span class="string">&quot;http://EXAMPLE/PrivateAdd_v2&quot;</span> </span><br><span class="line">  <span class="comment"># 项目截图</span></span><br><span class="line">  <span class="comment"># s.screenshots  = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot;  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Licensing your code is important. See http://choosealicense.com for more info.</span></span><br><span class="line">  <span class="comment">#  CocoaPods will detect a license file if there is a named LICENSE*</span></span><br><span class="line">  <span class="comment">#  Popular ones are &#x27;MIT&#x27;, &#x27;BSD&#x27; and &#x27;Apache License, Version 2.0&#x27;.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 项目遵守的协议</span></span><br><span class="line">  s.license      = <span class="string">&quot;MIT (example)&quot;</span>      </span><br><span class="line">  <span class="comment"># s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify the authors of the library, with email addresses. Email addresses</span></span><br><span class="line">  <span class="comment">#  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also</span></span><br><span class="line">  <span class="comment">#  accepts just a name if you&#x27;d rather not provide an email address.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify a social_media_url where others can refer to, for example a twitter</span></span><br><span class="line">  <span class="comment">#  profile URL.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 作者信息</span></span><br><span class="line">  s.author             = &#123; <span class="string">&quot;liujiajia&quot;</span> =&gt; <span class="string">&quot;liujiajia@gerrit.babytree-inc.com&quot;</span> &#125;  </span><br><span class="line">  <span class="comment"># Or just: s.author    = &quot;liujiajia&quot;</span></span><br><span class="line">  <span class="comment"># s.authors            = &#123; &quot;liujiajia&quot; =&gt; &quot;liujiajia@gerrit.babytree-inc.com&quot; &#125;</span></span><br><span class="line">  <span class="comment"># s.social_media_url   = &quot;http://twitter.com/liujiajia&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  If this Pod runs only on iOS or OS X, then specify the platform and</span></span><br><span class="line">  <span class="comment">#  the deployment target. You can optionally include the target after the platform.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.platform     = :ios           # 平台</span></span><br><span class="line">  <span class="comment"># 平台以及版本号</span></span><br><span class="line">  <span class="comment"># s.platform     = :ios, &quot;5.0&quot;    </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#  When using multiple platforms</span></span><br><span class="line">  <span class="comment"># s.ios.deployment_target = &quot;5.0&quot;</span></span><br><span class="line">  <span class="comment"># s.osx.deployment_target = &quot;10.7&quot;</span></span><br><span class="line">  <span class="comment"># s.watchos.deployment_target = &quot;2.0&quot;</span></span><br><span class="line">  <span class="comment"># s.tvos.deployment_target = &quot;9.0&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Specify the location from where the source should be retrieved.</span></span><br><span class="line">  <span class="comment">#  Supports git, hg, bzr, svn and HTTP.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#当前私有库资源的git地址，相应的tag，这里直接使用代码来标识使用和当前tag一样的值</span></span><br><span class="line">  s.source       = &#123; :git =&gt; <span class="string">&quot;http://EXAMPLE/PrivateAdd_v2.git&quot;</span>, :tag =&gt; <span class="string">&quot;#&#123;s.version&#125;&quot;</span> &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  CocoaPods is smart about how it includes source code. For source files</span></span><br><span class="line">  <span class="comment">#  giving a folder will include any swift, h, m, mm, c &amp; cpp files.</span></span><br><span class="line">  <span class="comment">#  For header files it will include any header in the folder.</span></span><br><span class="line">  <span class="comment">#  Not including the public_header_files will make all headers public.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 需要引用的文件代码，classes文件夹下的所有.h.m文件。这里的路径都是相对路径</span></span><br><span class="line">  s.source_files  = <span class="string">&quot;Classes&quot;</span>, <span class="string">&quot;Classes/**/*.&#123;h,m&#125;&quot;</span> </span><br><span class="line">  <span class="comment"># 排除掉哪些文件，不被包含的文件，这里是Classes/Exclude文件夹下的所有</span></span><br><span class="line">  s.exclude_files = <span class="string">&quot;Classes/Exclude&quot;</span>   </span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.public_header_files = &quot;Classes/**/*.h&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  A list of resources included with the Pod. These are copied into the</span></span><br><span class="line">  <span class="comment">#  target bundle with a build phase script. Anything else will be cleaned.</span></span><br><span class="line">  <span class="comment">#  You can preserve files from being cleaned, please don&#x27;t preserve</span></span><br><span class="line">  <span class="comment">#  non-essential files like tests, examples and documentation.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.resource  = &quot;icon.png&quot;            # 资源文件</span></span><br><span class="line">  <span class="comment"># s.resources = &quot;Resources/*.png&quot;     # 所有资源文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  Link your library with frameworks, or libraries. Libraries do not include</span></span><br><span class="line">  <span class="comment">#  the lib prefix of their name.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.framework  = &quot;UIKit&quot;          # 依赖的系统framework，去掉后缀</span></span><br><span class="line">  <span class="comment"># s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.library   = &quot;iconv&quot;                   # 依赖的系统library</span></span><br><span class="line">  <span class="comment"># s.libraries = &quot;iconv&quot;, &quot;xml2&quot;, &quot;z&quot;      # 依赖的library，去除前缀和后缀，例如“libz.tbd”，则直接引用为&quot;z&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># s.vendored_frameworks = &quot;*.framework&quot;, &quot;*.framework&quot;          #依赖那些静态库</span></span><br><span class="line">  <span class="comment"># s.vendored_libraries = &quot;*.a&quot;, &quot;*.a&quot;           # 依赖哪些静态library</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#  If your library depends on compiler flags you can set them in the xcconfig hash</span></span><br><span class="line">  <span class="comment">#  where they will only apply to your library. If you depend on other Podspecs</span></span><br><span class="line">  <span class="comment">#  you can include multiple dependencies to ensure it works.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.requires_arc = true       # 是否开启ARC</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.xcconfig = &#123; &quot;GCC_PREPROCESSOR_DEFINITIONS&quot; =&gt; &#x27;HMTIMEINPREGNACYAPP=1&#x27;, &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;  </span></span><br><span class="line">  <span class="comment"># 这里配置一些内容，&quot;GCC_PREPROCESSOR_DEFINITIONS&quot;：定义一个宏，</span></span><br><span class="line">  <span class="comment"># &quot;HEADER_SEARCH_PATHS&quot;：如果引用该私有库，则会在主工程中寻找文件夹下的内容</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;        # 使用了pod，依赖哪些库</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.prefix_header_contents = &lt;&lt;-EOS     #这里会生成一个默认pch文件，作用于Xcode工程中添加的pch文件一样。</span></span><br><span class="line">  <span class="comment">#      #import &lt;UIKit/UIKit.h&gt;</span></span><br><span class="line">  <span class="comment"># EOS</span></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这里有一个需要注意的地方，在创建私有库的时候，找不到MIT LICENSE证书，这里讲license修改一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二级库subspec"><a href="#二级库subspec" class="headerlink" title="二级库subspec"></a>二级库subspec</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.subspec &#x27;UIView+Category&#x27; do |ss| </span><br><span class="line">  ss.source_files = &quot;PrivateAdd_v3/PrivateAdd_v3/Classes/UIView+Category/*.&#123;h,m&#125;&quot;</span><br><span class="line">  ss.framework = &quot;UIKit&quot;</span><br><span class="line">  # ss.vendored_libraries = &#x27;/*.a&#x27;</span><br><span class="line">  # ss.vendored_frameworks = &#x27;/*.framework&#x27;</span><br><span class="line">  # ss.resource = &#x27;Moments/ForPregnacy/**/*.bundle&#x27;, &#x27;Moments/ForPregnacy/**/*.png&#x27;, &#x27;Moments/ForPregnacy/**/*.mp3&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>使用subspec关键字，并添加指定文件就行。</p>
<h2 id="验证私有库"><a href="#验证私有库" class="headerlink" title="验证私有库"></a>验证私有库</h2><p>修改完相应的代码块之后，开始验证私有库配置是否正确。</p>
<h3 id="本地验证"><a href="#本地验证" class="headerlink" title="本地验证"></a>本地验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br><span class="line">// 如果使用了私有库，则使用--sources来标明，给出具体地址</span><br><span class="line">pod lib lint --sources=[私有仓库repo地址],[私有库git地址],https://github.com/CocoaPods/Specs.git</span><br></pre></td></tr></table></figure>

<p>如果出现错误，基本上都是podspec文件中的配置出现了问题，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint</span><br><span class="line"></span><br><span class="line"> -&gt; PrivateAdd_v2 (0.0.1)</span><br><span class="line">    - WARN  | attributes: Missing required attribute `license`.</span><br><span class="line">    - WARN  | license: Missing license type.</span><br><span class="line">    - ERROR | description: The description is empty.</span><br><span class="line">    - ERROR | [iOS] unknown: Encountered an unknown error (The `PrivateAdd_v2` pod failed to validate due to 1 error:</span><br><span class="line">    - WARN  | attributes: Missing required attribute `license`.</span><br><span class="line">    - WARN  | license: Missing license type.</span><br><span class="line">    - ERROR | description: The description is empty.</span><br><span class="line"></span><br><span class="line">) during validation.</span><br><span class="line"></span><br><span class="line">[!] PrivateAdd_v2 did not pass validation, due to 2 errors and 2 warnings.</span><br><span class="line">You can use the `--no-clean` option to inspect any issue.</span><br></pre></td></tr></table></figure>
<p>这就需要将上面的错误修改掉。</p>
<p>一般情况下出现警告在后面添加<code>pod lib lint --allow-warnings</code>，就可以通过验证了。验证通过会提示passed validation。</p>
<p>如果依赖一些静态库（.framework，.a），则在命令后面添加<code>--use-libraries</code>，表示依赖了静态库。</p>
<p>如果报错不是很明显，这命令后添加<code>--verbose</code>，会输出验证的过程，并给出报错信息。</p>
<h3 id="远端验证"><a href="#远端验证" class="headerlink" title="远端验证"></a>远端验证</h3><p><code>pod spec lint</code>，一般情况下私有库都是存在远程git上的，所以基本上只在第一次验证使用本地验证之后，就可以直接使用远端验证了。<br>但是一般情况下，创建的私有代码库如果是私有的（并不是官方的），这时候，我们在做远端验证时，需要添加代码地址。，不然pod会默认从官方repo查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources=[私有仓库repo地址],[私有库git地址],https://github.com/CocoaPods/Specs.git</span><br><span class="line"></span><br><span class="line">// 或者只添加前面两项，最后一项可以忽略</span><br><span class="line">pod spec lint --sources=[私有仓库repo地址],[私有库git地址]</span><br></pre></td></tr></table></figure>
<p>如果出现一些警告，可以直接在命令最后添加<code>--allow-warnings</code>来屏蔽警告。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources=https://gitee.com/devAlan/PrivateRepo,https://gitee.com/devAlan/PrivateAdd_v3.git,https://github.com/CocoaPods/Specs.git --allow-warnings</span><br><span class="line"></span><br><span class="line">pod spec lint --sources=https://gitee.com/devAlan/PrivateRepo,https://gitee.com/devAlan/PrivateAdd_v3.git --allow-warnings</span><br></pre></td></tr></table></figure>

<h2 id="发布私有库"><a href="#发布私有库" class="headerlink" title="发布私有库"></a>发布私有库</h2><p>将podspec文件推送到私有空间repo，在发布时一定要记住，已经做了tag处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo push [私有仓库repo] [私有库podspec文件地址] --allow-warnings</span><br><span class="line">pod repo push [私有仓库repo] [私有库podspec文件地址] --sources=[私有仓库repo地址],[私有库地址],https://gitee.com/devAlan/PrivateAdd_v2.git --allow-warnings</span><br></pre></td></tr></table></figure>
<p>由于基本上的所有命令操作都是在该私有库文件夹下，所以不用管podspec的文件位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push PrivateRepo PrivateAdd.podspec --allow-warnings</span><br></pre></td></tr></table></figure>

<p>执行该命令时，相当于直接将podspec文件push到repo的Git地址上。</p>
<h2 id="引用私有库"><a href="#引用私有库" class="headerlink" title="引用私有库"></a>引用私有库</h2><h3 id="本地路径引用"><a href="#本地路径引用" class="headerlink" title="本地路径引用"></a>本地路径引用</h3><p>做好验证之后，如果需要测试，可以直接在podfile中引用私有库的本地路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ../是回到上一级文件目录，是以当前podfile所在文件位置决定</span><br><span class="line">pod &#x27;Private_v2&#x27;, :path =&gt; &#x27;../../Private_v2&#x27;</span><br></pre></td></tr></table></figure>
<p>这个时候如果改动Private_v2中的代码就是直接改动。</p>
<h3 id="repo引用"><a href="#repo引用" class="headerlink" title="repo引用"></a>repo引用</h3><p>在podfile中先添加source，然后直接pod引入，当然在引用私有库的时候，不仅需要需要私有仓库repo的权限，还需要有私有库的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source &#x27;https://gitee.com/devAlan/PrivateRepo&#x27;</span><br><span class="line"> </span><br><span class="line">pod &#x27;Private_v2&#x27;</span><br><span class="line"></span><br><span class="line">#或者使用下面的方式</span><br><span class="line">#pod &#x27;Private_v2&#x27;, :git=&gt; &#x27;https://gitee.com/devAlan/PrivateRepo&#x27;</span><br></pre></td></tr></table></figure>


<h2 id="pod-常用命令"><a href="#pod-常用命令" class="headerlink" title="pod 常用命令"></a>pod 常用命令</h2><ol>
<li><p>安装podfile中依赖的命令<br><code>pod install</code><br><code>pod update</code><br><code>--no-repo-update</code>   不需要更新repo<br><code>--repo-update</code>   更新repo</p>
</li>
<li><p>repo相关<br><code>pod repo list</code><br><code>pod repo remove xxx</code>   移除一个本地repo<br><code>pod repo add [本地仓库repo名称] [远程repo地址]</code>  远程版本空间添加到本地</p>
</li>
<li><p>私有库创建相关<br><code>pod lib lint</code>      本地验证<br><code>pod spec lint</code>     远程验证<br><code>pod repo push [本地仓库repo] [*.podspec]</code>  发布版本到repo<br><code>--source=[私有repo地址][私有代码库地址][pod地址]</code><br><code>--allow-warnings</code>  忽略warning<br><code>--use-libraries</code>   使用了第三方的framework或者.a文件<br><code>--verbose</code>         打印流程，可以快速定位失败原因</p>
</li>
<li><p>podspec中使用到的*<br><code>/**</code> 子目录下所有文件夹<br><code>/*</code>    目录下所有文件</p>
</li>
</ol>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li><p>私有库依赖主项目中的某些文件，如果是强制性的依赖，导致本地验证和远程验证都无法通过，所以更别说发布了。<br> 这种是没有完全的组件化。我们需要在podspec中添加HEADER_SEARCH_PATHS，添加指定位置文件路径。这里的路径也是相对路径。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.xcconfig = &#123; &quot;GCC_PREPROCESSOR_DEFINITIONS&quot; =&gt; &#x27;HMTIMEINPREGNACYAPP=1&#x27;, </span><br><span class="line">&quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SRCROOT)/usr/include/libxml2&quot;, $(SRCROOT)/../Commen/** &#125;  </span><br></pre></td></tr></table></figure>
<p>但是这样做仍然无法通过验证，这就需要我们将私有空间repo pull到本地，手动创建版本号文件夹添加podspec文件，然后push。</p>
</li>
<li><p>在上面的代码中还有一个 <code>GCC_PREPROCESSOR_DEFINITIONS</code>，这是定义一个宏，可以在Project-Build Settings - Preprocessor Macros下看到。</p>
<p>可以配合一些没有必要引入私有代码库中的文件来使用。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="不会飞的小白"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">不会飞的小白</p>
  <div class="site-description" itemprop="description">一只iOS程序猿，会陆陆续续的把之前的一些总结搬到这里。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liujiaboy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liujiaboy" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:alan129@163.com" title="E-Mail → mailto:alan129@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1768698000" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1768698000" rel="noopener" target="_blank"><i class="weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不会飞的小白</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
